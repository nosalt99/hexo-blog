{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/img/background.jpg","path":"img/background.jpg","modified":0,"renderable":0},{"_id":"source/img/favicon.jpg","path":"img/favicon.jpg","modified":0,"renderable":0},{"_id":"source/img/loading.gif","path":"img/loading.gif","modified":0,"renderable":0},{"_id":"source/img/police_beian.png","path":"img/police_beian.png","modified":0,"renderable":0},{"_id":"node_modules/hexo-theme-fluid/source/css/gitalk.css","path":"css/gitalk.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/boot.js","path":"js/boot.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/color-schema.js","path":"js/color-schema.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/events.js","path":"js/events.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/img-lazyload.js","path":"js/img-lazyload.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/leancloud.js","path":"js/leancloud.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/local-search.js","path":"js/local-search.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/plugins.js","path":"js/plugins.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/xml/local-search.xml","path":"xml/local-search.xml","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/avatar.png","path":"img/avatar.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/default.png","path":"img/default.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/favicon.png","path":"img/favicon.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/loading.gif","path":"img/loading.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/police_beian.png","path":"img/police_beian.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/lib/hint/hint.min.css","path":"lib/hint/hint.min.css","modified":0,"renderable":1},{"_id":"source/img/avatar.jpg","path":"img/avatar.jpg","modified":0,"renderable":0},{"_id":"source/img/qr_code.png","path":"img/qr_code.png","modified":0,"renderable":0}],"Cache":[{"_id":"source/.DS_Store","hash":"3de8b4c5f1681bbb46b9f509ee0c09a5523d1c14","modified":1625380934232},{"_id":"source/CNAME","hash":"ad9a8369ae211e51d4cda3d0b137232aa8efab65","modified":1625373252745},{"_id":"source/_posts/hello-world.md","hash":"5a20738da9ec5a5b3503c7a6f9f349793aaf1795","modified":1625372044835},{"_id":"source/img/background.jpg","hash":"d832d49b5037a64b82a291a8a797195ddad7d9fb","modified":1625377673518},{"_id":"source/img/favicon.jpg","hash":"ac1c92e8aaaedafe50d1d8f83732ef655c137373","modified":1625377673520},{"_id":"source/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1625377673522},{"_id":"source/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1625377673522},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_category/category.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_tag/tag.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.eslintrc","hash":"4bc2b19ce2b8c4d242f97d4ccf2d741e68ab0097","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.gitattributes","hash":"a54f902957d49356376b59287b894b1a3d7a003f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.editorconfig","hash":"33218fbd623feb43edf5f99f15965392cecc44a6","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/README.md","hash":"523b9db3801ca892124502c17d72864457cc4b21","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/README_en.md","hash":"ca8fd19a4948de1f253616a62c0e8a7d81f692f5","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/LICENSE","hash":"df5b54be535593d5442cebafbea34eb9bd69b987","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/_config.yml","hash":"dac9d10d95b9e179e8cd7c439300b450db51f0c2","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/gulpfile.js","hash":"a7c87a83becf7080bddd14e81a6f09ce8c3df109","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/package.json","hash":"c79d1bb1eba9ad8f8a8a85afcd68c5ed56a35c87","modified":1624101091255},{"_id":"node_modules/hexo-theme-fluid/languages/de.yml","hash":"13a6a799415fc2f6f69ebd1a399fb44426a5d641","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/languages/en.yml","hash":"a85dcc5cc21f9cab50df31e5001b8818ee62d1e2","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/languages/eo.yml","hash":"a0c7984495d4f2d33b64adfa33adebbf768a5ac3","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/languages/ja.yml","hash":"91020031a847c0361a6fd7ab990c7be4bf17529b","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/languages/zh-CN.yml","hash":"21307b4137c3d9b04bb58243747e75af0abc5a71","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/languages/zh-TW.yml","hash":"1a6d415446da11dee5c5f400e7d67544fbe743ea","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/404.ejs","hash":"689d9f4efd2a7f5edfd9b24561a7ade69d46617c","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/about.ejs","hash":"ad6fed7b646d3ca961db83db0fbe020e3a5d42ad","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/archive.ejs","hash":"472d0813ca5b88000a7bc6039f33b7e27b5a3216","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/categories.ejs","hash":"6cbd88a2ef9dd2198d72ccc1899c4966ac5f49f9","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/category.ejs","hash":"58291dfec65c36889dfce0ddc603540b67e4c598","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/index.ejs","hash":"a154785aef120988d29409847977f24069d3a3d5","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/layout.ejs","hash":"9d6ff8772bf54d7458ae4e846e5a2d1f2921b8a7","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/links.ejs","hash":"19c6db0ccebc8f59fa4ef9567a066b33223eccd6","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/page.ejs","hash":"1014b901d396f4fc445cb1ffc938d5380d894d71","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/post.ejs","hash":"79e3679a7069351a6172c281b9d09f59d7580484","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/tag.ejs","hash":"0ad89eb7c92a822980fa9a85285e6d94ad845d1d","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/tags.ejs","hash":"1d06af34b6cf1d8a20d2eb565e309326ceba309f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/bug_report_zh.md","hash":"af977ed0792508bb0766ea8afe82d34ef1e8fb3c","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/feature_request.md","hash":"c134dd57ffd269b93402ccfffe7dbe0f0b583bec","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/bug_report.md","hash":"16d33eb89ecf90f4046720fde5395d972c7ba1fd","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/feature_request_zh.md","hash":"ed08574b196447376dd74411cca664ac9227a5d4","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/question.md","hash":"ab5eab9e3ff889c4ba7fd82846e7f5b7ae15bebc","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.github/ISSUE_TEMPLATE/question_zh.md","hash":"e24b470f7aa8044499a4f5e39634e5dc43899011","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.github/workflows/limit.yaml","hash":"f8bd2edeb4424ee7a055b31583445d5d5dff91a4","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/.github/workflows/lint.yaml","hash":"64d521c9c5b61d3a4852c74894fb574082dc7009","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/beian.ejs","hash":"6ec30a9dd56341590af07f4227324f619025c109","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/archive-list.ejs","hash":"8723aa57f61134a2c1dc84cc7ea88ea366f4fda3","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/footer.ejs","hash":"39e63b3e1502803c9e8ea0c44ea662a7bbe15744","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/css.ejs","hash":"cdcb607f1104543a42beda647f3c9cf0f3d11623","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/head.ejs","hash":"248ecd01aead6e07ac1904a7b7c45395a922bcc7","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/nav.ejs","hash":"245f49aad0e4124b52aa82d981281ad9c871f1f8","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/paginator.ejs","hash":"0f38a2c238169edcb63fc46c23bfc529ff3859b7","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/scripts.ejs","hash":"b3d93135d9ae74f006da31ec54343308bbd77cb5","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/post-meta.ejs","hash":"3e0fa1731b6e54dbcf52ccf8e200e83dc4549bfa","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/search.ejs","hash":"cdd7919fa01f6ef7ccc09938d662ff3d77f5d999","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/statistics.ejs","hash":"920bc618d357d48d2b96f8758f6ae8f9488fc4d8","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/toc.ejs","hash":"3d2fb5552f373e5a0c56bc356702d807bcbcb411","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/filters/locals.js","hash":"58d0fec976f6b1d35e7ea03edc45414088acf05c","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/filters/post-filter.js","hash":"6c37e9f1ac1d6d00b3c32794e02e244dba942cd9","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/generators/pages.js","hash":"d9971f15fbb6b775e3d31a1b9b45011959395010","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/export-config.js","hash":"606131cb807846bf43776a9073fcc1473d359ec9","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/generators/local-search.js","hash":"fc2c50405b771b06b7f6cfc4e9de97b992691555","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/page.js","hash":"4607607445233b3029ef20ed5e91de0da0a7f9c5","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/url.js","hash":"99ab4551dc9c035abcc3bf4da5def2f63449d7ec","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/utils.js","hash":"9045f47c7a71aab39f16cffb3e3847b752c2e0f1","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/wordcount.js","hash":"e58d422eddb44c1be893f65f79f4c7feecfe6d5f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/index.js","hash":"44faef3e77ab08b91e4c5c6f1cd9087a9faff443","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/join-path.js","hash":"629e7deb3955f750c1cfa6fc773f412e020fcef4","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/object.js","hash":"649457796374c79e49a19bd541e4ad8e78fe8995","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/gitalk.css","hash":"a57b3cc8e04a0a4a27aefa07facf5b5e7bca0e76","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/main.styl","hash":"d5a8a59c8d1fd17d699a951e59c4ce9ae44c419d","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/button.js","hash":"3eb43a8cdea0a64576ad6b31b4df6c2bf5698d4c","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/group-image.js","hash":"4aeebb797026f1df25646a5d69f7fde79b1bcd26","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/checkbox.js","hash":"63468f7875c09d9557fe8315afc97175745d9087","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/mermaid.js","hash":"75160561e1ef3603b6d2ad2938464ab1cb77fd38","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/note.js","hash":"f52f3a005b41f48b4da274ac64710177c8d4502f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/label.js","hash":"f05a6d32cca79535b22907dc03edb9d3fa2d8176","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/boot.js","hash":"3de344ee619da989f6dccf7c2ae459fe91075983","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/color-schema.js","hash":"cc712fc71bf33d561e1ba74fe1d52d2353092171","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/events.js","hash":"4b9d2676c9544db9cc40a8c7d18456792299ba86","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/img-lazyload.js","hash":"cbdeca434ec4da51f488c821d51b4d23c73294af","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/local-search.js","hash":"bf00f5786bb8de7241f635455b67243d26656222","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/leancloud.js","hash":"b7985ac3cff9ee2722db43ee6b32b5484c43f5f2","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/plugins.js","hash":"342b1fbc30d1465687ce389a4e07f967266d5d86","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/js/utils.js","hash":"9d492fab9c26311ad0ab553c890e09b9575a76f2","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/xml/local-search.xml","hash":"8c96ba6a064705602ce28d096fd7dd9069630a55","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/img/default.png","hash":"7bb2b8ee07db305bcadee2985b81b942027ae940","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/img/favicon.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/cusdis.ejs","hash":"5f9dc012be27040bbe874d0c093c0d53958cc987","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/changyan.ejs","hash":"725a1fe23c672fca87edc57739b748c3adf705da","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/disqus.ejs","hash":"fb4502fc9204284f8b4e8dabde8477d478e826e5","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/gitalk.ejs","hash":"843bc141a4545eb20d1c92fb63c85d459b4271ec","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/livere.ejs","hash":"2264758fed57542a7389c7aa9f00f1aefa17eb87","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/remark42.ejs","hash":"d4e9532feeb02aed61bd15eda536b5b631454dac","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/twikoo.ejs","hash":"ffe08e76c9ebd4fc27715b8a60f385b3f10d0348","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/utterances.ejs","hash":"e1ed6530dfd7310f91060a75766a93ac3c39be3a","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/valine.ejs","hash":"9238063c5e2928bb6fce2b99cd25ad85e78c4d1c","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/comments/waline.ejs","hash":"5b61661fbc65752f54f99402077dbb03044149a1","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/analytics.ejs","hash":"557077a8825fffc0a2c7fe2b29f319287950244f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/math.ejs","hash":"76c4e0608ae362a265ac5e9c0fc49f75c1bc568e","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/mermaid.ejs","hash":"10ed1f9a611449d37736e17c4e251127b38b3772","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/nprogress.ejs","hash":"4c2d39ce816b8a6dcd6b53113c8695f8bd650a23","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/layout/_partial/plugins/typed.ejs","hash":"ab71df2e56b60e8e193ff827e81704e5b358a977","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/compatible-configs.js","hash":"b5fd5a2d9c463eb59318af0f47c591c485b6ad27","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/footnote.js","hash":"3b2abc5f5e3b681874637e98e047dc4969eb1983","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/hello.js","hash":"28e186c32576eb3d5d923273471a001c47fe8071","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/highlight.js","hash":"deed966f38cf0c8dee3f72e5b1f2e878510db0e1","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/lazyload.js","hash":"a2d08e3b9f98b6371b2e64d664f079c99571494b","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/merge-configs.js","hash":"c1db1a4f9eca6e36b660530641e3a4fb6a30c8d8","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_functions/base.styl","hash":"2e46f3f4e2c9fe34c1ff1c598738fc7349ae8188","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_mixins/base.styl","hash":"542e306ee9494e8a78e44d6d7d409605d94caeb3","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/pages.styl","hash":"b8e887bc7fb3b765a1f8ec9448eff8603a41984f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_variables/base.styl","hash":"26d29403d8ecb0b533e63bde3ca73b2c91f171ff","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/lib/hint/hint.min.css","hash":"b38df228460ebfb4c0b6085336ee2878fe85aafe","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_about/about.styl","hash":"15d2786d00418e61022475194ad76445d68e27ea","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_archive/archive.styl","hash":"6e6f22b664199772370b59ce1678b0c148b5849f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/base.styl","hash":"dabd87267d60240c0daea0f35a46f30ee1b2337a","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/color-schema.styl","hash":"32fb938d72b2d86159cb315a98b086bd17fa4415","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/inline.styl","hash":"d547ab0b91f84eb0acd0bc0c5d716ce17c30361a","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/keyframes.styl","hash":"94065ea50f5bef7566d184f2422f6ac20866ba22","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/rewrite.styl","hash":"4c6fffc6d4a3b8830931800ee7da99dccf1be36e","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_category/categories.styl","hash":"1ab7db37c2f7dc7ccdb994dcb41c16a4c8920397","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_index/index.styl","hash":"ad7dcc8a060d94d3c44ca5e0788a24ca38be0f79","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_links/links.styl","hash":"cd4ebb1426abed9fda93b797b02c6d5dd71dc2a1","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/post.styl","hash":"3a6b4f8a29648d9d2c1e99b52a7b42df3f15cf62","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/tag_plugin.styl","hash":"766fcf017deb4c8b0c260ac4c8d2e3489407ad89","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_tag/tags.styl","hash":"65bfc01c76abc927fa1a23bf2422892b0d566c3f","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/banner.styl","hash":"30f8fab95a5214d79df0ccc02b937df8bd885676","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/board.styl","hash":"32d90bcc8bf2fd5d8d78e86a567973d4b69bcfa1","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/copy-btn.styl","hash":"9f932ca3f9625c13aa5353f58319881e62c0c653","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/footer.styl","hash":"35539a1ce8476e75515015a06d01ec66e4af6834","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/footnote.styl","hash":"ae9289cc89649af2042907f8a003303b987f3404","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/header.styl","hash":"d8011325756eb6e4ce619b3e7b4d6d80c2de8a57","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/qrcode.styl","hash":"461d609a802a4f9aa9f492411ed8074813a956b7","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/scroll-btn.styl","hash":"55e10a6965462f8f62f85e75fd5e143af02a4b44","modified":499162500000},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/search.styl","hash":"10f7e91a91e681fb9fe46f9df7707b9ef78707c8","modified":499162500000},{"_id":"public/local-search.xml","hash":"8ae159ba20ee2571a16d69a44ec0fde3b860e75e","modified":1625382943557},{"_id":"public/2020/02/23/hello-world/index.html","hash":"a0fdcf499f2e6965ab208dc350531ad0453cbba2","modified":1625380359629},{"_id":"public/archives/index.html","hash":"457410fa6363904c834510ba2dfe0248f0efa268","modified":1625381746272},{"_id":"public/archives/2020/index.html","hash":"c94e513ab596947c417ba81f62dbf4e547e39f09","modified":1625380359629},{"_id":"public/archives/2020/02/index.html","hash":"c94e513ab596947c417ba81f62dbf4e547e39f09","modified":1625380359629},{"_id":"public/index.html","hash":"665086e7d812a0e41c2675e9423dc6af8b6217d7","modified":1625382943557},{"_id":"public/404.html","hash":"100df8b3920cd77b8ce66edb3001fe0fd6e3b810","modified":1625377742904},{"_id":"public/tags/index.html","hash":"3801120892417ba2571a09980141c00a36a3ea49","modified":1625382943557},{"_id":"public/categories/index.html","hash":"854dd69ae64b6f69f93817712a4cc06efc53151c","modified":1625382713765},{"_id":"public/links/index.html","hash":"5cc8ad6f6e3f0fa48c93c75efe0a85172c4c8ee3","modified":1625377742904},{"_id":"public/CNAME","hash":"ad9a8369ae211e51d4cda3d0b137232aa8efab65","modified":1625377742904},{"_id":"public/img/background.jpg","hash":"d832d49b5037a64b82a291a8a797195ddad7d9fb","modified":1625377742904},{"_id":"public/img/favicon.jpg","hash":"ac1c92e8aaaedafe50d1d8f83732ef655c137373","modified":1625377742904},{"_id":"public/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1625377742904},{"_id":"public/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1625377742904},{"_id":"public/xml/local-search.xml","hash":"8c96ba6a064705602ce28d096fd7dd9069630a55","modified":1625377742904},{"_id":"public/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1625377742904},{"_id":"public/img/default.png","hash":"7bb2b8ee07db305bcadee2985b81b942027ae940","modified":1625377742904},{"_id":"public/img/favicon.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1625377742904},{"_id":"public/css/gitalk.css","hash":"a57b3cc8e04a0a4a27aefa07facf5b5e7bca0e76","modified":1625377742904},{"_id":"public/css/main.css","hash":"425b66e73a47e332501ccaaef784ceb6de12a983","modified":1625377742904},{"_id":"public/js/boot.js","hash":"3de344ee619da989f6dccf7c2ae459fe91075983","modified":1625377742904},{"_id":"public/js/color-schema.js","hash":"cc712fc71bf33d561e1ba74fe1d52d2353092171","modified":1625377742904},{"_id":"public/js/events.js","hash":"4b9d2676c9544db9cc40a8c7d18456792299ba86","modified":1625377742904},{"_id":"public/js/img-lazyload.js","hash":"cbdeca434ec4da51f488c821d51b4d23c73294af","modified":1625377742904},{"_id":"public/js/leancloud.js","hash":"b7985ac3cff9ee2722db43ee6b32b5484c43f5f2","modified":1625377742904},{"_id":"public/js/local-search.js","hash":"bf00f5786bb8de7241f635455b67243d26656222","modified":1625377742904},{"_id":"public/js/plugins.js","hash":"342b1fbc30d1465687ce389a4e07f967266d5d86","modified":1625377742904},{"_id":"public/js/utils.js","hash":"9d492fab9c26311ad0ab553c890e09b9575a76f2","modified":1625377742904},{"_id":"public/lib/hint/hint.min.css","hash":"b38df228460ebfb4c0b6085336ee2878fe85aafe","modified":1625377742904},{"_id":"source/about/index.md","hash":"8704182c503b4d952ae4595abac7e64dd5457cf1","modified":1625378899049},{"_id":"source/img/avatar.jpg","hash":"ac1c92e8aaaedafe50d1d8f83732ef655c137373","modified":1625378644296},{"_id":"public/about/index.html","hash":"9bdd6143d17bab23c779df4bd735e4fe2340ab00","modified":1625379169339},{"_id":"public/img/avatar.jpg","hash":"ac1c92e8aaaedafe50d1d8f83732ef655c137373","modified":1625378692842},{"_id":"source/img/qr_code.png","hash":"a61d895cdca7afbf71af411d07e2cc1455bf26ff","modified":1625378938321},{"_id":"public/img/qr_code.png","hash":"a61d895cdca7afbf71af411d07e2cc1455bf26ff","modified":1625379169339},{"_id":"source/_posts/block_chain/为什么要记账.md","hash":"b4c18eaade1037d047e0ac808ca6aac1ef220dce","modified":1625382595285},{"_id":"source/_posts/block_chain/为什么要遵守协议.md","hash":"3a0d15a95b70c2f1555c60e1e1095fbf2a905426","modified":1625382599038},{"_id":"source/_posts/block_chain/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1625380119743},{"_id":"source/_posts/block_chain/什么事比特币.md","hash":"a94830fcd1b1f430b3a89f2504a99392088ed721","modified":1572657392526},{"_id":"source/_posts/block_chain/区块链记账原理.md","hash":"379dc579ca58492b766b587355a37d295fd82293","modified":1625382581232},{"_id":"source/_posts/block_chain/以太坊是什么.md","hash":"46de69e461d7ad3696477b8b6a0c813f32a385da","modified":1625382608280},{"_id":"source/_posts/block_chain/智能合约雏形.md","hash":"fe4c2d94bb07b7ab1a11162ce624c743b067b1e9","modified":1625382621859},{"_id":"public/2019/11/02/block_chain/智能合约雏形/index.html","hash":"5e8dd112893daba4896859b4d61ec59c893548fc","modified":1625382713765},{"_id":"public/2019/11/02/block_chain/以太坊是什么/index.html","hash":"623ca48284079d690aba3ce6a78a5c190931dfa2","modified":1625382713765},{"_id":"public/2019/11/02/block_chain/为什么要遵守协议/index.html","hash":"3b0c0d476352e2e558fd293c0cb97556490668af","modified":1625382713765},{"_id":"public/2019/11/02/block_chain/为什么要记账/index.html","hash":"4ecd47d829a628e89a9d81e7f9632bbda29d99dd","modified":1625382713765},{"_id":"public/2019/07/04/block_chain/区块链记账原理/index.html","hash":"0b172c5ed13fc8c367bf03e20a67c6232fdfe9df","modified":1625380359629},{"_id":"public/2019/11/02/block_chain/什么事比特币/index.html","hash":"c4cc650b4fe25049dacf863669ee852b4f709c8d","modified":1625380359629},{"_id":"public/archives/2019/index.html","hash":"825353bb619cd4b7923adb2cfbe0bd2273e58265","modified":1625381404301},{"_id":"public/archives/2019/07/index.html","hash":"b8cfa71abddd53363f435ba865c852c8cf86f22c","modified":1625380359629},{"_id":"public/archives/2019/11/index.html","hash":"825353bb619cd4b7923adb2cfbe0bd2273e58265","modified":1625381404301},{"_id":"public/categories/block-chain/index.html","hash":"3ded565aa2e76ea579a8884a92ed29f36fc1432d","modified":1625382713765},{"_id":"source/_posts/block_chain/什么是比特币.md","hash":"b23879a156700c491369859ebbc628e0c48948ef","modified":1625382591461},{"_id":"public/2019/11/02/block_chain/区块链记账原理/index.html","hash":"9b0c01a96d0c8f8c45bc760ffee6758ef0c777d9","modified":1625382713765},{"_id":"public/2019/11/02/block_chain/什么是比特币/index.html","hash":"0acaf8ba7a2e8cb63a59e26fc492e355d095f2d3","modified":1625382713765},{"_id":"source/_posts/react_native/ReactNative启动流程.md","hash":"588545bad23298e96e821df46c7d89abdcb92ab2","modified":1625382928830},{"_id":"source/_posts/.DS_Store","hash":"896682f3b57e263406364b55e0241fb88e1c7a91","modified":1625381195496},{"_id":"source/_posts/react_native/ReactNative通信机制.md","hash":"4200bad580a25af1cf499561a0cffd62eb76620f","modified":1625382643295},{"_id":"public/archives/2021/07/index.html","hash":"6d1dd6763d5c178a7218b037d5cda2d06e89aebc","modified":1625381404301},{"_id":"public/archives/2021/index.html","hash":"6d1dd6763d5c178a7218b037d5cda2d06e89aebc","modified":1625381404301},{"_id":"public/2021/07/04/react_native/ReactNative通信机制/index.html","hash":"64fe6dd263f9223401152d0c83b086c2db1e3a04","modified":1625381404301},{"_id":"public/2021/07/04/react_native/ReactNative启动流程/index.html","hash":"29bad3719578b454fc49471cf7317b6b7625ef71","modified":1625381404301},{"_id":"public/2018/12/09/react_native/ReactNative启动流程/index.html","hash":"57f591deaa102571c110b1423c2ce1ef1e1af5b7","modified":1625382943557},{"_id":"public/2018/12/09/react_native/ReactNative通信机制/index.html","hash":"2d9b7a7ed6fe87ef39330a6f3a581695126aee47","modified":1625382713765},{"_id":"public/archives/2018/12/index.html","hash":"1d88124ea40bcffadd6ed3e7e8407c805dfcb885","modified":1625381746272},{"_id":"public/archives/2018/index.html","hash":"1d88124ea40bcffadd6ed3e7e8407c805dfcb885","modified":1625381746272},{"_id":"public/categories/React-Native/index.html","hash":"3a1c0e49cd7649367bdc931188119465fb7c2db0","modified":1625381746272},{"_id":"public/tags/区块链/index.html","hash":"8d393f97c7162aece486c845df0577278601e99c","modified":1625382943557},{"_id":"public/tags/比特币/index.html","hash":"b8a5745978d28c27871ec72f3aecf8c7d4717ed6","modified":1625382943557},{"_id":"public/tags/以太坊/index.html","hash":"16c771548ca7df59f4c5385fbcffa6380765708a","modified":1625382713765},{"_id":"public/tags/智能合约/index.html","hash":"6d08cc2cc9e4ba64386441b9a19cf89517102472","modified":1625382713765},{"_id":"public/tags/React-Native/index.html","hash":"a8a275a2542c252af4657d40191b0c4272483d0e","modified":1625382943557}],"Category":[{"name":"block_chain","_id":"ckqoti0ay00051xmz7wb0fv08"},{"name":"React Native","_id":"ckqou869n00017zmz560u1kxn"},{"name":"ReactNative","_id":"ckqoud0o00000v5mz5zsm79gi"},{"name":"block chain","_id":"ckqoufqrb0005v5mz4pzt4af3"}],"Data":[],"Page":[{"title":"about","date":"2021-07-04T05:56:03.000Z","layout":"about","_content":"努力做到知行合一\n","source":"about/index.md","raw":"---\ntitle: about\ndate: 2021-07-04 13:56:03\nlayout: about\n---\n努力做到知行合一\n","updated":"2021-07-04T06:08:19.049Z","path":"about/index.html","_id":"ckqosdff50000svmz9mya9fq4","comments":1,"content":"<p>努力做到知行合一</p>\n","site":{"data":{}},"excerpt":"","more":"<p>努力做到知行合一</p>\n"}],"Post":[{"title":"为什么要记账","date":"2019-11-02T01:50:33.000Z","layout":"config.default_layout","_content":"在[区块链记账原理](https://learnblockchain.cn/2017/10/25/whatbc/) 一篇，我们了解到记账是把交易记录、交易时间、账本序号、上一个 Hash 值等信息计算 Hash 打包的过程。\n我们知道所有的计算和存贮是需要消耗计算机资源的，既然要付出成本，那节点为什么还要参与记账呢？在中本聪（比特币之父）的设计里，完成记账的节点可以获得系统给与的一定数量的比特币奖励，这个奖励的过程也就是比特币的发行过程，因此大家形象的把记账称为 “挖矿”，本文将详细讨论这个过程。\n\n\n\n## 记账工作\n\n由于记账是有奖励的，每次记账都可以给自己凭空增加一定数量的个比特币（当前是 12.5 比特币，博文写作时每个比特币是 4 万人民币以上，大家可以算算多少钱），因此就出现大家争相记账，大家一起记账就会引起问题：出现记账不一致的问题，比特币系统引入工作量证明来解决这个问题，规则如下：\n\n- 一段时间内（10 分钟左右，具体时间会与密码学难题难度相互影响）只有一人可以记账成功\n- 通过解决密码学难题（即工作量证明）竞争获得唯一记账权\n- 其他节点复制记账结果\n\n不过在进行工作量证明之前，记账节点会做进行如下准备工作：\n\n- 收集广播中还没有被记录账本的原始交易信息\n- 检查每个交易信息中付款地址有没有足够的余额\n- 验证交易是否有正确的签名\n- 把验证通过的交易信息进行打包记录\n- 添加一个奖励交易：给自己的地址增加 12.5 比特币\n\n如果节点争夺记账权成功的话，就可以得到 12.5 比特币的奖励。\n\n## 工作量证明\n\n区块链记账原理\n\n我们了解到，每次记账的时候会把上一个块的 Hash 值和当前的账页信息一起作为原始信息进行 Hash。 如果仅仅是这样，显然每个人都可以很轻松的完成记账。 为了保证 10 分钟左右只有一个人可以记账，就必须要提高记账的难度，使得 Hash 的结果必须以若干个 0 开头。同时为了满足这个条件，在进行 Hash 时引入一个随机数变量。 用伪代码表示一下：\n\n```\nHash(上一个Hash值，交易记录集) = 456635BCD\nHash(上一个Hash值，交易记录集，随机数) = 0000aFD635BCD\n```\n\n我们知道改变 Hash 的原始信息的任何一部分，Hash 值也会随之不断的变化，因此在运算 Hash 时，不断的改变随机数的值，总可以找到一个随机数使的 Hash 的结果以若干个 0 开头（下文把这个过程称为猜谜），率先找到随机数的节点就获得此次记账的唯一记账权。\n\n### 计算量分析\n\n（这部分可选阅读）我们简单分析下记账难度有多大，\nHash 值是由数字和大小写字母构成的字符串，每一位有 62 种可能性（可能为 26 个大写字母、26 个小写字母，10 个数字中任一个），假设任何一个字符出现的概率是均等的，那么第一位为 0 的概率是 1/62（其他位出现什么字符先不管），理论上需要尝试 62 次 Hash 运算才会出现一次第一位为 0 的情况，如果前两 2 位为 0，就得尝试 62 的平方次 Hash 运算，以 n 个 0 开头就需要尝试 62 的 n 次方次运算。我们结合当前实际区块 #493050 信息来看看：\n\n![区块#493050](https://img.learnblockchain.cn/2017/block_info_493050.jpg!wl)\n\n注：数据来源于 [https://blockchain.info](https://blockchain.info/)\n我们可以看到 Hash 值以 18 个 0 开头，理论上需要尝试 62 的 18 次方次，这个数是非常非常巨大的，我已经算不清楚了，应该是亿亿级别以上了。如此大的计算量需要投入大量的计算设备、电力等，\n目前应该没有单矿工独立参与挖矿了，基本都是由矿工联合起来组成矿池进行挖矿（矿池里的矿工按算力百分比来分收益）。\n\n从经济的角度讲，只有挖矿还有收益（比特币价格不断上涨也让收益变大），就会有新的矿工加入，从而加剧竞争，提高算力难度，挖矿就需要耗费更多的运算和电力，相互作用引起最终成本会接近收益。\n\n题外话：国内由于电力成本较低，相对收益更高，中国的算力占整个网络的一半以上\n\n## 验证\n\n在节点成功找到满足的 Hash 值之后，会马上对全网进行广播打包区块，网络的节点收到广播打包区块，会立刻对其进行验证。\n\n如果验证通过，则表明已经有节点成功挖出区块，自己就不再竞争当前区块打包，而是选择接受这个区块，记录到自己的账本中，然后进行下一个区块的竞争猜谜。\n网络中只有最快解谜的区块，才会添加的账本中，其他的节点进行复制，这样就保证了整个账本的唯一性。\n\n假如节点有任何的作弊行为，都会导致网络的节点验证不通过，直接丢弃其打包的区块，这个区块就无法记录到总账本中，作弊的节点耗费的成本就白费了，因此在巨大的挖矿成本下，也使得矿工自觉自愿的遵守比特币系统的共识协议，也就确保了整个系统的安全。\n\n进阶阅读[比特币区块结构 Merkle 树及简单支付验证分析](https://xiaozhuanlan.com/topic/1402935768)，可以详细了解区块结构如何验证交易。\n\n## 说明\n\n矿工的收益其实不仅仅包含新发行的 12.5 比特币奖励，同时还有交易费收益（本文忽略一些细节是为了让主干更清晰）。","source":"_posts/block_chain/为什么要记账.md","raw":"---\ntitle: 为什么要记账\ndate: 2019-11-02 09:50:33\nlayout: config.default_layout\ncategories: 'block chain'\ntags:\n- 区块链\n- 比特币\n---\n在[区块链记账原理](https://learnblockchain.cn/2017/10/25/whatbc/) 一篇，我们了解到记账是把交易记录、交易时间、账本序号、上一个 Hash 值等信息计算 Hash 打包的过程。\n我们知道所有的计算和存贮是需要消耗计算机资源的，既然要付出成本，那节点为什么还要参与记账呢？在中本聪（比特币之父）的设计里，完成记账的节点可以获得系统给与的一定数量的比特币奖励，这个奖励的过程也就是比特币的发行过程，因此大家形象的把记账称为 “挖矿”，本文将详细讨论这个过程。\n\n\n\n## 记账工作\n\n由于记账是有奖励的，每次记账都可以给自己凭空增加一定数量的个比特币（当前是 12.5 比特币，博文写作时每个比特币是 4 万人民币以上，大家可以算算多少钱），因此就出现大家争相记账，大家一起记账就会引起问题：出现记账不一致的问题，比特币系统引入工作量证明来解决这个问题，规则如下：\n\n- 一段时间内（10 分钟左右，具体时间会与密码学难题难度相互影响）只有一人可以记账成功\n- 通过解决密码学难题（即工作量证明）竞争获得唯一记账权\n- 其他节点复制记账结果\n\n不过在进行工作量证明之前，记账节点会做进行如下准备工作：\n\n- 收集广播中还没有被记录账本的原始交易信息\n- 检查每个交易信息中付款地址有没有足够的余额\n- 验证交易是否有正确的签名\n- 把验证通过的交易信息进行打包记录\n- 添加一个奖励交易：给自己的地址增加 12.5 比特币\n\n如果节点争夺记账权成功的话，就可以得到 12.5 比特币的奖励。\n\n## 工作量证明\n\n区块链记账原理\n\n我们了解到，每次记账的时候会把上一个块的 Hash 值和当前的账页信息一起作为原始信息进行 Hash。 如果仅仅是这样，显然每个人都可以很轻松的完成记账。 为了保证 10 分钟左右只有一个人可以记账，就必须要提高记账的难度，使得 Hash 的结果必须以若干个 0 开头。同时为了满足这个条件，在进行 Hash 时引入一个随机数变量。 用伪代码表示一下：\n\n```\nHash(上一个Hash值，交易记录集) = 456635BCD\nHash(上一个Hash值，交易记录集，随机数) = 0000aFD635BCD\n```\n\n我们知道改变 Hash 的原始信息的任何一部分，Hash 值也会随之不断的变化，因此在运算 Hash 时，不断的改变随机数的值，总可以找到一个随机数使的 Hash 的结果以若干个 0 开头（下文把这个过程称为猜谜），率先找到随机数的节点就获得此次记账的唯一记账权。\n\n### 计算量分析\n\n（这部分可选阅读）我们简单分析下记账难度有多大，\nHash 值是由数字和大小写字母构成的字符串，每一位有 62 种可能性（可能为 26 个大写字母、26 个小写字母，10 个数字中任一个），假设任何一个字符出现的概率是均等的，那么第一位为 0 的概率是 1/62（其他位出现什么字符先不管），理论上需要尝试 62 次 Hash 运算才会出现一次第一位为 0 的情况，如果前两 2 位为 0，就得尝试 62 的平方次 Hash 运算，以 n 个 0 开头就需要尝试 62 的 n 次方次运算。我们结合当前实际区块 #493050 信息来看看：\n\n![区块#493050](https://img.learnblockchain.cn/2017/block_info_493050.jpg!wl)\n\n注：数据来源于 [https://blockchain.info](https://blockchain.info/)\n我们可以看到 Hash 值以 18 个 0 开头，理论上需要尝试 62 的 18 次方次，这个数是非常非常巨大的，我已经算不清楚了，应该是亿亿级别以上了。如此大的计算量需要投入大量的计算设备、电力等，\n目前应该没有单矿工独立参与挖矿了，基本都是由矿工联合起来组成矿池进行挖矿（矿池里的矿工按算力百分比来分收益）。\n\n从经济的角度讲，只有挖矿还有收益（比特币价格不断上涨也让收益变大），就会有新的矿工加入，从而加剧竞争，提高算力难度，挖矿就需要耗费更多的运算和电力，相互作用引起最终成本会接近收益。\n\n题外话：国内由于电力成本较低，相对收益更高，中国的算力占整个网络的一半以上\n\n## 验证\n\n在节点成功找到满足的 Hash 值之后，会马上对全网进行广播打包区块，网络的节点收到广播打包区块，会立刻对其进行验证。\n\n如果验证通过，则表明已经有节点成功挖出区块，自己就不再竞争当前区块打包，而是选择接受这个区块，记录到自己的账本中，然后进行下一个区块的竞争猜谜。\n网络中只有最快解谜的区块，才会添加的账本中，其他的节点进行复制，这样就保证了整个账本的唯一性。\n\n假如节点有任何的作弊行为，都会导致网络的节点验证不通过，直接丢弃其打包的区块，这个区块就无法记录到总账本中，作弊的节点耗费的成本就白费了，因此在巨大的挖矿成本下，也使得矿工自觉自愿的遵守比特币系统的共识协议，也就确保了整个系统的安全。\n\n进阶阅读[比特币区块结构 Merkle 树及简单支付验证分析](https://xiaozhuanlan.com/topic/1402935768)，可以详细了解区块结构如何验证交易。\n\n## 说明\n\n矿工的收益其实不仅仅包含新发行的 12.5 比特币奖励，同时还有交易费收益（本文忽略一些细节是为了让主干更清晰）。","slug":"block_chain/为什么要记账","published":1,"updated":"2021-07-04T07:09:55.285Z","_id":"ckqoti0aq00001xmz7ir634we","comments":1,"photos":[],"link":"","content":"<p>在<a href=\"https://learnblockchain.cn/2017/10/25/whatbc/\">区块链记账原理</a> 一篇，我们了解到记账是把交易记录、交易时间、账本序号、上一个 Hash 值等信息计算 Hash 打包的过程。<br>我们知道所有的计算和存贮是需要消耗计算机资源的，既然要付出成本，那节点为什么还要参与记账呢？在中本聪（比特币之父）的设计里，完成记账的节点可以获得系统给与的一定数量的比特币奖励，这个奖励的过程也就是比特币的发行过程，因此大家形象的把记账称为 “挖矿”，本文将详细讨论这个过程。</p>\n<h2 id=\"记账工作\"><a href=\"#记账工作\" class=\"headerlink\" title=\"记账工作\"></a>记账工作</h2><p>由于记账是有奖励的，每次记账都可以给自己凭空增加一定数量的个比特币（当前是 12.5 比特币，博文写作时每个比特币是 4 万人民币以上，大家可以算算多少钱），因此就出现大家争相记账，大家一起记账就会引起问题：出现记账不一致的问题，比特币系统引入工作量证明来解决这个问题，规则如下：</p>\n<ul>\n<li>一段时间内（10 分钟左右，具体时间会与密码学难题难度相互影响）只有一人可以记账成功</li>\n<li>通过解决密码学难题（即工作量证明）竞争获得唯一记账权</li>\n<li>其他节点复制记账结果</li>\n</ul>\n<p>不过在进行工作量证明之前，记账节点会做进行如下准备工作：</p>\n<ul>\n<li>收集广播中还没有被记录账本的原始交易信息</li>\n<li>检查每个交易信息中付款地址有没有足够的余额</li>\n<li>验证交易是否有正确的签名</li>\n<li>把验证通过的交易信息进行打包记录</li>\n<li>添加一个奖励交易：给自己的地址增加 12.5 比特币</li>\n</ul>\n<p>如果节点争夺记账权成功的话，就可以得到 12.5 比特币的奖励。</p>\n<h2 id=\"工作量证明\"><a href=\"#工作量证明\" class=\"headerlink\" title=\"工作量证明\"></a>工作量证明</h2><p>区块链记账原理</p>\n<p>我们了解到，每次记账的时候会把上一个块的 Hash 值和当前的账页信息一起作为原始信息进行 Hash。 如果仅仅是这样，显然每个人都可以很轻松的完成记账。 为了保证 10 分钟左右只有一个人可以记账，就必须要提高记账的难度，使得 Hash 的结果必须以若干个 0 开头。同时为了满足这个条件，在进行 Hash 时引入一个随机数变量。 用伪代码表示一下：</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs stylus\"><span class=\"hljs-function\"><span class=\"hljs-title\">Hash</span><span class=\"hljs-params\">(上一个Hash值，交易记录集)</span></span> = <span class=\"hljs-number\">456635</span>BCD<br><span class=\"hljs-function\"><span class=\"hljs-title\">Hash</span><span class=\"hljs-params\">(上一个Hash值，交易记录集，随机数)</span></span> = <span class=\"hljs-number\">0000</span>aFD635BCD<br></code></pre></div></td></tr></table></figure>\n\n<p>我们知道改变 Hash 的原始信息的任何一部分，Hash 值也会随之不断的变化，因此在运算 Hash 时，不断的改变随机数的值，总可以找到一个随机数使的 Hash 的结果以若干个 0 开头（下文把这个过程称为猜谜），率先找到随机数的节点就获得此次记账的唯一记账权。</p>\n<h3 id=\"计算量分析\"><a href=\"#计算量分析\" class=\"headerlink\" title=\"计算量分析\"></a>计算量分析</h3><p>（这部分可选阅读）我们简单分析下记账难度有多大，<br>Hash 值是由数字和大小写字母构成的字符串，每一位有 62 种可能性（可能为 26 个大写字母、26 个小写字母，10 个数字中任一个），假设任何一个字符出现的概率是均等的，那么第一位为 0 的概率是 1/62（其他位出现什么字符先不管），理论上需要尝试 62 次 Hash 运算才会出现一次第一位为 0 的情况，如果前两 2 位为 0，就得尝试 62 的平方次 Hash 运算，以 n 个 0 开头就需要尝试 62 的 n 次方次运算。我们结合当前实际区块 #493050 信息来看看：</p>\n<p><img src=\"https://img.learnblockchain.cn/2017/block_info_493050.jpg!wl\" alt=\"区块#493050\"></p>\n<p>注：数据来源于 <a href=\"https://blockchain.info/\">https://blockchain.info</a><br>我们可以看到 Hash 值以 18 个 0 开头，理论上需要尝试 62 的 18 次方次，这个数是非常非常巨大的，我已经算不清楚了，应该是亿亿级别以上了。如此大的计算量需要投入大量的计算设备、电力等，<br>目前应该没有单矿工独立参与挖矿了，基本都是由矿工联合起来组成矿池进行挖矿（矿池里的矿工按算力百分比来分收益）。</p>\n<p>从经济的角度讲，只有挖矿还有收益（比特币价格不断上涨也让收益变大），就会有新的矿工加入，从而加剧竞争，提高算力难度，挖矿就需要耗费更多的运算和电力，相互作用引起最终成本会接近收益。</p>\n<p>题外话：国内由于电力成本较低，相对收益更高，中国的算力占整个网络的一半以上</p>\n<h2 id=\"验证\"><a href=\"#验证\" class=\"headerlink\" title=\"验证\"></a>验证</h2><p>在节点成功找到满足的 Hash 值之后，会马上对全网进行广播打包区块，网络的节点收到广播打包区块，会立刻对其进行验证。</p>\n<p>如果验证通过，则表明已经有节点成功挖出区块，自己就不再竞争当前区块打包，而是选择接受这个区块，记录到自己的账本中，然后进行下一个区块的竞争猜谜。<br>网络中只有最快解谜的区块，才会添加的账本中，其他的节点进行复制，这样就保证了整个账本的唯一性。</p>\n<p>假如节点有任何的作弊行为，都会导致网络的节点验证不通过，直接丢弃其打包的区块，这个区块就无法记录到总账本中，作弊的节点耗费的成本就白费了，因此在巨大的挖矿成本下，也使得矿工自觉自愿的遵守比特币系统的共识协议，也就确保了整个系统的安全。</p>\n<p>进阶阅读<a href=\"https://xiaozhuanlan.com/topic/1402935768\">比特币区块结构 Merkle 树及简单支付验证分析</a>，可以详细了解区块结构如何验证交易。</p>\n<h2 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h2><p>矿工的收益其实不仅仅包含新发行的 12.5 比特币奖励，同时还有交易费收益（本文忽略一些细节是为了让主干更清晰）。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在<a href=\"https://learnblockchain.cn/2017/10/25/whatbc/\">区块链记账原理</a> 一篇，我们了解到记账是把交易记录、交易时间、账本序号、上一个 Hash 值等信息计算 Hash 打包的过程。<br>我们知道所有的计算和存贮是需要消耗计算机资源的，既然要付出成本，那节点为什么还要参与记账呢？在中本聪（比特币之父）的设计里，完成记账的节点可以获得系统给与的一定数量的比特币奖励，这个奖励的过程也就是比特币的发行过程，因此大家形象的把记账称为 “挖矿”，本文将详细讨论这个过程。</p>\n<h2 id=\"记账工作\"><a href=\"#记账工作\" class=\"headerlink\" title=\"记账工作\"></a>记账工作</h2><p>由于记账是有奖励的，每次记账都可以给自己凭空增加一定数量的个比特币（当前是 12.5 比特币，博文写作时每个比特币是 4 万人民币以上，大家可以算算多少钱），因此就出现大家争相记账，大家一起记账就会引起问题：出现记账不一致的问题，比特币系统引入工作量证明来解决这个问题，规则如下：</p>\n<ul>\n<li>一段时间内（10 分钟左右，具体时间会与密码学难题难度相互影响）只有一人可以记账成功</li>\n<li>通过解决密码学难题（即工作量证明）竞争获得唯一记账权</li>\n<li>其他节点复制记账结果</li>\n</ul>\n<p>不过在进行工作量证明之前，记账节点会做进行如下准备工作：</p>\n<ul>\n<li>收集广播中还没有被记录账本的原始交易信息</li>\n<li>检查每个交易信息中付款地址有没有足够的余额</li>\n<li>验证交易是否有正确的签名</li>\n<li>把验证通过的交易信息进行打包记录</li>\n<li>添加一个奖励交易：给自己的地址增加 12.5 比特币</li>\n</ul>\n<p>如果节点争夺记账权成功的话，就可以得到 12.5 比特币的奖励。</p>\n<h2 id=\"工作量证明\"><a href=\"#工作量证明\" class=\"headerlink\" title=\"工作量证明\"></a>工作量证明</h2><p>区块链记账原理</p>\n<p>我们了解到，每次记账的时候会把上一个块的 Hash 值和当前的账页信息一起作为原始信息进行 Hash。 如果仅仅是这样，显然每个人都可以很轻松的完成记账。 为了保证 10 分钟左右只有一个人可以记账，就必须要提高记账的难度，使得 Hash 的结果必须以若干个 0 开头。同时为了满足这个条件，在进行 Hash 时引入一个随机数变量。 用伪代码表示一下：</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\"><span class=\"hljs-function\"><span class=\"hljs-title\">Hash</span><span class=\"hljs-params\">(上一个Hash值，交易记录集)</span></span> = <span class=\"hljs-number\">456635</span>BCD<br><span class=\"hljs-function\"><span class=\"hljs-title\">Hash</span><span class=\"hljs-params\">(上一个Hash值，交易记录集，随机数)</span></span> = <span class=\"hljs-number\">0000</span>aFD635BCD<br></code></pre></td></tr></table></figure>\n\n<p>我们知道改变 Hash 的原始信息的任何一部分，Hash 值也会随之不断的变化，因此在运算 Hash 时，不断的改变随机数的值，总可以找到一个随机数使的 Hash 的结果以若干个 0 开头（下文把这个过程称为猜谜），率先找到随机数的节点就获得此次记账的唯一记账权。</p>\n<h3 id=\"计算量分析\"><a href=\"#计算量分析\" class=\"headerlink\" title=\"计算量分析\"></a>计算量分析</h3><p>（这部分可选阅读）我们简单分析下记账难度有多大，<br>Hash 值是由数字和大小写字母构成的字符串，每一位有 62 种可能性（可能为 26 个大写字母、26 个小写字母，10 个数字中任一个），假设任何一个字符出现的概率是均等的，那么第一位为 0 的概率是 1/62（其他位出现什么字符先不管），理论上需要尝试 62 次 Hash 运算才会出现一次第一位为 0 的情况，如果前两 2 位为 0，就得尝试 62 的平方次 Hash 运算，以 n 个 0 开头就需要尝试 62 的 n 次方次运算。我们结合当前实际区块 #493050 信息来看看：</p>\n<p><img src=\"https://img.learnblockchain.cn/2017/block_info_493050.jpg!wl\" alt=\"区块#493050\"></p>\n<p>注：数据来源于 <a href=\"https://blockchain.info/\">https://blockchain.info</a><br>我们可以看到 Hash 值以 18 个 0 开头，理论上需要尝试 62 的 18 次方次，这个数是非常非常巨大的，我已经算不清楚了，应该是亿亿级别以上了。如此大的计算量需要投入大量的计算设备、电力等，<br>目前应该没有单矿工独立参与挖矿了，基本都是由矿工联合起来组成矿池进行挖矿（矿池里的矿工按算力百分比来分收益）。</p>\n<p>从经济的角度讲，只有挖矿还有收益（比特币价格不断上涨也让收益变大），就会有新的矿工加入，从而加剧竞争，提高算力难度，挖矿就需要耗费更多的运算和电力，相互作用引起最终成本会接近收益。</p>\n<p>题外话：国内由于电力成本较低，相对收益更高，中国的算力占整个网络的一半以上</p>\n<h2 id=\"验证\"><a href=\"#验证\" class=\"headerlink\" title=\"验证\"></a>验证</h2><p>在节点成功找到满足的 Hash 值之后，会马上对全网进行广播打包区块，网络的节点收到广播打包区块，会立刻对其进行验证。</p>\n<p>如果验证通过，则表明已经有节点成功挖出区块，自己就不再竞争当前区块打包，而是选择接受这个区块，记录到自己的账本中，然后进行下一个区块的竞争猜谜。<br>网络中只有最快解谜的区块，才会添加的账本中，其他的节点进行复制，这样就保证了整个账本的唯一性。</p>\n<p>假如节点有任何的作弊行为，都会导致网络的节点验证不通过，直接丢弃其打包的区块，这个区块就无法记录到总账本中，作弊的节点耗费的成本就白费了，因此在巨大的挖矿成本下，也使得矿工自觉自愿的遵守比特币系统的共识协议，也就确保了整个系统的安全。</p>\n<p>进阶阅读<a href=\"https://xiaozhuanlan.com/topic/1402935768\">比特币区块结构 Merkle 树及简单支付验证分析</a>，可以详细了解区块结构如何验证交易。</p>\n<h2 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h2><p>矿工的收益其实不仅仅包含新发行的 12.5 比特币奖励，同时还有交易费收益（本文忽略一些细节是为了让主干更清晰）。</p>\n"},{"title":"为什么要遵守协议","date":"2019-11-02T02:12:33.000Z","layout":"config.default_layout","_content":"比特币没有中心机构，几乎所有的完整节点都有一份公共总帐本，那么大家如何达成共识：确认哪一份才是公认权威的总账本呢？\n\n\n\n## 为什么要遵守协议\n\n这其实是一个经济问题，在经济活动中的每个人都是自私自利的，追求的是利益的最大化，一个节点工作量只有在其他的节点认同其是有效的（打包的新区块，其他的节点只有验证通过才会加入到区块链中，并在网络上传播），才能够过得收益，\n而只有遵守规则才会得到其他的节点认同。\n因此，基于逐利，节点就会自发的遵守协议。共识就是数以万计的独立节点遵守了简单的规则（通过异步交互）自发形成的。\n\n> 共识：共同遵守的协议规范\n\n## 去中心化共识\n\n在[工作量证明](https://learnblockchain.cn/2017/11/04/bitcoin-pow/)一篇，我们了解通过工作量证明来竞争记账，权威的总帐本是怎么达到共识的，没有完全说清楚，今天补上，\n实际上，比特币的共识由所有节点的 4 个**独立过程**相互作用而产生：\n\n1. 每个节点（挖矿节点）依据标准对每个交易进行独立验证\n2. 挖矿节点通过完成工作量证明，将交易记录独立打包进新区块\n3. 每个节点独立的对新区块进行校验并组装进区块链\n4. 每个节点对区块链进行独立选择，在工作量证明机制下选择累计工作量最大的区块链\n\n共识最终目的是保证比特币不停的在工作量最大的区块链上运转，工作量最大的区块链就是权威的公共总帐本。\n\n第 1 2 3 步在[比特币如何挖矿 - 工作量证明](https://learnblockchain.cn/2017/11/04/bitcoin-pow/)一篇有提到过，下面着重讲第 4 步。\n\n## 最长链的选择\n\n先来一个定义，把累计了最多难度的区块链。在一般情况下，也是包含最多区块的那个链称为**主链**\n每一个（挖矿）节点总是选择并尝试延长主链。\n\n### 分叉\n\n当有两名矿工在几乎在相同的时间内，各自都算得了工作量证明解，便立即传播自己的 “获胜” 区块到网络中，先是传播给邻近的节点而后传播到整个网络。每个收到有效区块的节点都会将其并入并延长区块链。\n当这个两个区块传播时，一些节点首先收到 #3458A, 一些节点首先收到 #3458B，这两个候选区块（通常这两个候选区块会包含几乎相同的交易）都是主链的延伸，分叉就会产生，这时分叉出有竞争关系的两条链，如图：\n![img](https://img.learnblockchain.cn/2017/block_branch.jpg!wl)\n两个块都收到的节点，会把其中有更多工作量的一条会继续作为主链，另一条作为**备用链**保存（保存是因为备用链将来可能会超过主链难度称为新主链）。\n\n### 分叉解决\n\n收到 #3458A 的（挖矿）节点，会立刻以这个区块为父区块来产生新的候选区块，并尝试寻找这个候选区块的工作量证明解。同样地，接受 #3458B 区块的节点会以这个区块为链的顶点开始生成新块，延长这个链（下面称为 B 链）。\n这时总会有一方抢先发现工作量证明解并将其传播出去，假设以 #3458B 为父区块的工作量证明首先解出，如图：\n![img](https://img.learnblockchain.cn/2017/block_branch2.jpg!wl)\n\n当原本以 #3458A 为父区块求解的节点在收到 #3458B, #3459B 之后，会立刻将 B 链作为主链（因为 #3458A 为顶点的链已经不是最长链了）继续挖矿。\n\n> 节点也有可能先收到 #3459B，再收到 #3458B，收到 #3459B 时，会被认为是 “孤块 “（因为还找不到 #3459B 的父块 #3458B）保存在孤块池中，一旦收到父块 #3458B 时，节点就会将孤块从孤块池中取出，并且连接到它的父区块，让它作为区块链的一部分。\n\n比特币将区块间隔设计为 10 分钟，是在更快速的交易确认和更低的分叉概率间作出的妥协。更短的区块产生间隔会让交易确认更快地完成，也会导致更加频繁地区块链分叉。与之相对地，长的间隔会减少分叉数量，却会导致更长的确认时间。","source":"_posts/block_chain/为什么要遵守协议.md","raw":"---\ntitle: 为什么要遵守协议\ndate: 2019-11-02 10:12:33\nlayout: config.default_layout\ncategories: 'block chain'\ntags:\n- 区块链\n- 比特币\n---\n比特币没有中心机构，几乎所有的完整节点都有一份公共总帐本，那么大家如何达成共识：确认哪一份才是公认权威的总账本呢？\n\n\n\n## 为什么要遵守协议\n\n这其实是一个经济问题，在经济活动中的每个人都是自私自利的，追求的是利益的最大化，一个节点工作量只有在其他的节点认同其是有效的（打包的新区块，其他的节点只有验证通过才会加入到区块链中，并在网络上传播），才能够过得收益，\n而只有遵守规则才会得到其他的节点认同。\n因此，基于逐利，节点就会自发的遵守协议。共识就是数以万计的独立节点遵守了简单的规则（通过异步交互）自发形成的。\n\n> 共识：共同遵守的协议规范\n\n## 去中心化共识\n\n在[工作量证明](https://learnblockchain.cn/2017/11/04/bitcoin-pow/)一篇，我们了解通过工作量证明来竞争记账，权威的总帐本是怎么达到共识的，没有完全说清楚，今天补上，\n实际上，比特币的共识由所有节点的 4 个**独立过程**相互作用而产生：\n\n1. 每个节点（挖矿节点）依据标准对每个交易进行独立验证\n2. 挖矿节点通过完成工作量证明，将交易记录独立打包进新区块\n3. 每个节点独立的对新区块进行校验并组装进区块链\n4. 每个节点对区块链进行独立选择，在工作量证明机制下选择累计工作量最大的区块链\n\n共识最终目的是保证比特币不停的在工作量最大的区块链上运转，工作量最大的区块链就是权威的公共总帐本。\n\n第 1 2 3 步在[比特币如何挖矿 - 工作量证明](https://learnblockchain.cn/2017/11/04/bitcoin-pow/)一篇有提到过，下面着重讲第 4 步。\n\n## 最长链的选择\n\n先来一个定义，把累计了最多难度的区块链。在一般情况下，也是包含最多区块的那个链称为**主链**\n每一个（挖矿）节点总是选择并尝试延长主链。\n\n### 分叉\n\n当有两名矿工在几乎在相同的时间内，各自都算得了工作量证明解，便立即传播自己的 “获胜” 区块到网络中，先是传播给邻近的节点而后传播到整个网络。每个收到有效区块的节点都会将其并入并延长区块链。\n当这个两个区块传播时，一些节点首先收到 #3458A, 一些节点首先收到 #3458B，这两个候选区块（通常这两个候选区块会包含几乎相同的交易）都是主链的延伸，分叉就会产生，这时分叉出有竞争关系的两条链，如图：\n![img](https://img.learnblockchain.cn/2017/block_branch.jpg!wl)\n两个块都收到的节点，会把其中有更多工作量的一条会继续作为主链，另一条作为**备用链**保存（保存是因为备用链将来可能会超过主链难度称为新主链）。\n\n### 分叉解决\n\n收到 #3458A 的（挖矿）节点，会立刻以这个区块为父区块来产生新的候选区块，并尝试寻找这个候选区块的工作量证明解。同样地，接受 #3458B 区块的节点会以这个区块为链的顶点开始生成新块，延长这个链（下面称为 B 链）。\n这时总会有一方抢先发现工作量证明解并将其传播出去，假设以 #3458B 为父区块的工作量证明首先解出，如图：\n![img](https://img.learnblockchain.cn/2017/block_branch2.jpg!wl)\n\n当原本以 #3458A 为父区块求解的节点在收到 #3458B, #3459B 之后，会立刻将 B 链作为主链（因为 #3458A 为顶点的链已经不是最长链了）继续挖矿。\n\n> 节点也有可能先收到 #3459B，再收到 #3458B，收到 #3459B 时，会被认为是 “孤块 “（因为还找不到 #3459B 的父块 #3458B）保存在孤块池中，一旦收到父块 #3458B 时，节点就会将孤块从孤块池中取出，并且连接到它的父区块，让它作为区块链的一部分。\n\n比特币将区块间隔设计为 10 分钟，是在更快速的交易确认和更低的分叉概率间作出的妥协。更短的区块产生间隔会让交易确认更快地完成，也会导致更加频繁地区块链分叉。与之相对地，长的间隔会减少分叉数量，却会导致更长的确认时间。","slug":"block_chain/为什么要遵守协议","published":1,"updated":"2021-07-04T07:09:59.038Z","_id":"ckqoti0au00011xmzevlndn7o","comments":1,"photos":[],"link":"","content":"<p>比特币没有中心机构，几乎所有的完整节点都有一份公共总帐本，那么大家如何达成共识：确认哪一份才是公认权威的总账本呢？</p>\n<h2 id=\"为什么要遵守协议\"><a href=\"#为什么要遵守协议\" class=\"headerlink\" title=\"为什么要遵守协议\"></a>为什么要遵守协议</h2><p>这其实是一个经济问题，在经济活动中的每个人都是自私自利的，追求的是利益的最大化，一个节点工作量只有在其他的节点认同其是有效的（打包的新区块，其他的节点只有验证通过才会加入到区块链中，并在网络上传播），才能够过得收益，<br>而只有遵守规则才会得到其他的节点认同。<br>因此，基于逐利，节点就会自发的遵守协议。共识就是数以万计的独立节点遵守了简单的规则（通过异步交互）自发形成的。</p>\n<blockquote>\n<p>共识：共同遵守的协议规范</p>\n</blockquote>\n<h2 id=\"去中心化共识\"><a href=\"#去中心化共识\" class=\"headerlink\" title=\"去中心化共识\"></a>去中心化共识</h2><p>在<a href=\"https://learnblockchain.cn/2017/11/04/bitcoin-pow/\">工作量证明</a>一篇，我们了解通过工作量证明来竞争记账，权威的总帐本是怎么达到共识的，没有完全说清楚，今天补上，<br>实际上，比特币的共识由所有节点的 4 个<strong>独立过程</strong>相互作用而产生：</p>\n<ol>\n<li>每个节点（挖矿节点）依据标准对每个交易进行独立验证</li>\n<li>挖矿节点通过完成工作量证明，将交易记录独立打包进新区块</li>\n<li>每个节点独立的对新区块进行校验并组装进区块链</li>\n<li>每个节点对区块链进行独立选择，在工作量证明机制下选择累计工作量最大的区块链</li>\n</ol>\n<p>共识最终目的是保证比特币不停的在工作量最大的区块链上运转，工作量最大的区块链就是权威的公共总帐本。</p>\n<p>第 1 2 3 步在<a href=\"https://learnblockchain.cn/2017/11/04/bitcoin-pow/\">比特币如何挖矿 - 工作量证明</a>一篇有提到过，下面着重讲第 4 步。</p>\n<h2 id=\"最长链的选择\"><a href=\"#最长链的选择\" class=\"headerlink\" title=\"最长链的选择\"></a>最长链的选择</h2><p>先来一个定义，把累计了最多难度的区块链。在一般情况下，也是包含最多区块的那个链称为<strong>主链</strong><br>每一个（挖矿）节点总是选择并尝试延长主链。</p>\n<h3 id=\"分叉\"><a href=\"#分叉\" class=\"headerlink\" title=\"分叉\"></a>分叉</h3><p>当有两名矿工在几乎在相同的时间内，各自都算得了工作量证明解，便立即传播自己的 “获胜” 区块到网络中，先是传播给邻近的节点而后传播到整个网络。每个收到有效区块的节点都会将其并入并延长区块链。<br>当这个两个区块传播时，一些节点首先收到 #3458A, 一些节点首先收到 #3458B，这两个候选区块（通常这两个候选区块会包含几乎相同的交易）都是主链的延伸，分叉就会产生，这时分叉出有竞争关系的两条链，如图：<br><img src=\"https://img.learnblockchain.cn/2017/block_branch.jpg!wl\" alt=\"img\"><br>两个块都收到的节点，会把其中有更多工作量的一条会继续作为主链，另一条作为<strong>备用链</strong>保存（保存是因为备用链将来可能会超过主链难度称为新主链）。</p>\n<h3 id=\"分叉解决\"><a href=\"#分叉解决\" class=\"headerlink\" title=\"分叉解决\"></a>分叉解决</h3><p>收到 #3458A 的（挖矿）节点，会立刻以这个区块为父区块来产生新的候选区块，并尝试寻找这个候选区块的工作量证明解。同样地，接受 #3458B 区块的节点会以这个区块为链的顶点开始生成新块，延长这个链（下面称为 B 链）。<br>这时总会有一方抢先发现工作量证明解并将其传播出去，假设以 #3458B 为父区块的工作量证明首先解出，如图：<br><img src=\"https://img.learnblockchain.cn/2017/block_branch2.jpg!wl\" alt=\"img\"></p>\n<p>当原本以 #3458A 为父区块求解的节点在收到 #3458B, #3459B 之后，会立刻将 B 链作为主链（因为 #3458A 为顶点的链已经不是最长链了）继续挖矿。</p>\n<blockquote>\n<p>节点也有可能先收到 #3459B，再收到 #3458B，收到 #3459B 时，会被认为是 “孤块 “（因为还找不到 #3459B 的父块 #3458B）保存在孤块池中，一旦收到父块 #3458B 时，节点就会将孤块从孤块池中取出，并且连接到它的父区块，让它作为区块链的一部分。</p>\n</blockquote>\n<p>比特币将区块间隔设计为 10 分钟，是在更快速的交易确认和更低的分叉概率间作出的妥协。更短的区块产生间隔会让交易确认更快地完成，也会导致更加频繁地区块链分叉。与之相对地，长的间隔会减少分叉数量，却会导致更长的确认时间。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>比特币没有中心机构，几乎所有的完整节点都有一份公共总帐本，那么大家如何达成共识：确认哪一份才是公认权威的总账本呢？</p>\n<h2 id=\"为什么要遵守协议\"><a href=\"#为什么要遵守协议\" class=\"headerlink\" title=\"为什么要遵守协议\"></a>为什么要遵守协议</h2><p>这其实是一个经济问题，在经济活动中的每个人都是自私自利的，追求的是利益的最大化，一个节点工作量只有在其他的节点认同其是有效的（打包的新区块，其他的节点只有验证通过才会加入到区块链中，并在网络上传播），才能够过得收益，<br>而只有遵守规则才会得到其他的节点认同。<br>因此，基于逐利，节点就会自发的遵守协议。共识就是数以万计的独立节点遵守了简单的规则（通过异步交互）自发形成的。</p>\n<blockquote>\n<p>共识：共同遵守的协议规范</p>\n</blockquote>\n<h2 id=\"去中心化共识\"><a href=\"#去中心化共识\" class=\"headerlink\" title=\"去中心化共识\"></a>去中心化共识</h2><p>在<a href=\"https://learnblockchain.cn/2017/11/04/bitcoin-pow/\">工作量证明</a>一篇，我们了解通过工作量证明来竞争记账，权威的总帐本是怎么达到共识的，没有完全说清楚，今天补上，<br>实际上，比特币的共识由所有节点的 4 个<strong>独立过程</strong>相互作用而产生：</p>\n<ol>\n<li>每个节点（挖矿节点）依据标准对每个交易进行独立验证</li>\n<li>挖矿节点通过完成工作量证明，将交易记录独立打包进新区块</li>\n<li>每个节点独立的对新区块进行校验并组装进区块链</li>\n<li>每个节点对区块链进行独立选择，在工作量证明机制下选择累计工作量最大的区块链</li>\n</ol>\n<p>共识最终目的是保证比特币不停的在工作量最大的区块链上运转，工作量最大的区块链就是权威的公共总帐本。</p>\n<p>第 1 2 3 步在<a href=\"https://learnblockchain.cn/2017/11/04/bitcoin-pow/\">比特币如何挖矿 - 工作量证明</a>一篇有提到过，下面着重讲第 4 步。</p>\n<h2 id=\"最长链的选择\"><a href=\"#最长链的选择\" class=\"headerlink\" title=\"最长链的选择\"></a>最长链的选择</h2><p>先来一个定义，把累计了最多难度的区块链。在一般情况下，也是包含最多区块的那个链称为<strong>主链</strong><br>每一个（挖矿）节点总是选择并尝试延长主链。</p>\n<h3 id=\"分叉\"><a href=\"#分叉\" class=\"headerlink\" title=\"分叉\"></a>分叉</h3><p>当有两名矿工在几乎在相同的时间内，各自都算得了工作量证明解，便立即传播自己的 “获胜” 区块到网络中，先是传播给邻近的节点而后传播到整个网络。每个收到有效区块的节点都会将其并入并延长区块链。<br>当这个两个区块传播时，一些节点首先收到 #3458A, 一些节点首先收到 #3458B，这两个候选区块（通常这两个候选区块会包含几乎相同的交易）都是主链的延伸，分叉就会产生，这时分叉出有竞争关系的两条链，如图：<br><img src=\"https://img.learnblockchain.cn/2017/block_branch.jpg!wl\" alt=\"img\"><br>两个块都收到的节点，会把其中有更多工作量的一条会继续作为主链，另一条作为<strong>备用链</strong>保存（保存是因为备用链将来可能会超过主链难度称为新主链）。</p>\n<h3 id=\"分叉解决\"><a href=\"#分叉解决\" class=\"headerlink\" title=\"分叉解决\"></a>分叉解决</h3><p>收到 #3458A 的（挖矿）节点，会立刻以这个区块为父区块来产生新的候选区块，并尝试寻找这个候选区块的工作量证明解。同样地，接受 #3458B 区块的节点会以这个区块为链的顶点开始生成新块，延长这个链（下面称为 B 链）。<br>这时总会有一方抢先发现工作量证明解并将其传播出去，假设以 #3458B 为父区块的工作量证明首先解出，如图：<br><img src=\"https://img.learnblockchain.cn/2017/block_branch2.jpg!wl\" alt=\"img\"></p>\n<p>当原本以 #3458A 为父区块求解的节点在收到 #3458B, #3459B 之后，会立刻将 B 链作为主链（因为 #3458A 为顶点的链已经不是最长链了）继续挖矿。</p>\n<blockquote>\n<p>节点也有可能先收到 #3459B，再收到 #3458B，收到 #3459B 时，会被认为是 “孤块 “（因为还找不到 #3459B 的父块 #3458B）保存在孤块池中，一旦收到父块 #3458B 时，节点就会将孤块从孤块池中取出，并且连接到它的父区块，让它作为区块链的一部分。</p>\n</blockquote>\n<p>比特币将区块间隔设计为 10 分钟，是在更快速的交易确认和更低的分叉概率间作出的妥协。更短的区块产生间隔会让交易确认更快地完成，也会导致更加频繁地区块链分叉。与之相对地，长的间隔会减少分叉数量，却会导致更长的确认时间。</p>\n"},{"title":"区块链记账原理","date":"2019-11-02T01:30:33.000Z","layout":"config.default_layout","_content":"\n区块链 (1.0) 是一个基于密码学安全的分布式账本，是一个方便验证，不可篡改的账本。\n通常认为与智能合约相结合的区块链为区块链 2.0, 如以太坊是典型的区块链 2.0\n很多人只了解过比特币，不知道区块链，比特币实际是一个使用了区块链技术的应用，只是比特币当前太热，把区块链技术的光芒给掩盖了。区块链才是未来，期望各位开发人员少关心币价，多关心技术。\n本文将讲解区块链 1.0 技术是如何实现的。\n\n\n\n## 哈希函数\n\n在讲区块链记账之前，先说明一下哈希函数。\n哈希函数：Hash (原始信息) = 摘要信息\n原始信息可以是任意的信息，hash 之后会得到一个简短的摘要信息\n\n哈希函数有几个特点:\n\n- 同样的原始信息用同一个哈希函数总能得到相同的摘要信息\n- 原始信息任何微小的变化都会哈希出面目全非的摘要信息\n- 从摘要信息无法逆向推算出原始信息\n\n举例说明：\nHash (张三借给李四 100 万，利息 1%，1 年后还本息 …..) = AC4635D34DEF\n账本上记录了 AC4635D34DEF 这样一条记录。\n\n可以看出哈希函数有 4 个作用：\n\n- 简化信息\n  很好理解，哈希后的信息变短了。\n- 标识信息\n  可以使用 AC4635D34DEF 来标识原始信息，摘要信息也称为原始信息的 id。\n- 隐匿信息\n  账本是 AC4635D34DEF 这样一条记录，原始信息被隐匿。\n- 验证信息\n  假如李四在还款时欺骗说，张三只借给李四 10 万，双方可以用 AC4635D34DEF 来验证原始信息\n\n哈希函数的这 4 个作用在区块链技术里有广泛的运用。\n（哈希函数是一组函数或算法，以后会发文章专门介绍哈希）\n\n## 区块链记账方法\n\n假设有一个账页序号为 0 的账页交易记录如下:\n\n| 账号 | 入账 | 出账 | 余额 | 备注说明      |\n| ---- | ---- | ---- | ---- | ------------- |\n| 王二 | 100  |      | 190  | 收到 xxx 货款 |\n| 张三 |      | 100  | 30   | xxxx          |\n| 李四 | 120  | 90   | 170  | xxxx          |\n\n记账时间为：2017-10-22 10:22:02\n\n区块链在记账是会把账页信息（包含序号、记账时间、交易记录）作为原始信息进行 Hash, 得到一个 Hash 值，如：787635ACD, 用函数表示为：\n\n```\nHash(序号0、记账时间、交易记录) = 787635ACD\n```\n\n\n\n账页信息和 Hash 值组合在一起就构成了第一个区块。\n\n> 比特币系统里约 10 分钟记一次账，即每个区块生成时间大概间隔 10 分钟\n\n在记第 2 个账页的时候，会把上一个块的 Hash 值和当前的账页信息一起作为原始信息进行 Hash, 即：\n\n```\nHash(上一个Hash值、序号1、记账时间、交易记录) = 456635BCD\n```\n\n这样第 2 个区块不仅包含了本账页信息，还间接的包含了第一个区块的信息。依次按照此方法继续记账，则最新的区块总是间接包含了所有之前的账页信息。\n\n所有这些区块组合起来就形成了区块链，这样的区块链就构成了一个便于验证（只要验证最后一个区块的 Hash 值就相当于验证了整个账本），不可更改（任何一个交易信息的更改，会让所有之后的区块的 Hash 值发生变化，这样在验证时就无法通过）的总账本。","source":"_posts/block_chain/区块链记账原理.md","raw":"---\ntitle: 区块链记账原理\ndate: 2019-11-02 09:30:33\nlayout: config.default_layout\ncategories: 'block chain'\ntags:\n- 区块链\n- 比特币\n---\n\n区块链 (1.0) 是一个基于密码学安全的分布式账本，是一个方便验证，不可篡改的账本。\n通常认为与智能合约相结合的区块链为区块链 2.0, 如以太坊是典型的区块链 2.0\n很多人只了解过比特币，不知道区块链，比特币实际是一个使用了区块链技术的应用，只是比特币当前太热，把区块链技术的光芒给掩盖了。区块链才是未来，期望各位开发人员少关心币价，多关心技术。\n本文将讲解区块链 1.0 技术是如何实现的。\n\n\n\n## 哈希函数\n\n在讲区块链记账之前，先说明一下哈希函数。\n哈希函数：Hash (原始信息) = 摘要信息\n原始信息可以是任意的信息，hash 之后会得到一个简短的摘要信息\n\n哈希函数有几个特点:\n\n- 同样的原始信息用同一个哈希函数总能得到相同的摘要信息\n- 原始信息任何微小的变化都会哈希出面目全非的摘要信息\n- 从摘要信息无法逆向推算出原始信息\n\n举例说明：\nHash (张三借给李四 100 万，利息 1%，1 年后还本息 …..) = AC4635D34DEF\n账本上记录了 AC4635D34DEF 这样一条记录。\n\n可以看出哈希函数有 4 个作用：\n\n- 简化信息\n  很好理解，哈希后的信息变短了。\n- 标识信息\n  可以使用 AC4635D34DEF 来标识原始信息，摘要信息也称为原始信息的 id。\n- 隐匿信息\n  账本是 AC4635D34DEF 这样一条记录，原始信息被隐匿。\n- 验证信息\n  假如李四在还款时欺骗说，张三只借给李四 10 万，双方可以用 AC4635D34DEF 来验证原始信息\n\n哈希函数的这 4 个作用在区块链技术里有广泛的运用。\n（哈希函数是一组函数或算法，以后会发文章专门介绍哈希）\n\n## 区块链记账方法\n\n假设有一个账页序号为 0 的账页交易记录如下:\n\n| 账号 | 入账 | 出账 | 余额 | 备注说明      |\n| ---- | ---- | ---- | ---- | ------------- |\n| 王二 | 100  |      | 190  | 收到 xxx 货款 |\n| 张三 |      | 100  | 30   | xxxx          |\n| 李四 | 120  | 90   | 170  | xxxx          |\n\n记账时间为：2017-10-22 10:22:02\n\n区块链在记账是会把账页信息（包含序号、记账时间、交易记录）作为原始信息进行 Hash, 得到一个 Hash 值，如：787635ACD, 用函数表示为：\n\n```\nHash(序号0、记账时间、交易记录) = 787635ACD\n```\n\n\n\n账页信息和 Hash 值组合在一起就构成了第一个区块。\n\n> 比特币系统里约 10 分钟记一次账，即每个区块生成时间大概间隔 10 分钟\n\n在记第 2 个账页的时候，会把上一个块的 Hash 值和当前的账页信息一起作为原始信息进行 Hash, 即：\n\n```\nHash(上一个Hash值、序号1、记账时间、交易记录) = 456635BCD\n```\n\n这样第 2 个区块不仅包含了本账页信息，还间接的包含了第一个区块的信息。依次按照此方法继续记账，则最新的区块总是间接包含了所有之前的账页信息。\n\n所有这些区块组合起来就形成了区块链，这样的区块链就构成了一个便于验证（只要验证最后一个区块的 Hash 值就相当于验证了整个账本），不可更改（任何一个交易信息的更改，会让所有之后的区块的 Hash 值发生变化，这样在验证时就无法通过）的总账本。","slug":"block_chain/区块链记账原理","published":1,"updated":"2021-07-04T07:09:41.232Z","_id":"ckqoti0aw00031xmz3q40c591","comments":1,"photos":[],"link":"","content":"<p>区块链 (1.0) 是一个基于密码学安全的分布式账本，是一个方便验证，不可篡改的账本。<br>通常认为与智能合约相结合的区块链为区块链 2.0, 如以太坊是典型的区块链 2.0<br>很多人只了解过比特币，不知道区块链，比特币实际是一个使用了区块链技术的应用，只是比特币当前太热，把区块链技术的光芒给掩盖了。区块链才是未来，期望各位开发人员少关心币价，多关心技术。<br>本文将讲解区块链 1.0 技术是如何实现的。</p>\n<h2 id=\"哈希函数\"><a href=\"#哈希函数\" class=\"headerlink\" title=\"哈希函数\"></a>哈希函数</h2><p>在讲区块链记账之前，先说明一下哈希函数。<br>哈希函数：Hash (原始信息) = 摘要信息<br>原始信息可以是任意的信息，hash 之后会得到一个简短的摘要信息</p>\n<p>哈希函数有几个特点:</p>\n<ul>\n<li>同样的原始信息用同一个哈希函数总能得到相同的摘要信息</li>\n<li>原始信息任何微小的变化都会哈希出面目全非的摘要信息</li>\n<li>从摘要信息无法逆向推算出原始信息</li>\n</ul>\n<p>举例说明：<br>Hash (张三借给李四 100 万，利息 1%，1 年后还本息 …..) = AC4635D34DEF<br>账本上记录了 AC4635D34DEF 这样一条记录。</p>\n<p>可以看出哈希函数有 4 个作用：</p>\n<ul>\n<li>简化信息<br>很好理解，哈希后的信息变短了。</li>\n<li>标识信息<br>可以使用 AC4635D34DEF 来标识原始信息，摘要信息也称为原始信息的 id。</li>\n<li>隐匿信息<br>账本是 AC4635D34DEF 这样一条记录，原始信息被隐匿。</li>\n<li>验证信息<br>假如李四在还款时欺骗说，张三只借给李四 10 万，双方可以用 AC4635D34DEF 来验证原始信息</li>\n</ul>\n<p>哈希函数的这 4 个作用在区块链技术里有广泛的运用。<br>（哈希函数是一组函数或算法，以后会发文章专门介绍哈希）</p>\n<h2 id=\"区块链记账方法\"><a href=\"#区块链记账方法\" class=\"headerlink\" title=\"区块链记账方法\"></a>区块链记账方法</h2><p>假设有一个账页序号为 0 的账页交易记录如下:</p>\n<table>\n<thead>\n<tr>\n<th>账号</th>\n<th>入账</th>\n<th>出账</th>\n<th>余额</th>\n<th>备注说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>王二</td>\n<td>100</td>\n<td></td>\n<td>190</td>\n<td>收到 xxx 货款</td>\n</tr>\n<tr>\n<td>张三</td>\n<td></td>\n<td>100</td>\n<td>30</td>\n<td>xxxx</td>\n</tr>\n<tr>\n<td>李四</td>\n<td>120</td>\n<td>90</td>\n<td>170</td>\n<td>xxxx</td>\n</tr>\n</tbody></table>\n<p>记账时间为：2017-10-22 10:22:02</p>\n<p>区块链在记账是会把账页信息（包含序号、记账时间、交易记录）作为原始信息进行 Hash, 得到一个 Hash 值，如：787635ACD, 用函数表示为：</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs stylus\"><span class=\"hljs-function\"><span class=\"hljs-title\">Hash</span><span class=\"hljs-params\">(序号<span class=\"hljs-number\">0</span>、记账时间、交易记录)</span></span> = <span class=\"hljs-number\">787635</span>ACD<br></code></pre></div></td></tr></table></figure>\n\n\n\n<p>账页信息和 Hash 值组合在一起就构成了第一个区块。</p>\n<blockquote>\n<p>比特币系统里约 10 分钟记一次账，即每个区块生成时间大概间隔 10 分钟</p>\n</blockquote>\n<p>在记第 2 个账页的时候，会把上一个块的 Hash 值和当前的账页信息一起作为原始信息进行 Hash, 即：</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs stylus\"><span class=\"hljs-function\"><span class=\"hljs-title\">Hash</span><span class=\"hljs-params\">(上一个Hash值、序号<span class=\"hljs-number\">1</span>、记账时间、交易记录)</span></span> = <span class=\"hljs-number\">456635</span>BCD<br></code></pre></div></td></tr></table></figure>\n\n<p>这样第 2 个区块不仅包含了本账页信息，还间接的包含了第一个区块的信息。依次按照此方法继续记账，则最新的区块总是间接包含了所有之前的账页信息。</p>\n<p>所有这些区块组合起来就形成了区块链，这样的区块链就构成了一个便于验证（只要验证最后一个区块的 Hash 值就相当于验证了整个账本），不可更改（任何一个交易信息的更改，会让所有之后的区块的 Hash 值发生变化，这样在验证时就无法通过）的总账本。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>区块链 (1.0) 是一个基于密码学安全的分布式账本，是一个方便验证，不可篡改的账本。<br>通常认为与智能合约相结合的区块链为区块链 2.0, 如以太坊是典型的区块链 2.0<br>很多人只了解过比特币，不知道区块链，比特币实际是一个使用了区块链技术的应用，只是比特币当前太热，把区块链技术的光芒给掩盖了。区块链才是未来，期望各位开发人员少关心币价，多关心技术。<br>本文将讲解区块链 1.0 技术是如何实现的。</p>\n<h2 id=\"哈希函数\"><a href=\"#哈希函数\" class=\"headerlink\" title=\"哈希函数\"></a>哈希函数</h2><p>在讲区块链记账之前，先说明一下哈希函数。<br>哈希函数：Hash (原始信息) = 摘要信息<br>原始信息可以是任意的信息，hash 之后会得到一个简短的摘要信息</p>\n<p>哈希函数有几个特点:</p>\n<ul>\n<li>同样的原始信息用同一个哈希函数总能得到相同的摘要信息</li>\n<li>原始信息任何微小的变化都会哈希出面目全非的摘要信息</li>\n<li>从摘要信息无法逆向推算出原始信息</li>\n</ul>\n<p>举例说明：<br>Hash (张三借给李四 100 万，利息 1%，1 年后还本息 …..) = AC4635D34DEF<br>账本上记录了 AC4635D34DEF 这样一条记录。</p>\n<p>可以看出哈希函数有 4 个作用：</p>\n<ul>\n<li>简化信息<br>很好理解，哈希后的信息变短了。</li>\n<li>标识信息<br>可以使用 AC4635D34DEF 来标识原始信息，摘要信息也称为原始信息的 id。</li>\n<li>隐匿信息<br>账本是 AC4635D34DEF 这样一条记录，原始信息被隐匿。</li>\n<li>验证信息<br>假如李四在还款时欺骗说，张三只借给李四 10 万，双方可以用 AC4635D34DEF 来验证原始信息</li>\n</ul>\n<p>哈希函数的这 4 个作用在区块链技术里有广泛的运用。<br>（哈希函数是一组函数或算法，以后会发文章专门介绍哈希）</p>\n<h2 id=\"区块链记账方法\"><a href=\"#区块链记账方法\" class=\"headerlink\" title=\"区块链记账方法\"></a>区块链记账方法</h2><p>假设有一个账页序号为 0 的账页交易记录如下:</p>\n<table>\n<thead>\n<tr>\n<th>账号</th>\n<th>入账</th>\n<th>出账</th>\n<th>余额</th>\n<th>备注说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>王二</td>\n<td>100</td>\n<td></td>\n<td>190</td>\n<td>收到 xxx 货款</td>\n</tr>\n<tr>\n<td>张三</td>\n<td></td>\n<td>100</td>\n<td>30</td>\n<td>xxxx</td>\n</tr>\n<tr>\n<td>李四</td>\n<td>120</td>\n<td>90</td>\n<td>170</td>\n<td>xxxx</td>\n</tr>\n</tbody></table>\n<p>记账时间为：2017-10-22 10:22:02</p>\n<p>区块链在记账是会把账页信息（包含序号、记账时间、交易记录）作为原始信息进行 Hash, 得到一个 Hash 值，如：787635ACD, 用函数表示为：</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\"><span class=\"hljs-function\"><span class=\"hljs-title\">Hash</span><span class=\"hljs-params\">(序号<span class=\"hljs-number\">0</span>、记账时间、交易记录)</span></span> = <span class=\"hljs-number\">787635</span>ACD<br></code></pre></td></tr></table></figure>\n\n\n\n<p>账页信息和 Hash 值组合在一起就构成了第一个区块。</p>\n<blockquote>\n<p>比特币系统里约 10 分钟记一次账，即每个区块生成时间大概间隔 10 分钟</p>\n</blockquote>\n<p>在记第 2 个账页的时候，会把上一个块的 Hash 值和当前的账页信息一起作为原始信息进行 Hash, 即：</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\"><span class=\"hljs-function\"><span class=\"hljs-title\">Hash</span><span class=\"hljs-params\">(上一个Hash值、序号<span class=\"hljs-number\">1</span>、记账时间、交易记录)</span></span> = <span class=\"hljs-number\">456635</span>BCD<br></code></pre></td></tr></table></figure>\n\n<p>这样第 2 个区块不仅包含了本账页信息，还间接的包含了第一个区块的信息。依次按照此方法继续记账，则最新的区块总是间接包含了所有之前的账页信息。</p>\n<p>所有这些区块组合起来就形成了区块链，这样的区块链就构成了一个便于验证（只要验证最后一个区块的 Hash 值就相当于验证了整个账本），不可更改（任何一个交易信息的更改，会让所有之后的区块的 Hash 值发生变化，这样在验证时就无法通过）的总账本。</p>\n"},{"title":"以太坊是什么","date":"2019-11-02T03:12:33.000Z","layout":"config.default_layout","_content":"## 以太坊是什么\n\n以太坊（Ethereum）是一个建立在区块链技术之上， 去中心化应用平台。它允许任何人在平台中建立和使用通过区块链技术运行的去中心化应用。\n\n> 对这句话不理解的同学，姑且可以理解为以太坊是区块链里的 Android，它是一个开发平台，让我们就可以像基于 Android Framework 一样基于区块链技术写应用。\n\n在没有以太坊之前，写区块链应用是这样的：拷贝一份比特币代码，然后去改底层代码如加密算法，共识机制，网络协议等等（很多山寨币就是这样，改改就出来一个新币）。\n\n以太坊平台对底层区块链技术进行了封装，让区块链应用开发者可以直接基于以太坊平台进行开发，只要专注于开发应用本身逻辑的智能合约，这样就可以大大降低开发难度。\n\n> 目前围绕以太坊已经形成了一个最为完善的开发生态：有很多经过测试和验证的开发库、有完善的[开发者文档](https://learnblockchain.cn/docs/)（中文的也很多）及开发测试工具。\n\n## 智能合约\n\n那么什么是智能合约呢？**以太坊网络上运行程序就称之为智能合约**， 它和其他的程序一样，也是代码和数据 (状态) 的集合。\n\n智能合约（Smart Contract）和人工智能（Artificial Intelligence ）的智能没有关系，智能合约最早尼克萨博在 95 年就提出，它的概念很简单，就是将法律条文写成可执行代码。让法律条文的执行中立化，这个理念和区块链上的程序可以不被篡改、不被干预（只有有人触发交易，它将自动执行）的执行不谋而合，因此区块链引入了这个概念。\n\n在前面介绍[比特币脚本](https://learnblockchain.cn/2017/11/10/bitcoin-script/)的时候，我们讲到过比特币的交易也是可以编程的，但是比特币脚本有很多的限制，能够编写的程序也有限，而以太坊程序则是 “图灵完备的”，因此理论上让我们可以来编写可以做任何事情的程序。\n\n智能合约非常适合对信任、安全和持久性要求较高的应用场景，比如：数字货币、数字资产、投票、保险、金融应用、预测市场、产权所有权管理、物联网、点对点交易等等。\n目前除数字货币之外，真正落地的应用还不多（就像移动平台刚开始出来一样），相信 1 到 3 年内，各种杀手级会慢慢出现。\n\n进一步了解智能合约，可以阅读[完全了解智能合约运行原理](https://learnblockchain.cn/2018/01/04/understanding-smart-contracts/)。\n\n### 编程语言：Solidity\n\n智能合约现在的主要编程语言是 [Solidity](https://learnblockchain.cn/docs/solidity/) 和 Vyper ，`Solidity` 更为成熟一些，`Solidity` 合约文件扩展名是 `.sol` ，虽然是一门新语言，但是但是他和大家常用的现代语言很相似，学期来 以下就是一个简单的计数器智能合约：\n\n```\npragma solidity >=0.4.22 <0.6.0;\n // 用contract 关键字定义一个合约\ncontract Counter { \n    uint counter;\n\n    function count() public {\n        counter = counter + 1;\n    }\n}\n```\n\n\n\n如果上面的合约把 `contract` 改成 `class` ，就和其他语言里定义一个类一样了。 `Solidity` 是一门编译型语言，代码被编译为以太坊虚拟机字节码之后，再部署到以太坊网络。以太坊为我们提供了很好的工具来完成这项工作，比如：[Remix](https://remix.ethereum.org/) 就是用来开发、编译、部署智能合约的 IDE，它还是一个基于浏览器的 Web IDE，下面是 Remix IDE 的一个截图。\n![Remix IDE](https://img.learnblockchain.cn/2019/06/15613593398072.jpg)\n\nSolidity 是静态类型语言，支持继承、库和复杂的用户定义类型等特性。 了解更多 Solidity 知识，可以参考社区翻译的 [Solidity 中文文档](https://learnblockchain.cn/docs/solidity/)。\n\n### 运行环境：EVM\n\nEVM（Ethereum Virtual Machine）[以太坊虚拟机](https://learnblockchain.cn/2019/04/09/easy-evm/) 用来执行以太坊上的交易，提供智能合约的运行环境。\n\n> Solidity 之于 EVM，就像之于跟 JVM 的关系一样，这样大家就容易理解了。\n> [以太坊虚拟机](https://learnblockchain.cn/2019/04/09/easy-evm/)是一个隔离的环境，外部无法接触到在 EVM 内部运行的代码。\n\n而 EVM 运行在以太坊节点上，当我们把合约部署到以太坊网络上之后，合约就可以在以太坊网络中运行了。\n\n### 合约的编译\n\n以太坊虚拟机上运行的是合约的字节码形式，需要我们在部署之前先对合约进行编译，可以选择 [Remix](https://remix.ethereum.org/) 或 solc 编译器。\n\n### 合约的部署\n\n在以太坊上开发应用时，常常要使用到以太坊客户端（钱包）。平时我们在开发中，一般不接触到客户端或钱包的概念，它是什么呢？\n\n#### 以太坊客户端（钱包）\n\n以太坊客户端，其实我们可以把它理解为一个开发者工具，它提供账户管理、挖矿、转账、智能合约的部署和执行等等功能。\n\n> EVM 是由以太坊客户端提供的\n\n**Geth** 是典型的开发以太坊时使用的客户端，基于 Go 语言开发。 `Geth` 提供了一个交互式命令控制台，通过命令控制台中包含了以太坊的各种功能（API）。Geth 的使用我们之后会有文章介绍，这里大家先有个概念。\n\n> \bGeth 控制台和 Chrome 浏览器开发者工具里的面的控制台是类似的，不过 Geth 控制台是跑在终端里。\n\n#### 如何部署\n\n智能合约的部署是指把合约字节码发布到区块链上，并使用一个特定的地址来标示这个合约，这个地址称为合约账户。\n\n> 以太坊中有两类账户：\n>\n> - 外部账户\n>   该类账户被私钥控制（由人控制），没有关联任何代码。\n> - 合约账户\n>   该类账户被它们的合约代码控制且有代码与之关联。\n>\n> > 和比特币使用 UTXO 的设计不一样，以太坊使用更为简单的账户概念。\n> > 两类账户对于 EVM 来说是一样的。\n>\n> 外部账户与合约账户的区别和关系是这样的：一个外部账户可以通过创建和用自己的私钥来对交易进行签名，来发送消息给另一个外部账户或合约账户。\n> 在两个外部账户之间传送消息是价值转移的过程。但从外部账户到合约账户的消息会激活合约账户的代码，允许它执行各种动作（比如转移代币，写入内部存储，挖出一个新代币，执行一些运算，创建一个新的合约等等）。\n> 只有当外部账户发出指令时，合同账户才会执行相应的操作。\n\n合约部署就是将编译好的合约字节码通过外部账号发送交易的形式部署到以太坊区块链上（由实际矿工出块之后，才真正部署成功）。\n\n### 运行\n\n合约部署之后，当需要调用这个智能合约的方法时只需要向这个合约账户发送消息（交易）即可，通过消息触发后智能合约的代码就会在 EVM 中执行了。\n\n## Gas\n\n和云计算相似，占用区块链的资源（不管是简单的转账交易，还是合约的部署和执行）同样需要付出相应的费用（天下没有免费的午餐对不对！）。\n\n以太坊上用 Gas 机制来计费，Gas 也可以认为是一个工作量单位，智能合约越复杂（计算步骤的数量和类型，占用的内存等），用来完成运行就需要越多 Gas。\n\n任何特定的合约所需的运行合约的 Gas 数量是固定的，由合约的复杂度决定。\n而 Gas 价格由运行合约的人在提交运行合约请求的时候设定，以确定他愿意为这次交易愿意付出的费用：Gas 价格（用以太币计价） * Gas 数量。\n\nGas 的目的是限制执行交易所需的工作量，同时为执行支付费用。当 EVM 执行交易时，Gas 将按照特定规则被逐渐消耗，无论执行到什么位置，一旦 Gas 被耗尽，将会触发异常。当前调用帧所做的所有状态修改都将被回滚， 如果执行结束还有 Gas 剩余，这些 Gas 将被返还给发送账户。\n\n> 如果没有这个限制，就会有人写出无法停止（如：死循环）的合约来阻塞网络。\n\n因此实际上（把前面的内容串起来），我们需要一个有以太币余额的外部账户，来发起一个交易（普通交易或部署、运行一个合约），运行时，矿工收取相应的工作量费用。\n\n## 以太坊网络\n\n有些着急的同学要问了，没有以太币，要怎么进行智能合约的开发？可以选择以下方式：\n\n### 选择以太坊官网测试网络 Testnet\n\n测试网络中，我们可以很容易获得免费的以太币，缺点是需要发很长时间初始化节点。\n\n### 使用私有链\n\n创建自己的以太币私有测试网络，通常也称为私有链，我们可以用它来作为一个测试环境来开发、调试和测试智能合约。\n通过上面提到的 Geth 很容易就可以创建一个属于自己的测试网络，以太币想挖多少挖多少，也免去了同步正式网络的整个区块链数据。\n\n### 使用开发者网络 (模式)\n\n相比私有链，开发者网络 (模式) 下，会自动分配一个有大量余额的开发者账户给我们使用。\n\n### 使用模拟环境\n\n另一个创建测试网络的方法是使用 Ganache，Ganache 是普通的应用程序，它在本地使用内存模拟的一个以太坊区块链环境，对于开发调试来说，更方便快捷。而且 Ganache 会在启动时帮我们创建 10 个存有资金的测试账户。\n进行合约开发时，可以在 Ganache 中测试通过后，再部署到 Geth 节点中去。\n\n## DApp：去中心化的应用程序\n\n以太坊社区把基于智能合约的应用称为去中心化的应用程序 (Decentralized App)。如果我们把区块链理解为一个不可篡改的数据库，智能合约理解为和数据库打交道的程序，那就很容易理解 DApp 了，一个 DApp 不单单有智能合约（相当于应用的后台），比如还需要有一个友好的用户界面。\n\n### Truffle\n\n[Truffle](https://learnblockchain.cn/docs/truffle/) 是一个非常流行 DApp 开发框架，他可以帮我们处理掉大量无关紧要的小事情，让我们可以迅速开始写代码 - 编译 - 部署 - 测试 - 打包 DApp 这个流程。\n\n## 总结\n\n我们现在来总结一下，以太坊是平台，它让我们方便的使用区块链技术开发去中心化的应用，在这个应用中，使用 Solidity 来编写和区块链交互的智能合约，合约编写好后之后，我们需要用以太坊客户端用一个有余额的账户去部署及运行合约（使用 [Truffle](https://learnblockchain.cn/docs/truffle/) 可以更好的帮助我们做这些事情了）。为了开发方便，我们可以用 Geth 或 Ganache 来搭建一个测试网络。\n\n注：本文中为了方便大家理解，对一些概念做了类比，有些严格来不是准确，不过我也认为对于初学者，也没有必要把每一个概念掌握的很细致和准确，学习是一个逐步深入的过程，很多时候我们会发现，过一段后，我们会对同一个东西有不一样的理解。","source":"_posts/block_chain/以太坊是什么.md","raw":"---\ntitle: 以太坊是什么\ndate: 2019-11-02 11:12:33\nlayout: config.default_layout\ncategories: 'block chain'\ntags:\n- 区块链\n- 比特币\n- 以太坊\n---\n## 以太坊是什么\n\n以太坊（Ethereum）是一个建立在区块链技术之上， 去中心化应用平台。它允许任何人在平台中建立和使用通过区块链技术运行的去中心化应用。\n\n> 对这句话不理解的同学，姑且可以理解为以太坊是区块链里的 Android，它是一个开发平台，让我们就可以像基于 Android Framework 一样基于区块链技术写应用。\n\n在没有以太坊之前，写区块链应用是这样的：拷贝一份比特币代码，然后去改底层代码如加密算法，共识机制，网络协议等等（很多山寨币就是这样，改改就出来一个新币）。\n\n以太坊平台对底层区块链技术进行了封装，让区块链应用开发者可以直接基于以太坊平台进行开发，只要专注于开发应用本身逻辑的智能合约，这样就可以大大降低开发难度。\n\n> 目前围绕以太坊已经形成了一个最为完善的开发生态：有很多经过测试和验证的开发库、有完善的[开发者文档](https://learnblockchain.cn/docs/)（中文的也很多）及开发测试工具。\n\n## 智能合约\n\n那么什么是智能合约呢？**以太坊网络上运行程序就称之为智能合约**， 它和其他的程序一样，也是代码和数据 (状态) 的集合。\n\n智能合约（Smart Contract）和人工智能（Artificial Intelligence ）的智能没有关系，智能合约最早尼克萨博在 95 年就提出，它的概念很简单，就是将法律条文写成可执行代码。让法律条文的执行中立化，这个理念和区块链上的程序可以不被篡改、不被干预（只有有人触发交易，它将自动执行）的执行不谋而合，因此区块链引入了这个概念。\n\n在前面介绍[比特币脚本](https://learnblockchain.cn/2017/11/10/bitcoin-script/)的时候，我们讲到过比特币的交易也是可以编程的，但是比特币脚本有很多的限制，能够编写的程序也有限，而以太坊程序则是 “图灵完备的”，因此理论上让我们可以来编写可以做任何事情的程序。\n\n智能合约非常适合对信任、安全和持久性要求较高的应用场景，比如：数字货币、数字资产、投票、保险、金融应用、预测市场、产权所有权管理、物联网、点对点交易等等。\n目前除数字货币之外，真正落地的应用还不多（就像移动平台刚开始出来一样），相信 1 到 3 年内，各种杀手级会慢慢出现。\n\n进一步了解智能合约，可以阅读[完全了解智能合约运行原理](https://learnblockchain.cn/2018/01/04/understanding-smart-contracts/)。\n\n### 编程语言：Solidity\n\n智能合约现在的主要编程语言是 [Solidity](https://learnblockchain.cn/docs/solidity/) 和 Vyper ，`Solidity` 更为成熟一些，`Solidity` 合约文件扩展名是 `.sol` ，虽然是一门新语言，但是但是他和大家常用的现代语言很相似，学期来 以下就是一个简单的计数器智能合约：\n\n```\npragma solidity >=0.4.22 <0.6.0;\n // 用contract 关键字定义一个合约\ncontract Counter { \n    uint counter;\n\n    function count() public {\n        counter = counter + 1;\n    }\n}\n```\n\n\n\n如果上面的合约把 `contract` 改成 `class` ，就和其他语言里定义一个类一样了。 `Solidity` 是一门编译型语言，代码被编译为以太坊虚拟机字节码之后，再部署到以太坊网络。以太坊为我们提供了很好的工具来完成这项工作，比如：[Remix](https://remix.ethereum.org/) 就是用来开发、编译、部署智能合约的 IDE，它还是一个基于浏览器的 Web IDE，下面是 Remix IDE 的一个截图。\n![Remix IDE](https://img.learnblockchain.cn/2019/06/15613593398072.jpg)\n\nSolidity 是静态类型语言，支持继承、库和复杂的用户定义类型等特性。 了解更多 Solidity 知识，可以参考社区翻译的 [Solidity 中文文档](https://learnblockchain.cn/docs/solidity/)。\n\n### 运行环境：EVM\n\nEVM（Ethereum Virtual Machine）[以太坊虚拟机](https://learnblockchain.cn/2019/04/09/easy-evm/) 用来执行以太坊上的交易，提供智能合约的运行环境。\n\n> Solidity 之于 EVM，就像之于跟 JVM 的关系一样，这样大家就容易理解了。\n> [以太坊虚拟机](https://learnblockchain.cn/2019/04/09/easy-evm/)是一个隔离的环境，外部无法接触到在 EVM 内部运行的代码。\n\n而 EVM 运行在以太坊节点上，当我们把合约部署到以太坊网络上之后，合约就可以在以太坊网络中运行了。\n\n### 合约的编译\n\n以太坊虚拟机上运行的是合约的字节码形式，需要我们在部署之前先对合约进行编译，可以选择 [Remix](https://remix.ethereum.org/) 或 solc 编译器。\n\n### 合约的部署\n\n在以太坊上开发应用时，常常要使用到以太坊客户端（钱包）。平时我们在开发中，一般不接触到客户端或钱包的概念，它是什么呢？\n\n#### 以太坊客户端（钱包）\n\n以太坊客户端，其实我们可以把它理解为一个开发者工具，它提供账户管理、挖矿、转账、智能合约的部署和执行等等功能。\n\n> EVM 是由以太坊客户端提供的\n\n**Geth** 是典型的开发以太坊时使用的客户端，基于 Go 语言开发。 `Geth` 提供了一个交互式命令控制台，通过命令控制台中包含了以太坊的各种功能（API）。Geth 的使用我们之后会有文章介绍，这里大家先有个概念。\n\n> \bGeth 控制台和 Chrome 浏览器开发者工具里的面的控制台是类似的，不过 Geth 控制台是跑在终端里。\n\n#### 如何部署\n\n智能合约的部署是指把合约字节码发布到区块链上，并使用一个特定的地址来标示这个合约，这个地址称为合约账户。\n\n> 以太坊中有两类账户：\n>\n> - 外部账户\n>   该类账户被私钥控制（由人控制），没有关联任何代码。\n> - 合约账户\n>   该类账户被它们的合约代码控制且有代码与之关联。\n>\n> > 和比特币使用 UTXO 的设计不一样，以太坊使用更为简单的账户概念。\n> > 两类账户对于 EVM 来说是一样的。\n>\n> 外部账户与合约账户的区别和关系是这样的：一个外部账户可以通过创建和用自己的私钥来对交易进行签名，来发送消息给另一个外部账户或合约账户。\n> 在两个外部账户之间传送消息是价值转移的过程。但从外部账户到合约账户的消息会激活合约账户的代码，允许它执行各种动作（比如转移代币，写入内部存储，挖出一个新代币，执行一些运算，创建一个新的合约等等）。\n> 只有当外部账户发出指令时，合同账户才会执行相应的操作。\n\n合约部署就是将编译好的合约字节码通过外部账号发送交易的形式部署到以太坊区块链上（由实际矿工出块之后，才真正部署成功）。\n\n### 运行\n\n合约部署之后，当需要调用这个智能合约的方法时只需要向这个合约账户发送消息（交易）即可，通过消息触发后智能合约的代码就会在 EVM 中执行了。\n\n## Gas\n\n和云计算相似，占用区块链的资源（不管是简单的转账交易，还是合约的部署和执行）同样需要付出相应的费用（天下没有免费的午餐对不对！）。\n\n以太坊上用 Gas 机制来计费，Gas 也可以认为是一个工作量单位，智能合约越复杂（计算步骤的数量和类型，占用的内存等），用来完成运行就需要越多 Gas。\n\n任何特定的合约所需的运行合约的 Gas 数量是固定的，由合约的复杂度决定。\n而 Gas 价格由运行合约的人在提交运行合约请求的时候设定，以确定他愿意为这次交易愿意付出的费用：Gas 价格（用以太币计价） * Gas 数量。\n\nGas 的目的是限制执行交易所需的工作量，同时为执行支付费用。当 EVM 执行交易时，Gas 将按照特定规则被逐渐消耗，无论执行到什么位置，一旦 Gas 被耗尽，将会触发异常。当前调用帧所做的所有状态修改都将被回滚， 如果执行结束还有 Gas 剩余，这些 Gas 将被返还给发送账户。\n\n> 如果没有这个限制，就会有人写出无法停止（如：死循环）的合约来阻塞网络。\n\n因此实际上（把前面的内容串起来），我们需要一个有以太币余额的外部账户，来发起一个交易（普通交易或部署、运行一个合约），运行时，矿工收取相应的工作量费用。\n\n## 以太坊网络\n\n有些着急的同学要问了，没有以太币，要怎么进行智能合约的开发？可以选择以下方式：\n\n### 选择以太坊官网测试网络 Testnet\n\n测试网络中，我们可以很容易获得免费的以太币，缺点是需要发很长时间初始化节点。\n\n### 使用私有链\n\n创建自己的以太币私有测试网络，通常也称为私有链，我们可以用它来作为一个测试环境来开发、调试和测试智能合约。\n通过上面提到的 Geth 很容易就可以创建一个属于自己的测试网络，以太币想挖多少挖多少，也免去了同步正式网络的整个区块链数据。\n\n### 使用开发者网络 (模式)\n\n相比私有链，开发者网络 (模式) 下，会自动分配一个有大量余额的开发者账户给我们使用。\n\n### 使用模拟环境\n\n另一个创建测试网络的方法是使用 Ganache，Ganache 是普通的应用程序，它在本地使用内存模拟的一个以太坊区块链环境，对于开发调试来说，更方便快捷。而且 Ganache 会在启动时帮我们创建 10 个存有资金的测试账户。\n进行合约开发时，可以在 Ganache 中测试通过后，再部署到 Geth 节点中去。\n\n## DApp：去中心化的应用程序\n\n以太坊社区把基于智能合约的应用称为去中心化的应用程序 (Decentralized App)。如果我们把区块链理解为一个不可篡改的数据库，智能合约理解为和数据库打交道的程序，那就很容易理解 DApp 了，一个 DApp 不单单有智能合约（相当于应用的后台），比如还需要有一个友好的用户界面。\n\n### Truffle\n\n[Truffle](https://learnblockchain.cn/docs/truffle/) 是一个非常流行 DApp 开发框架，他可以帮我们处理掉大量无关紧要的小事情，让我们可以迅速开始写代码 - 编译 - 部署 - 测试 - 打包 DApp 这个流程。\n\n## 总结\n\n我们现在来总结一下，以太坊是平台，它让我们方便的使用区块链技术开发去中心化的应用，在这个应用中，使用 Solidity 来编写和区块链交互的智能合约，合约编写好后之后，我们需要用以太坊客户端用一个有余额的账户去部署及运行合约（使用 [Truffle](https://learnblockchain.cn/docs/truffle/) 可以更好的帮助我们做这些事情了）。为了开发方便，我们可以用 Geth 或 Ganache 来搭建一个测试网络。\n\n注：本文中为了方便大家理解，对一些概念做了类比，有些严格来不是准确，不过我也认为对于初学者，也没有必要把每一个概念掌握的很细致和准确，学习是一个逐步深入的过程，很多时候我们会发现，过一段后，我们会对同一个东西有不一样的理解。","slug":"block_chain/以太坊是什么","published":1,"updated":"2021-07-04T07:10:08.280Z","_id":"ckqoti0ax00041xmz62lydneh","comments":1,"photos":[],"link":"","content":"<h2 id=\"以太坊是什么\"><a href=\"#以太坊是什么\" class=\"headerlink\" title=\"以太坊是什么\"></a>以太坊是什么</h2><p>以太坊（Ethereum）是一个建立在区块链技术之上， 去中心化应用平台。它允许任何人在平台中建立和使用通过区块链技术运行的去中心化应用。</p>\n<blockquote>\n<p>对这句话不理解的同学，姑且可以理解为以太坊是区块链里的 Android，它是一个开发平台，让我们就可以像基于 Android Framework 一样基于区块链技术写应用。</p>\n</blockquote>\n<p>在没有以太坊之前，写区块链应用是这样的：拷贝一份比特币代码，然后去改底层代码如加密算法，共识机制，网络协议等等（很多山寨币就是这样，改改就出来一个新币）。</p>\n<p>以太坊平台对底层区块链技术进行了封装，让区块链应用开发者可以直接基于以太坊平台进行开发，只要专注于开发应用本身逻辑的智能合约，这样就可以大大降低开发难度。</p>\n<blockquote>\n<p>目前围绕以太坊已经形成了一个最为完善的开发生态：有很多经过测试和验证的开发库、有完善的<a href=\"https://learnblockchain.cn/docs/\">开发者文档</a>（中文的也很多）及开发测试工具。</p>\n</blockquote>\n<h2 id=\"智能合约\"><a href=\"#智能合约\" class=\"headerlink\" title=\"智能合约\"></a>智能合约</h2><p>那么什么是智能合约呢？<strong>以太坊网络上运行程序就称之为智能合约</strong>， 它和其他的程序一样，也是代码和数据 (状态) 的集合。</p>\n<p>智能合约（Smart Contract）和人工智能（Artificial Intelligence ）的智能没有关系，智能合约最早尼克萨博在 95 年就提出，它的概念很简单，就是将法律条文写成可执行代码。让法律条文的执行中立化，这个理念和区块链上的程序可以不被篡改、不被干预（只有有人触发交易，它将自动执行）的执行不谋而合，因此区块链引入了这个概念。</p>\n<p>在前面介绍<a href=\"https://learnblockchain.cn/2017/11/10/bitcoin-script/\">比特币脚本</a>的时候，我们讲到过比特币的交易也是可以编程的，但是比特币脚本有很多的限制，能够编写的程序也有限，而以太坊程序则是 “图灵完备的”，因此理论上让我们可以来编写可以做任何事情的程序。</p>\n<p>智能合约非常适合对信任、安全和持久性要求较高的应用场景，比如：数字货币、数字资产、投票、保险、金融应用、预测市场、产权所有权管理、物联网、点对点交易等等。<br>目前除数字货币之外，真正落地的应用还不多（就像移动平台刚开始出来一样），相信 1 到 3 年内，各种杀手级会慢慢出现。</p>\n<p>进一步了解智能合约，可以阅读<a href=\"https://learnblockchain.cn/2018/01/04/understanding-smart-contracts/\">完全了解智能合约运行原理</a>。</p>\n<h3 id=\"编程语言：Solidity\"><a href=\"#编程语言：Solidity\" class=\"headerlink\" title=\"编程语言：Solidity\"></a>编程语言：Solidity</h3><p>智能合约现在的主要编程语言是 <a href=\"https://learnblockchain.cn/docs/solidity/\">Solidity</a> 和 Vyper ，<code>Solidity</code> 更为成熟一些，<code>Solidity</code> 合约文件扩展名是 <code>.sol</code> ，虽然是一门新语言，但是但是他和大家常用的现代语言很相似，学期来 以下就是一个简单的计数器智能合约：</p>\n<figure class=\"highlight d\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs d\"><span class=\"hljs-keyword\">pragma</span> solidity &gt;=<span class=\"hljs-number\">0.4</span><span class=\"hljs-number\">.22</span> &lt;<span class=\"hljs-number\">0.6</span><span class=\"hljs-number\">.0</span>;<br> <span class=\"hljs-comment\">// 用contract 关键字定义一个合约</span><br>contract Counter &#123; <br>    <span class=\"hljs-built_in\">uint</span> counter;<br><br>    <span class=\"hljs-built_in\">function</span> count() <span class=\"hljs-keyword\">public</span> &#123;<br>        counter = counter + <span class=\"hljs-number\">1</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n\n\n<p>如果上面的合约把 <code>contract</code> 改成 <code>class</code> ，就和其他语言里定义一个类一样了。 <code>Solidity</code> 是一门编译型语言，代码被编译为以太坊虚拟机字节码之后，再部署到以太坊网络。以太坊为我们提供了很好的工具来完成这项工作，比如：<a href=\"https://remix.ethereum.org/\">Remix</a> 就是用来开发、编译、部署智能合约的 IDE，它还是一个基于浏览器的 Web IDE，下面是 Remix IDE 的一个截图。<br><img src=\"https://img.learnblockchain.cn/2019/06/15613593398072.jpg\" alt=\"Remix IDE\"></p>\n<p>Solidity 是静态类型语言，支持继承、库和复杂的用户定义类型等特性。 了解更多 Solidity 知识，可以参考社区翻译的 <a href=\"https://learnblockchain.cn/docs/solidity/\">Solidity 中文文档</a>。</p>\n<h3 id=\"运行环境：EVM\"><a href=\"#运行环境：EVM\" class=\"headerlink\" title=\"运行环境：EVM\"></a>运行环境：EVM</h3><p>EVM（Ethereum Virtual Machine）<a href=\"https://learnblockchain.cn/2019/04/09/easy-evm/\">以太坊虚拟机</a> 用来执行以太坊上的交易，提供智能合约的运行环境。</p>\n<blockquote>\n<p>Solidity 之于 EVM，就像之于跟 JVM 的关系一样，这样大家就容易理解了。<br><a href=\"https://learnblockchain.cn/2019/04/09/easy-evm/\">以太坊虚拟机</a>是一个隔离的环境，外部无法接触到在 EVM 内部运行的代码。</p>\n</blockquote>\n<p>而 EVM 运行在以太坊节点上，当我们把合约部署到以太坊网络上之后，合约就可以在以太坊网络中运行了。</p>\n<h3 id=\"合约的编译\"><a href=\"#合约的编译\" class=\"headerlink\" title=\"合约的编译\"></a>合约的编译</h3><p>以太坊虚拟机上运行的是合约的字节码形式，需要我们在部署之前先对合约进行编译，可以选择 <a href=\"https://remix.ethereum.org/\">Remix</a> 或 solc 编译器。</p>\n<h3 id=\"合约的部署\"><a href=\"#合约的部署\" class=\"headerlink\" title=\"合约的部署\"></a>合约的部署</h3><p>在以太坊上开发应用时，常常要使用到以太坊客户端（钱包）。平时我们在开发中，一般不接触到客户端或钱包的概念，它是什么呢？</p>\n<h4 id=\"以太坊客户端（钱包）\"><a href=\"#以太坊客户端（钱包）\" class=\"headerlink\" title=\"以太坊客户端（钱包）\"></a>以太坊客户端（钱包）</h4><p>以太坊客户端，其实我们可以把它理解为一个开发者工具，它提供账户管理、挖矿、转账、智能合约的部署和执行等等功能。</p>\n<blockquote>\n<p>EVM 是由以太坊客户端提供的</p>\n</blockquote>\n<p><strong>Geth</strong> 是典型的开发以太坊时使用的客户端，基于 Go 语言开发。 <code>Geth</code> 提供了一个交互式命令控制台，通过命令控制台中包含了以太坊的各种功能（API）。Geth 的使用我们之后会有文章介绍，这里大家先有个概念。</p>\n<blockquote>\n<p>\bGeth 控制台和 Chrome 浏览器开发者工具里的面的控制台是类似的，不过 Geth 控制台是跑在终端里。</p>\n</blockquote>\n<h4 id=\"如何部署\"><a href=\"#如何部署\" class=\"headerlink\" title=\"如何部署\"></a>如何部署</h4><p>智能合约的部署是指把合约字节码发布到区块链上，并使用一个特定的地址来标示这个合约，这个地址称为合约账户。</p>\n<blockquote>\n<p>以太坊中有两类账户：</p>\n<ul>\n<li>外部账户<br>该类账户被私钥控制（由人控制），没有关联任何代码。</li>\n<li>合约账户<br>该类账户被它们的合约代码控制且有代码与之关联。</li>\n</ul>\n<blockquote>\n<p>和比特币使用 UTXO 的设计不一样，以太坊使用更为简单的账户概念。<br>两类账户对于 EVM 来说是一样的。</p>\n</blockquote>\n<p>外部账户与合约账户的区别和关系是这样的：一个外部账户可以通过创建和用自己的私钥来对交易进行签名，来发送消息给另一个外部账户或合约账户。<br>在两个外部账户之间传送消息是价值转移的过程。但从外部账户到合约账户的消息会激活合约账户的代码，允许它执行各种动作（比如转移代币，写入内部存储，挖出一个新代币，执行一些运算，创建一个新的合约等等）。<br>只有当外部账户发出指令时，合同账户才会执行相应的操作。</p>\n</blockquote>\n<p>合约部署就是将编译好的合约字节码通过外部账号发送交易的形式部署到以太坊区块链上（由实际矿工出块之后，才真正部署成功）。</p>\n<h3 id=\"运行\"><a href=\"#运行\" class=\"headerlink\" title=\"运行\"></a>运行</h3><p>合约部署之后，当需要调用这个智能合约的方法时只需要向这个合约账户发送消息（交易）即可，通过消息触发后智能合约的代码就会在 EVM 中执行了。</p>\n<h2 id=\"Gas\"><a href=\"#Gas\" class=\"headerlink\" title=\"Gas\"></a>Gas</h2><p>和云计算相似，占用区块链的资源（不管是简单的转账交易，还是合约的部署和执行）同样需要付出相应的费用（天下没有免费的午餐对不对！）。</p>\n<p>以太坊上用 Gas 机制来计费，Gas 也可以认为是一个工作量单位，智能合约越复杂（计算步骤的数量和类型，占用的内存等），用来完成运行就需要越多 Gas。</p>\n<p>任何特定的合约所需的运行合约的 Gas 数量是固定的，由合约的复杂度决定。<br>而 Gas 价格由运行合约的人在提交运行合约请求的时候设定，以确定他愿意为这次交易愿意付出的费用：Gas 价格（用以太币计价） * Gas 数量。</p>\n<p>Gas 的目的是限制执行交易所需的工作量，同时为执行支付费用。当 EVM 执行交易时，Gas 将按照特定规则被逐渐消耗，无论执行到什么位置，一旦 Gas 被耗尽，将会触发异常。当前调用帧所做的所有状态修改都将被回滚， 如果执行结束还有 Gas 剩余，这些 Gas 将被返还给发送账户。</p>\n<blockquote>\n<p>如果没有这个限制，就会有人写出无法停止（如：死循环）的合约来阻塞网络。</p>\n</blockquote>\n<p>因此实际上（把前面的内容串起来），我们需要一个有以太币余额的外部账户，来发起一个交易（普通交易或部署、运行一个合约），运行时，矿工收取相应的工作量费用。</p>\n<h2 id=\"以太坊网络\"><a href=\"#以太坊网络\" class=\"headerlink\" title=\"以太坊网络\"></a>以太坊网络</h2><p>有些着急的同学要问了，没有以太币，要怎么进行智能合约的开发？可以选择以下方式：</p>\n<h3 id=\"选择以太坊官网测试网络-Testnet\"><a href=\"#选择以太坊官网测试网络-Testnet\" class=\"headerlink\" title=\"选择以太坊官网测试网络 Testnet\"></a>选择以太坊官网测试网络 Testnet</h3><p>测试网络中，我们可以很容易获得免费的以太币，缺点是需要发很长时间初始化节点。</p>\n<h3 id=\"使用私有链\"><a href=\"#使用私有链\" class=\"headerlink\" title=\"使用私有链\"></a>使用私有链</h3><p>创建自己的以太币私有测试网络，通常也称为私有链，我们可以用它来作为一个测试环境来开发、调试和测试智能合约。<br>通过上面提到的 Geth 很容易就可以创建一个属于自己的测试网络，以太币想挖多少挖多少，也免去了同步正式网络的整个区块链数据。</p>\n<h3 id=\"使用开发者网络-模式\"><a href=\"#使用开发者网络-模式\" class=\"headerlink\" title=\"使用开发者网络 (模式)\"></a>使用开发者网络 (模式)</h3><p>相比私有链，开发者网络 (模式) 下，会自动分配一个有大量余额的开发者账户给我们使用。</p>\n<h3 id=\"使用模拟环境\"><a href=\"#使用模拟环境\" class=\"headerlink\" title=\"使用模拟环境\"></a>使用模拟环境</h3><p>另一个创建测试网络的方法是使用 Ganache，Ganache 是普通的应用程序，它在本地使用内存模拟的一个以太坊区块链环境，对于开发调试来说，更方便快捷。而且 Ganache 会在启动时帮我们创建 10 个存有资金的测试账户。<br>进行合约开发时，可以在 Ganache 中测试通过后，再部署到 Geth 节点中去。</p>\n<h2 id=\"DApp：去中心化的应用程序\"><a href=\"#DApp：去中心化的应用程序\" class=\"headerlink\" title=\"DApp：去中心化的应用程序\"></a>DApp：去中心化的应用程序</h2><p>以太坊社区把基于智能合约的应用称为去中心化的应用程序 (Decentralized App)。如果我们把区块链理解为一个不可篡改的数据库，智能合约理解为和数据库打交道的程序，那就很容易理解 DApp 了，一个 DApp 不单单有智能合约（相当于应用的后台），比如还需要有一个友好的用户界面。</p>\n<h3 id=\"Truffle\"><a href=\"#Truffle\" class=\"headerlink\" title=\"Truffle\"></a>Truffle</h3><p><a href=\"https://learnblockchain.cn/docs/truffle/\">Truffle</a> 是一个非常流行 DApp 开发框架，他可以帮我们处理掉大量无关紧要的小事情，让我们可以迅速开始写代码 - 编译 - 部署 - 测试 - 打包 DApp 这个流程。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>我们现在来总结一下，以太坊是平台，它让我们方便的使用区块链技术开发去中心化的应用，在这个应用中，使用 Solidity 来编写和区块链交互的智能合约，合约编写好后之后，我们需要用以太坊客户端用一个有余额的账户去部署及运行合约（使用 <a href=\"https://learnblockchain.cn/docs/truffle/\">Truffle</a> 可以更好的帮助我们做这些事情了）。为了开发方便，我们可以用 Geth 或 Ganache 来搭建一个测试网络。</p>\n<p>注：本文中为了方便大家理解，对一些概念做了类比，有些严格来不是准确，不过我也认为对于初学者，也没有必要把每一个概念掌握的很细致和准确，学习是一个逐步深入的过程，很多时候我们会发现，过一段后，我们会对同一个东西有不一样的理解。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"以太坊是什么\"><a href=\"#以太坊是什么\" class=\"headerlink\" title=\"以太坊是什么\"></a>以太坊是什么</h2><p>以太坊（Ethereum）是一个建立在区块链技术之上， 去中心化应用平台。它允许任何人在平台中建立和使用通过区块链技术运行的去中心化应用。</p>\n<blockquote>\n<p>对这句话不理解的同学，姑且可以理解为以太坊是区块链里的 Android，它是一个开发平台，让我们就可以像基于 Android Framework 一样基于区块链技术写应用。</p>\n</blockquote>\n<p>在没有以太坊之前，写区块链应用是这样的：拷贝一份比特币代码，然后去改底层代码如加密算法，共识机制，网络协议等等（很多山寨币就是这样，改改就出来一个新币）。</p>\n<p>以太坊平台对底层区块链技术进行了封装，让区块链应用开发者可以直接基于以太坊平台进行开发，只要专注于开发应用本身逻辑的智能合约，这样就可以大大降低开发难度。</p>\n<blockquote>\n<p>目前围绕以太坊已经形成了一个最为完善的开发生态：有很多经过测试和验证的开发库、有完善的<a href=\"https://learnblockchain.cn/docs/\">开发者文档</a>（中文的也很多）及开发测试工具。</p>\n</blockquote>\n<h2 id=\"智能合约\"><a href=\"#智能合约\" class=\"headerlink\" title=\"智能合约\"></a>智能合约</h2><p>那么什么是智能合约呢？<strong>以太坊网络上运行程序就称之为智能合约</strong>， 它和其他的程序一样，也是代码和数据 (状态) 的集合。</p>\n<p>智能合约（Smart Contract）和人工智能（Artificial Intelligence ）的智能没有关系，智能合约最早尼克萨博在 95 年就提出，它的概念很简单，就是将法律条文写成可执行代码。让法律条文的执行中立化，这个理念和区块链上的程序可以不被篡改、不被干预（只有有人触发交易，它将自动执行）的执行不谋而合，因此区块链引入了这个概念。</p>\n<p>在前面介绍<a href=\"https://learnblockchain.cn/2017/11/10/bitcoin-script/\">比特币脚本</a>的时候，我们讲到过比特币的交易也是可以编程的，但是比特币脚本有很多的限制，能够编写的程序也有限，而以太坊程序则是 “图灵完备的”，因此理论上让我们可以来编写可以做任何事情的程序。</p>\n<p>智能合约非常适合对信任、安全和持久性要求较高的应用场景，比如：数字货币、数字资产、投票、保险、金融应用、预测市场、产权所有权管理、物联网、点对点交易等等。<br>目前除数字货币之外，真正落地的应用还不多（就像移动平台刚开始出来一样），相信 1 到 3 年内，各种杀手级会慢慢出现。</p>\n<p>进一步了解智能合约，可以阅读<a href=\"https://learnblockchain.cn/2018/01/04/understanding-smart-contracts/\">完全了解智能合约运行原理</a>。</p>\n<h3 id=\"编程语言：Solidity\"><a href=\"#编程语言：Solidity\" class=\"headerlink\" title=\"编程语言：Solidity\"></a>编程语言：Solidity</h3><p>智能合约现在的主要编程语言是 <a href=\"https://learnblockchain.cn/docs/solidity/\">Solidity</a> 和 Vyper ，<code>Solidity</code> 更为成熟一些，<code>Solidity</code> 合约文件扩展名是 <code>.sol</code> ，虽然是一门新语言，但是但是他和大家常用的现代语言很相似，学期来 以下就是一个简单的计数器智能合约：</p>\n<figure class=\"highlight d\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs d\"><span class=\"hljs-keyword\">pragma</span> solidity &gt;=<span class=\"hljs-number\">0.4</span><span class=\"hljs-number\">.22</span> &lt;<span class=\"hljs-number\">0.6</span><span class=\"hljs-number\">.0</span>;<br> <span class=\"hljs-comment\">// 用contract 关键字定义一个合约</span><br>contract Counter &#123; <br>    <span class=\"hljs-built_in\">uint</span> counter;<br><br>    <span class=\"hljs-built_in\">function</span> count() <span class=\"hljs-keyword\">public</span> &#123;<br>        counter = counter + <span class=\"hljs-number\">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<p>如果上面的合约把 <code>contract</code> 改成 <code>class</code> ，就和其他语言里定义一个类一样了。 <code>Solidity</code> 是一门编译型语言，代码被编译为以太坊虚拟机字节码之后，再部署到以太坊网络。以太坊为我们提供了很好的工具来完成这项工作，比如：<a href=\"https://remix.ethereum.org/\">Remix</a> 就是用来开发、编译、部署智能合约的 IDE，它还是一个基于浏览器的 Web IDE，下面是 Remix IDE 的一个截图。<br><img src=\"https://img.learnblockchain.cn/2019/06/15613593398072.jpg\" alt=\"Remix IDE\"></p>\n<p>Solidity 是静态类型语言，支持继承、库和复杂的用户定义类型等特性。 了解更多 Solidity 知识，可以参考社区翻译的 <a href=\"https://learnblockchain.cn/docs/solidity/\">Solidity 中文文档</a>。</p>\n<h3 id=\"运行环境：EVM\"><a href=\"#运行环境：EVM\" class=\"headerlink\" title=\"运行环境：EVM\"></a>运行环境：EVM</h3><p>EVM（Ethereum Virtual Machine）<a href=\"https://learnblockchain.cn/2019/04/09/easy-evm/\">以太坊虚拟机</a> 用来执行以太坊上的交易，提供智能合约的运行环境。</p>\n<blockquote>\n<p>Solidity 之于 EVM，就像之于跟 JVM 的关系一样，这样大家就容易理解了。<br><a href=\"https://learnblockchain.cn/2019/04/09/easy-evm/\">以太坊虚拟机</a>是一个隔离的环境，外部无法接触到在 EVM 内部运行的代码。</p>\n</blockquote>\n<p>而 EVM 运行在以太坊节点上，当我们把合约部署到以太坊网络上之后，合约就可以在以太坊网络中运行了。</p>\n<h3 id=\"合约的编译\"><a href=\"#合约的编译\" class=\"headerlink\" title=\"合约的编译\"></a>合约的编译</h3><p>以太坊虚拟机上运行的是合约的字节码形式，需要我们在部署之前先对合约进行编译，可以选择 <a href=\"https://remix.ethereum.org/\">Remix</a> 或 solc 编译器。</p>\n<h3 id=\"合约的部署\"><a href=\"#合约的部署\" class=\"headerlink\" title=\"合约的部署\"></a>合约的部署</h3><p>在以太坊上开发应用时，常常要使用到以太坊客户端（钱包）。平时我们在开发中，一般不接触到客户端或钱包的概念，它是什么呢？</p>\n<h4 id=\"以太坊客户端（钱包）\"><a href=\"#以太坊客户端（钱包）\" class=\"headerlink\" title=\"以太坊客户端（钱包）\"></a>以太坊客户端（钱包）</h4><p>以太坊客户端，其实我们可以把它理解为一个开发者工具，它提供账户管理、挖矿、转账、智能合约的部署和执行等等功能。</p>\n<blockquote>\n<p>EVM 是由以太坊客户端提供的</p>\n</blockquote>\n<p><strong>Geth</strong> 是典型的开发以太坊时使用的客户端，基于 Go 语言开发。 <code>Geth</code> 提供了一个交互式命令控制台，通过命令控制台中包含了以太坊的各种功能（API）。Geth 的使用我们之后会有文章介绍，这里大家先有个概念。</p>\n<blockquote>\n<p>\bGeth 控制台和 Chrome 浏览器开发者工具里的面的控制台是类似的，不过 Geth 控制台是跑在终端里。</p>\n</blockquote>\n<h4 id=\"如何部署\"><a href=\"#如何部署\" class=\"headerlink\" title=\"如何部署\"></a>如何部署</h4><p>智能合约的部署是指把合约字节码发布到区块链上，并使用一个特定的地址来标示这个合约，这个地址称为合约账户。</p>\n<blockquote>\n<p>以太坊中有两类账户：</p>\n<ul>\n<li>外部账户<br>该类账户被私钥控制（由人控制），没有关联任何代码。</li>\n<li>合约账户<br>该类账户被它们的合约代码控制且有代码与之关联。</li>\n</ul>\n<blockquote>\n<p>和比特币使用 UTXO 的设计不一样，以太坊使用更为简单的账户概念。<br>两类账户对于 EVM 来说是一样的。</p>\n</blockquote>\n<p>外部账户与合约账户的区别和关系是这样的：一个外部账户可以通过创建和用自己的私钥来对交易进行签名，来发送消息给另一个外部账户或合约账户。<br>在两个外部账户之间传送消息是价值转移的过程。但从外部账户到合约账户的消息会激活合约账户的代码，允许它执行各种动作（比如转移代币，写入内部存储，挖出一个新代币，执行一些运算，创建一个新的合约等等）。<br>只有当外部账户发出指令时，合同账户才会执行相应的操作。</p>\n</blockquote>\n<p>合约部署就是将编译好的合约字节码通过外部账号发送交易的形式部署到以太坊区块链上（由实际矿工出块之后，才真正部署成功）。</p>\n<h3 id=\"运行\"><a href=\"#运行\" class=\"headerlink\" title=\"运行\"></a>运行</h3><p>合约部署之后，当需要调用这个智能合约的方法时只需要向这个合约账户发送消息（交易）即可，通过消息触发后智能合约的代码就会在 EVM 中执行了。</p>\n<h2 id=\"Gas\"><a href=\"#Gas\" class=\"headerlink\" title=\"Gas\"></a>Gas</h2><p>和云计算相似，占用区块链的资源（不管是简单的转账交易，还是合约的部署和执行）同样需要付出相应的费用（天下没有免费的午餐对不对！）。</p>\n<p>以太坊上用 Gas 机制来计费，Gas 也可以认为是一个工作量单位，智能合约越复杂（计算步骤的数量和类型，占用的内存等），用来完成运行就需要越多 Gas。</p>\n<p>任何特定的合约所需的运行合约的 Gas 数量是固定的，由合约的复杂度决定。<br>而 Gas 价格由运行合约的人在提交运行合约请求的时候设定，以确定他愿意为这次交易愿意付出的费用：Gas 价格（用以太币计价） * Gas 数量。</p>\n<p>Gas 的目的是限制执行交易所需的工作量，同时为执行支付费用。当 EVM 执行交易时，Gas 将按照特定规则被逐渐消耗，无论执行到什么位置，一旦 Gas 被耗尽，将会触发异常。当前调用帧所做的所有状态修改都将被回滚， 如果执行结束还有 Gas 剩余，这些 Gas 将被返还给发送账户。</p>\n<blockquote>\n<p>如果没有这个限制，就会有人写出无法停止（如：死循环）的合约来阻塞网络。</p>\n</blockquote>\n<p>因此实际上（把前面的内容串起来），我们需要一个有以太币余额的外部账户，来发起一个交易（普通交易或部署、运行一个合约），运行时，矿工收取相应的工作量费用。</p>\n<h2 id=\"以太坊网络\"><a href=\"#以太坊网络\" class=\"headerlink\" title=\"以太坊网络\"></a>以太坊网络</h2><p>有些着急的同学要问了，没有以太币，要怎么进行智能合约的开发？可以选择以下方式：</p>\n<h3 id=\"选择以太坊官网测试网络-Testnet\"><a href=\"#选择以太坊官网测试网络-Testnet\" class=\"headerlink\" title=\"选择以太坊官网测试网络 Testnet\"></a>选择以太坊官网测试网络 Testnet</h3><p>测试网络中，我们可以很容易获得免费的以太币，缺点是需要发很长时间初始化节点。</p>\n<h3 id=\"使用私有链\"><a href=\"#使用私有链\" class=\"headerlink\" title=\"使用私有链\"></a>使用私有链</h3><p>创建自己的以太币私有测试网络，通常也称为私有链，我们可以用它来作为一个测试环境来开发、调试和测试智能合约。<br>通过上面提到的 Geth 很容易就可以创建一个属于自己的测试网络，以太币想挖多少挖多少，也免去了同步正式网络的整个区块链数据。</p>\n<h3 id=\"使用开发者网络-模式\"><a href=\"#使用开发者网络-模式\" class=\"headerlink\" title=\"使用开发者网络 (模式)\"></a>使用开发者网络 (模式)</h3><p>相比私有链，开发者网络 (模式) 下，会自动分配一个有大量余额的开发者账户给我们使用。</p>\n<h3 id=\"使用模拟环境\"><a href=\"#使用模拟环境\" class=\"headerlink\" title=\"使用模拟环境\"></a>使用模拟环境</h3><p>另一个创建测试网络的方法是使用 Ganache，Ganache 是普通的应用程序，它在本地使用内存模拟的一个以太坊区块链环境，对于开发调试来说，更方便快捷。而且 Ganache 会在启动时帮我们创建 10 个存有资金的测试账户。<br>进行合约开发时，可以在 Ganache 中测试通过后，再部署到 Geth 节点中去。</p>\n<h2 id=\"DApp：去中心化的应用程序\"><a href=\"#DApp：去中心化的应用程序\" class=\"headerlink\" title=\"DApp：去中心化的应用程序\"></a>DApp：去中心化的应用程序</h2><p>以太坊社区把基于智能合约的应用称为去中心化的应用程序 (Decentralized App)。如果我们把区块链理解为一个不可篡改的数据库，智能合约理解为和数据库打交道的程序，那就很容易理解 DApp 了，一个 DApp 不单单有智能合约（相当于应用的后台），比如还需要有一个友好的用户界面。</p>\n<h3 id=\"Truffle\"><a href=\"#Truffle\" class=\"headerlink\" title=\"Truffle\"></a>Truffle</h3><p><a href=\"https://learnblockchain.cn/docs/truffle/\">Truffle</a> 是一个非常流行 DApp 开发框架，他可以帮我们处理掉大量无关紧要的小事情，让我们可以迅速开始写代码 - 编译 - 部署 - 测试 - 打包 DApp 这个流程。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>我们现在来总结一下，以太坊是平台，它让我们方便的使用区块链技术开发去中心化的应用，在这个应用中，使用 Solidity 来编写和区块链交互的智能合约，合约编写好后之后，我们需要用以太坊客户端用一个有余额的账户去部署及运行合约（使用 <a href=\"https://learnblockchain.cn/docs/truffle/\">Truffle</a> 可以更好的帮助我们做这些事情了）。为了开发方便，我们可以用 Geth 或 Ganache 来搭建一个测试网络。</p>\n<p>注：本文中为了方便大家理解，对一些概念做了类比，有些严格来不是准确，不过我也认为对于初学者，也没有必要把每一个概念掌握的很细致和准确，学习是一个逐步深入的过程，很多时候我们会发现，过一段后，我们会对同一个东西有不一样的理解。</p>\n"},{"title":"智能合约雏形","date":"2019-11-02T02:30:33.000Z","layout":"config.default_layout","_content":"大家都有转过账，每笔交易是这样的：张三账上减￥200，李四账上加￥200。\n在比特币区块链中，交易不是这么简单，\b\b交易实际是通过脚本来完成，以承载更多的功能个，这也是为什么比特币被称为是一种 “可编程的货币”。\n本文就来分析一下交易是如何实现可编程的。\n\n\n\n## 未花费的交易输出 (UTXO)\n\n先引入一个概念：未花费的交易输出 ——UTXO（Unspent Transaction Output）\n\n其实比特币的交易都是基于 UTXO 上的，即交易的输入是之前交易未花费的输出，这笔交易的输出可以被当做下一笔新交易的输入。\n\n> 挖矿奖励属于一个特殊的交易（称为 coinbase 交易），可以没有输入。\n> UTXO 是交易的基本单元，不能再分割。\n> 在比特币没有余额概念，只有分散到区块链里的 UTXO\n\n随着钱从一个地址被移动到另一个地址的同时形成了一条所有权链，像这样：\n![own_chain](https://img.learnblockchain.cn/2017/own_chain.jpeg!wl)\n\n## 比特币脚本\n\n比特币交易是首先要提供一个用于解锁 UTXO（用私钥去匹配锁定脚本）的脚本（常称为解锁脚本：Signature script)，这也叫交易输入，\n交易的输出则是指向一个脚本（称为锁定脚本：PubKey script），这个脚本表达了：谁的签名（签名是常见形式，\b并不一定必须是签名）能匹配这个输出地址，钱就支付给谁。\n\n每一个比特币节点会通过同时执行这解锁和锁定脚本（不是当前的锁定脚本，是指上一个交易的锁定脚本）来验证一笔交易，脚本组合结果为真，则为有效交易。\n\n> 当解锁版脚本与锁定版脚本的设定条件相匹配时，执行组合有效脚本时才会显示结果为真\n\n如最为常见类型的比特币交易脚本（支付到公钥哈希：P2PKH（Pay-to-Public-Key-Hash））组合是这样：\n![script](https://img.learnblockchain.cn/2017/script.jpeg!wl)\n\n### 常见交易脚本验证过程\n\n比特币交易脚本语言是一种基于逆波兰表示法的基于栈的执行语言（不知道逆波兰和栈的同学去翻大学数据结构课本，你也可跳过这个部分）。\n\n> 比特币脚本语言包含基本算数计算、基本逻辑 (比如 if…then)、报错以及返回结果和一些加密指令，不支持循环。想了解更多语言细节可参考: [比特币脚本](http://www.8btc.com/bitcoin_scripts)\n\n脚本语言通过从左至右地处理每个项目的方式执行脚本。\n\n下面用两个图说明下常见类型的比特币交易脚本验证执行过程：\n![script_run1](https://img.learnblockchain.cn/2017/script_run1.jpeg!wl)\n上图为解锁脚本运行过程（主要是入栈）\n![script_run2](https://img.learnblockchain.cn/2017/script_run2.jpeg!wl)\n上图为锁定脚本运行过程（主要是出栈），最后的结果为真，说明交易有效。\n\n## 交易分析\n\n实际上比特币的交易被设计为可以纳入多个输入和输出。\n\n### 交易结构\n\n我们来看看完整的交易结构，\n![img](https://img.learnblockchain.cn/2017/tx_struce.jpeg!wl)\n\n> 交易的锁定时间定义了能被加到区块链里的最早的交易时间。在大多数交易里，它被设置成 0，用来表示立即执行。\n> 如果锁定时间不是 0 并且小于 5 亿，就被视为区块高度，意指在这个指定的区块高度之前，该交易不会被包含在区块链里。\n> 如果锁定时间大于 5 亿，则它被当作是一个 Unix 纪元时间戳（从 1970 年 1 月 1 日以来的秒数），并且在这个指定时间之前，该交易不会被包含在区块链里。\n\n交易的数据结构没有交易费的字段，交易费通过所有输入的总和，以及所有输出的总和之间的差来表示，即：\n\n> 交易费 = 求和（所有输入） - 求和（所有输出）\n\n### 交易输入结构\n\n刚刚我们提过输入需要提供一个解锁脚本，现在来看看一个交易的输入结构：\n![img](https://img.learnblockchain.cn/2017/tx_input_struce.jpeg!wl)\n\n我们结合整个交易的结构里看输入结构就是这样子：\n![img](https://img.learnblockchain.cn/2017/tx_input_overview.jpeg!wl)\n\n### 交易输出结构\n\n刚刚我们提过输出是指向一个解锁脚本，具体交易的输出结构为：\n![img](https://img.learnblockchain.cn/2017/tx_output_struce.jpeg!wl)\n我们结合整个交易的结构里看输出结构就是这样子：\n![img](https://img.learnblockchain.cn/2017/tx_output_overview.jpeg!wl)\n\n### 交易哈希计算\n\n在[比特币区块结构 Merkle 树及简单支付验证分析](https://xiaozhuanlan.com/topic/1402935768) 讲到区块结构，区块结构包含多个交易的哈希。\n那么交易哈希是怎么计算的呢？\n\n1. 交易结构各字段序列化为字节数组\n2. 把字节数组拼接为支付串\n3. 对支付串计算两次 SHA256 得到交易 hash\n\n了解详情可进一步参考[如何计算交易 Hash?](https://bitcoin.stackexchange.com/questions/2859/how-are-transaction-hashes-calculated) 及[如何创建 Hash?](https://bitcointalk.org/index.php?topic=54451.msg649253#msg649253)\n\n现在是不是对完整的交易到区块有了更清晰的认识。\n\n## 智能合约雏形 - 应用场景说明\n\n由于交易是通过脚本来实现，脚本语言可以表达出无数的条件变种。\n\n比特币的脚本目前常用的主要分为两种，一种是常见的 P2PKH（支付给公钥哈希），另一种是 P2SH（Pay-to-Script-Hash 支付脚本哈希）。\nP2SH 支付中，锁定脚本被密码学哈希所取代，当一笔交易试图支付 UTXO 时，要解锁支付脚本，它必须含有与哈希相匹配的脚本。\n\n这里不展开技术细节，下面说明一些应用场景，以便大家有更直观的认识。\n\n- 多重签名应用\n  合伙经营中，如只有一半以上的的股东同意签名就可以进行支付，可为公司治理提供管控便利，同时也能有效防范盗窃、挪用和遗失。\n\n  用于担保和争端调解，一个买家想和他不认识或不信任的某人交易，在一般情况交易正常进行时，买家不想任何第三方参与。那交易双方可以发起支付，但如果交易出现问题时，那第三方就可以根据裁定，使用自己的签名和裁定认可的一方共同签名来兑现这笔交易。\n\n- 保证合同\n  保证合同是建造公众商品时的集资办法，公众商品是指一旦建成，任何人都可以免费享受到好处。标准的例子是灯塔，所有人都认同应该建造一个，但是对于个人航海者来说灯塔太贵了，灯塔同时也会方便其他航海者。\n  一个解决方案是向所有人集资，只有当筹集的资金超过所需的建造成本时，每个人才真正付钱，如果集资款不足，则谁都不用付钱。\n\n- 依靠预言\n  假如老人想让他孙子继承遗产，继承时间是在他死后或者在孙子年满 18 岁时（也是一个带锁定时间交易），无论哪个条件先满足，他的孙子都可以得到遗产。\n  因为比特币节点可依靠预言对死亡条件进行判断，预言是指具有密钥对的服务器，当用户自定义的表达式被证明是真的，它能按照要求对交易签名。","source":"_posts/block_chain/智能合约雏形.md","raw":"---\ntitle: 智能合约雏形\ndate: 2019-11-02 10:30:33\nlayout: config.default_layout\ncategories: 'block chain'\ntags:\n- 区块链\n- 比特币\n- 智能合约\n---\n大家都有转过账，每笔交易是这样的：张三账上减￥200，李四账上加￥200。\n在比特币区块链中，交易不是这么简单，\b\b交易实际是通过脚本来完成，以承载更多的功能个，这也是为什么比特币被称为是一种 “可编程的货币”。\n本文就来分析一下交易是如何实现可编程的。\n\n\n\n## 未花费的交易输出 (UTXO)\n\n先引入一个概念：未花费的交易输出 ——UTXO（Unspent Transaction Output）\n\n其实比特币的交易都是基于 UTXO 上的，即交易的输入是之前交易未花费的输出，这笔交易的输出可以被当做下一笔新交易的输入。\n\n> 挖矿奖励属于一个特殊的交易（称为 coinbase 交易），可以没有输入。\n> UTXO 是交易的基本单元，不能再分割。\n> 在比特币没有余额概念，只有分散到区块链里的 UTXO\n\n随着钱从一个地址被移动到另一个地址的同时形成了一条所有权链，像这样：\n![own_chain](https://img.learnblockchain.cn/2017/own_chain.jpeg!wl)\n\n## 比特币脚本\n\n比特币交易是首先要提供一个用于解锁 UTXO（用私钥去匹配锁定脚本）的脚本（常称为解锁脚本：Signature script)，这也叫交易输入，\n交易的输出则是指向一个脚本（称为锁定脚本：PubKey script），这个脚本表达了：谁的签名（签名是常见形式，\b并不一定必须是签名）能匹配这个输出地址，钱就支付给谁。\n\n每一个比特币节点会通过同时执行这解锁和锁定脚本（不是当前的锁定脚本，是指上一个交易的锁定脚本）来验证一笔交易，脚本组合结果为真，则为有效交易。\n\n> 当解锁版脚本与锁定版脚本的设定条件相匹配时，执行组合有效脚本时才会显示结果为真\n\n如最为常见类型的比特币交易脚本（支付到公钥哈希：P2PKH（Pay-to-Public-Key-Hash））组合是这样：\n![script](https://img.learnblockchain.cn/2017/script.jpeg!wl)\n\n### 常见交易脚本验证过程\n\n比特币交易脚本语言是一种基于逆波兰表示法的基于栈的执行语言（不知道逆波兰和栈的同学去翻大学数据结构课本，你也可跳过这个部分）。\n\n> 比特币脚本语言包含基本算数计算、基本逻辑 (比如 if…then)、报错以及返回结果和一些加密指令，不支持循环。想了解更多语言细节可参考: [比特币脚本](http://www.8btc.com/bitcoin_scripts)\n\n脚本语言通过从左至右地处理每个项目的方式执行脚本。\n\n下面用两个图说明下常见类型的比特币交易脚本验证执行过程：\n![script_run1](https://img.learnblockchain.cn/2017/script_run1.jpeg!wl)\n上图为解锁脚本运行过程（主要是入栈）\n![script_run2](https://img.learnblockchain.cn/2017/script_run2.jpeg!wl)\n上图为锁定脚本运行过程（主要是出栈），最后的结果为真，说明交易有效。\n\n## 交易分析\n\n实际上比特币的交易被设计为可以纳入多个输入和输出。\n\n### 交易结构\n\n我们来看看完整的交易结构，\n![img](https://img.learnblockchain.cn/2017/tx_struce.jpeg!wl)\n\n> 交易的锁定时间定义了能被加到区块链里的最早的交易时间。在大多数交易里，它被设置成 0，用来表示立即执行。\n> 如果锁定时间不是 0 并且小于 5 亿，就被视为区块高度，意指在这个指定的区块高度之前，该交易不会被包含在区块链里。\n> 如果锁定时间大于 5 亿，则它被当作是一个 Unix 纪元时间戳（从 1970 年 1 月 1 日以来的秒数），并且在这个指定时间之前，该交易不会被包含在区块链里。\n\n交易的数据结构没有交易费的字段，交易费通过所有输入的总和，以及所有输出的总和之间的差来表示，即：\n\n> 交易费 = 求和（所有输入） - 求和（所有输出）\n\n### 交易输入结构\n\n刚刚我们提过输入需要提供一个解锁脚本，现在来看看一个交易的输入结构：\n![img](https://img.learnblockchain.cn/2017/tx_input_struce.jpeg!wl)\n\n我们结合整个交易的结构里看输入结构就是这样子：\n![img](https://img.learnblockchain.cn/2017/tx_input_overview.jpeg!wl)\n\n### 交易输出结构\n\n刚刚我们提过输出是指向一个解锁脚本，具体交易的输出结构为：\n![img](https://img.learnblockchain.cn/2017/tx_output_struce.jpeg!wl)\n我们结合整个交易的结构里看输出结构就是这样子：\n![img](https://img.learnblockchain.cn/2017/tx_output_overview.jpeg!wl)\n\n### 交易哈希计算\n\n在[比特币区块结构 Merkle 树及简单支付验证分析](https://xiaozhuanlan.com/topic/1402935768) 讲到区块结构，区块结构包含多个交易的哈希。\n那么交易哈希是怎么计算的呢？\n\n1. 交易结构各字段序列化为字节数组\n2. 把字节数组拼接为支付串\n3. 对支付串计算两次 SHA256 得到交易 hash\n\n了解详情可进一步参考[如何计算交易 Hash?](https://bitcoin.stackexchange.com/questions/2859/how-are-transaction-hashes-calculated) 及[如何创建 Hash?](https://bitcointalk.org/index.php?topic=54451.msg649253#msg649253)\n\n现在是不是对完整的交易到区块有了更清晰的认识。\n\n## 智能合约雏形 - 应用场景说明\n\n由于交易是通过脚本来实现，脚本语言可以表达出无数的条件变种。\n\n比特币的脚本目前常用的主要分为两种，一种是常见的 P2PKH（支付给公钥哈希），另一种是 P2SH（Pay-to-Script-Hash 支付脚本哈希）。\nP2SH 支付中，锁定脚本被密码学哈希所取代，当一笔交易试图支付 UTXO 时，要解锁支付脚本，它必须含有与哈希相匹配的脚本。\n\n这里不展开技术细节，下面说明一些应用场景，以便大家有更直观的认识。\n\n- 多重签名应用\n  合伙经营中，如只有一半以上的的股东同意签名就可以进行支付，可为公司治理提供管控便利，同时也能有效防范盗窃、挪用和遗失。\n\n  用于担保和争端调解，一个买家想和他不认识或不信任的某人交易，在一般情况交易正常进行时，买家不想任何第三方参与。那交易双方可以发起支付，但如果交易出现问题时，那第三方就可以根据裁定，使用自己的签名和裁定认可的一方共同签名来兑现这笔交易。\n\n- 保证合同\n  保证合同是建造公众商品时的集资办法，公众商品是指一旦建成，任何人都可以免费享受到好处。标准的例子是灯塔，所有人都认同应该建造一个，但是对于个人航海者来说灯塔太贵了，灯塔同时也会方便其他航海者。\n  一个解决方案是向所有人集资，只有当筹集的资金超过所需的建造成本时，每个人才真正付钱，如果集资款不足，则谁都不用付钱。\n\n- 依靠预言\n  假如老人想让他孙子继承遗产，继承时间是在他死后或者在孙子年满 18 岁时（也是一个带锁定时间交易），无论哪个条件先满足，他的孙子都可以得到遗产。\n  因为比特币节点可依靠预言对死亡条件进行判断，预言是指具有密钥对的服务器，当用户自定义的表达式被证明是真的，它能按照要求对交易签名。","slug":"block_chain/智能合约雏形","published":1,"updated":"2021-07-04T07:10:21.859Z","_id":"ckqoti0b200071xmz8eqdbmdh","comments":1,"photos":[],"link":"","content":"<p>大家都有转过账，每笔交易是这样的：张三账上减￥200，李四账上加￥200。<br>在比特币区块链中，交易不是这么简单，\b\b交易实际是通过脚本来完成，以承载更多的功能个，这也是为什么比特币被称为是一种 “可编程的货币”。<br>本文就来分析一下交易是如何实现可编程的。</p>\n<h2 id=\"未花费的交易输出-UTXO\"><a href=\"#未花费的交易输出-UTXO\" class=\"headerlink\" title=\"未花费的交易输出 (UTXO)\"></a>未花费的交易输出 (UTXO)</h2><p>先引入一个概念：未花费的交易输出 ——UTXO（Unspent Transaction Output）</p>\n<p>其实比特币的交易都是基于 UTXO 上的，即交易的输入是之前交易未花费的输出，这笔交易的输出可以被当做下一笔新交易的输入。</p>\n<blockquote>\n<p>挖矿奖励属于一个特殊的交易（称为 coinbase 交易），可以没有输入。<br>UTXO 是交易的基本单元，不能再分割。<br>在比特币没有余额概念，只有分散到区块链里的 UTXO</p>\n</blockquote>\n<p>随着钱从一个地址被移动到另一个地址的同时形成了一条所有权链，像这样：<br><img src=\"https://img.learnblockchain.cn/2017/own_chain.jpeg!wl\" alt=\"own_chain\"></p>\n<h2 id=\"比特币脚本\"><a href=\"#比特币脚本\" class=\"headerlink\" title=\"比特币脚本\"></a>比特币脚本</h2><p>比特币交易是首先要提供一个用于解锁 UTXO（用私钥去匹配锁定脚本）的脚本（常称为解锁脚本：Signature script)，这也叫交易输入，<br>交易的输出则是指向一个脚本（称为锁定脚本：PubKey script），这个脚本表达了：谁的签名（签名是常见形式，\b并不一定必须是签名）能匹配这个输出地址，钱就支付给谁。</p>\n<p>每一个比特币节点会通过同时执行这解锁和锁定脚本（不是当前的锁定脚本，是指上一个交易的锁定脚本）来验证一笔交易，脚本组合结果为真，则为有效交易。</p>\n<blockquote>\n<p>当解锁版脚本与锁定版脚本的设定条件相匹配时，执行组合有效脚本时才会显示结果为真</p>\n</blockquote>\n<p>如最为常见类型的比特币交易脚本（支付到公钥哈希：P2PKH（Pay-to-Public-Key-Hash））组合是这样：<br><img src=\"https://img.learnblockchain.cn/2017/script.jpeg!wl\" alt=\"script\"></p>\n<h3 id=\"常见交易脚本验证过程\"><a href=\"#常见交易脚本验证过程\" class=\"headerlink\" title=\"常见交易脚本验证过程\"></a>常见交易脚本验证过程</h3><p>比特币交易脚本语言是一种基于逆波兰表示法的基于栈的执行语言（不知道逆波兰和栈的同学去翻大学数据结构课本，你也可跳过这个部分）。</p>\n<blockquote>\n<p>比特币脚本语言包含基本算数计算、基本逻辑 (比如 if…then)、报错以及返回结果和一些加密指令，不支持循环。想了解更多语言细节可参考: <a href=\"http://www.8btc.com/bitcoin_scripts\">比特币脚本</a></p>\n</blockquote>\n<p>脚本语言通过从左至右地处理每个项目的方式执行脚本。</p>\n<p>下面用两个图说明下常见类型的比特币交易脚本验证执行过程：<br><img src=\"https://img.learnblockchain.cn/2017/script_run1.jpeg!wl\" alt=\"script_run1\"><br>上图为解锁脚本运行过程（主要是入栈）<br><img src=\"https://img.learnblockchain.cn/2017/script_run2.jpeg!wl\" alt=\"script_run2\"><br>上图为锁定脚本运行过程（主要是出栈），最后的结果为真，说明交易有效。</p>\n<h2 id=\"交易分析\"><a href=\"#交易分析\" class=\"headerlink\" title=\"交易分析\"></a>交易分析</h2><p>实际上比特币的交易被设计为可以纳入多个输入和输出。</p>\n<h3 id=\"交易结构\"><a href=\"#交易结构\" class=\"headerlink\" title=\"交易结构\"></a>交易结构</h3><p>我们来看看完整的交易结构，<br><img src=\"https://img.learnblockchain.cn/2017/tx_struce.jpeg!wl\" alt=\"img\"></p>\n<blockquote>\n<p>交易的锁定时间定义了能被加到区块链里的最早的交易时间。在大多数交易里，它被设置成 0，用来表示立即执行。<br>如果锁定时间不是 0 并且小于 5 亿，就被视为区块高度，意指在这个指定的区块高度之前，该交易不会被包含在区块链里。<br>如果锁定时间大于 5 亿，则它被当作是一个 Unix 纪元时间戳（从 1970 年 1 月 1 日以来的秒数），并且在这个指定时间之前，该交易不会被包含在区块链里。</p>\n</blockquote>\n<p>交易的数据结构没有交易费的字段，交易费通过所有输入的总和，以及所有输出的总和之间的差来表示，即：</p>\n<blockquote>\n<p>交易费 = 求和（所有输入） - 求和（所有输出）</p>\n</blockquote>\n<h3 id=\"交易输入结构\"><a href=\"#交易输入结构\" class=\"headerlink\" title=\"交易输入结构\"></a>交易输入结构</h3><p>刚刚我们提过输入需要提供一个解锁脚本，现在来看看一个交易的输入结构：<br><img src=\"https://img.learnblockchain.cn/2017/tx_input_struce.jpeg!wl\" alt=\"img\"></p>\n<p>我们结合整个交易的结构里看输入结构就是这样子：<br><img src=\"https://img.learnblockchain.cn/2017/tx_input_overview.jpeg!wl\" alt=\"img\"></p>\n<h3 id=\"交易输出结构\"><a href=\"#交易输出结构\" class=\"headerlink\" title=\"交易输出结构\"></a>交易输出结构</h3><p>刚刚我们提过输出是指向一个解锁脚本，具体交易的输出结构为：<br><img src=\"https://img.learnblockchain.cn/2017/tx_output_struce.jpeg!wl\" alt=\"img\"><br>我们结合整个交易的结构里看输出结构就是这样子：<br><img src=\"https://img.learnblockchain.cn/2017/tx_output_overview.jpeg!wl\" alt=\"img\"></p>\n<h3 id=\"交易哈希计算\"><a href=\"#交易哈希计算\" class=\"headerlink\" title=\"交易哈希计算\"></a>交易哈希计算</h3><p>在<a href=\"https://xiaozhuanlan.com/topic/1402935768\">比特币区块结构 Merkle 树及简单支付验证分析</a> 讲到区块结构，区块结构包含多个交易的哈希。<br>那么交易哈希是怎么计算的呢？</p>\n<ol>\n<li>交易结构各字段序列化为字节数组</li>\n<li>把字节数组拼接为支付串</li>\n<li>对支付串计算两次 SHA256 得到交易 hash</li>\n</ol>\n<p>了解详情可进一步参考<a href=\"https://bitcoin.stackexchange.com/questions/2859/how-are-transaction-hashes-calculated\">如何计算交易 Hash?</a> 及<a href=\"https://bitcointalk.org/index.php?topic=54451.msg649253#msg649253\">如何创建 Hash?</a></p>\n<p>现在是不是对完整的交易到区块有了更清晰的认识。</p>\n<h2 id=\"智能合约雏形-应用场景说明\"><a href=\"#智能合约雏形-应用场景说明\" class=\"headerlink\" title=\"智能合约雏形 - 应用场景说明\"></a>智能合约雏形 - 应用场景说明</h2><p>由于交易是通过脚本来实现，脚本语言可以表达出无数的条件变种。</p>\n<p>比特币的脚本目前常用的主要分为两种，一种是常见的 P2PKH（支付给公钥哈希），另一种是 P2SH（Pay-to-Script-Hash 支付脚本哈希）。<br>P2SH 支付中，锁定脚本被密码学哈希所取代，当一笔交易试图支付 UTXO 时，要解锁支付脚本，它必须含有与哈希相匹配的脚本。</p>\n<p>这里不展开技术细节，下面说明一些应用场景，以便大家有更直观的认识。</p>\n<ul>\n<li><p>多重签名应用<br>合伙经营中，如只有一半以上的的股东同意签名就可以进行支付，可为公司治理提供管控便利，同时也能有效防范盗窃、挪用和遗失。</p>\n<p>用于担保和争端调解，一个买家想和他不认识或不信任的某人交易，在一般情况交易正常进行时，买家不想任何第三方参与。那交易双方可以发起支付，但如果交易出现问题时，那第三方就可以根据裁定，使用自己的签名和裁定认可的一方共同签名来兑现这笔交易。</p>\n</li>\n<li><p>保证合同<br>保证合同是建造公众商品时的集资办法，公众商品是指一旦建成，任何人都可以免费享受到好处。标准的例子是灯塔，所有人都认同应该建造一个，但是对于个人航海者来说灯塔太贵了，灯塔同时也会方便其他航海者。<br>一个解决方案是向所有人集资，只有当筹集的资金超过所需的建造成本时，每个人才真正付钱，如果集资款不足，则谁都不用付钱。</p>\n</li>\n<li><p>依靠预言<br>假如老人想让他孙子继承遗产，继承时间是在他死后或者在孙子年满 18 岁时（也是一个带锁定时间交易），无论哪个条件先满足，他的孙子都可以得到遗产。<br>因为比特币节点可依靠预言对死亡条件进行判断，预言是指具有密钥对的服务器，当用户自定义的表达式被证明是真的，它能按照要求对交易签名。</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>大家都有转过账，每笔交易是这样的：张三账上减￥200，李四账上加￥200。<br>在比特币区块链中，交易不是这么简单，\b\b交易实际是通过脚本来完成，以承载更多的功能个，这也是为什么比特币被称为是一种 “可编程的货币”。<br>本文就来分析一下交易是如何实现可编程的。</p>\n<h2 id=\"未花费的交易输出-UTXO\"><a href=\"#未花费的交易输出-UTXO\" class=\"headerlink\" title=\"未花费的交易输出 (UTXO)\"></a>未花费的交易输出 (UTXO)</h2><p>先引入一个概念：未花费的交易输出 ——UTXO（Unspent Transaction Output）</p>\n<p>其实比特币的交易都是基于 UTXO 上的，即交易的输入是之前交易未花费的输出，这笔交易的输出可以被当做下一笔新交易的输入。</p>\n<blockquote>\n<p>挖矿奖励属于一个特殊的交易（称为 coinbase 交易），可以没有输入。<br>UTXO 是交易的基本单元，不能再分割。<br>在比特币没有余额概念，只有分散到区块链里的 UTXO</p>\n</blockquote>\n<p>随着钱从一个地址被移动到另一个地址的同时形成了一条所有权链，像这样：<br><img src=\"https://img.learnblockchain.cn/2017/own_chain.jpeg!wl\" alt=\"own_chain\"></p>\n<h2 id=\"比特币脚本\"><a href=\"#比特币脚本\" class=\"headerlink\" title=\"比特币脚本\"></a>比特币脚本</h2><p>比特币交易是首先要提供一个用于解锁 UTXO（用私钥去匹配锁定脚本）的脚本（常称为解锁脚本：Signature script)，这也叫交易输入，<br>交易的输出则是指向一个脚本（称为锁定脚本：PubKey script），这个脚本表达了：谁的签名（签名是常见形式，\b并不一定必须是签名）能匹配这个输出地址，钱就支付给谁。</p>\n<p>每一个比特币节点会通过同时执行这解锁和锁定脚本（不是当前的锁定脚本，是指上一个交易的锁定脚本）来验证一笔交易，脚本组合结果为真，则为有效交易。</p>\n<blockquote>\n<p>当解锁版脚本与锁定版脚本的设定条件相匹配时，执行组合有效脚本时才会显示结果为真</p>\n</blockquote>\n<p>如最为常见类型的比特币交易脚本（支付到公钥哈希：P2PKH（Pay-to-Public-Key-Hash））组合是这样：<br><img src=\"https://img.learnblockchain.cn/2017/script.jpeg!wl\" alt=\"script\"></p>\n<h3 id=\"常见交易脚本验证过程\"><a href=\"#常见交易脚本验证过程\" class=\"headerlink\" title=\"常见交易脚本验证过程\"></a>常见交易脚本验证过程</h3><p>比特币交易脚本语言是一种基于逆波兰表示法的基于栈的执行语言（不知道逆波兰和栈的同学去翻大学数据结构课本，你也可跳过这个部分）。</p>\n<blockquote>\n<p>比特币脚本语言包含基本算数计算、基本逻辑 (比如 if…then)、报错以及返回结果和一些加密指令，不支持循环。想了解更多语言细节可参考: <a href=\"http://www.8btc.com/bitcoin_scripts\">比特币脚本</a></p>\n</blockquote>\n<p>脚本语言通过从左至右地处理每个项目的方式执行脚本。</p>\n<p>下面用两个图说明下常见类型的比特币交易脚本验证执行过程：<br><img src=\"https://img.learnblockchain.cn/2017/script_run1.jpeg!wl\" alt=\"script_run1\"><br>上图为解锁脚本运行过程（主要是入栈）<br><img src=\"https://img.learnblockchain.cn/2017/script_run2.jpeg!wl\" alt=\"script_run2\"><br>上图为锁定脚本运行过程（主要是出栈），最后的结果为真，说明交易有效。</p>\n<h2 id=\"交易分析\"><a href=\"#交易分析\" class=\"headerlink\" title=\"交易分析\"></a>交易分析</h2><p>实际上比特币的交易被设计为可以纳入多个输入和输出。</p>\n<h3 id=\"交易结构\"><a href=\"#交易结构\" class=\"headerlink\" title=\"交易结构\"></a>交易结构</h3><p>我们来看看完整的交易结构，<br><img src=\"https://img.learnblockchain.cn/2017/tx_struce.jpeg!wl\" alt=\"img\"></p>\n<blockquote>\n<p>交易的锁定时间定义了能被加到区块链里的最早的交易时间。在大多数交易里，它被设置成 0，用来表示立即执行。<br>如果锁定时间不是 0 并且小于 5 亿，就被视为区块高度，意指在这个指定的区块高度之前，该交易不会被包含在区块链里。<br>如果锁定时间大于 5 亿，则它被当作是一个 Unix 纪元时间戳（从 1970 年 1 月 1 日以来的秒数），并且在这个指定时间之前，该交易不会被包含在区块链里。</p>\n</blockquote>\n<p>交易的数据结构没有交易费的字段，交易费通过所有输入的总和，以及所有输出的总和之间的差来表示，即：</p>\n<blockquote>\n<p>交易费 = 求和（所有输入） - 求和（所有输出）</p>\n</blockquote>\n<h3 id=\"交易输入结构\"><a href=\"#交易输入结构\" class=\"headerlink\" title=\"交易输入结构\"></a>交易输入结构</h3><p>刚刚我们提过输入需要提供一个解锁脚本，现在来看看一个交易的输入结构：<br><img src=\"https://img.learnblockchain.cn/2017/tx_input_struce.jpeg!wl\" alt=\"img\"></p>\n<p>我们结合整个交易的结构里看输入结构就是这样子：<br><img src=\"https://img.learnblockchain.cn/2017/tx_input_overview.jpeg!wl\" alt=\"img\"></p>\n<h3 id=\"交易输出结构\"><a href=\"#交易输出结构\" class=\"headerlink\" title=\"交易输出结构\"></a>交易输出结构</h3><p>刚刚我们提过输出是指向一个解锁脚本，具体交易的输出结构为：<br><img src=\"https://img.learnblockchain.cn/2017/tx_output_struce.jpeg!wl\" alt=\"img\"><br>我们结合整个交易的结构里看输出结构就是这样子：<br><img src=\"https://img.learnblockchain.cn/2017/tx_output_overview.jpeg!wl\" alt=\"img\"></p>\n<h3 id=\"交易哈希计算\"><a href=\"#交易哈希计算\" class=\"headerlink\" title=\"交易哈希计算\"></a>交易哈希计算</h3><p>在<a href=\"https://xiaozhuanlan.com/topic/1402935768\">比特币区块结构 Merkle 树及简单支付验证分析</a> 讲到区块结构，区块结构包含多个交易的哈希。<br>那么交易哈希是怎么计算的呢？</p>\n<ol>\n<li>交易结构各字段序列化为字节数组</li>\n<li>把字节数组拼接为支付串</li>\n<li>对支付串计算两次 SHA256 得到交易 hash</li>\n</ol>\n<p>了解详情可进一步参考<a href=\"https://bitcoin.stackexchange.com/questions/2859/how-are-transaction-hashes-calculated\">如何计算交易 Hash?</a> 及<a href=\"https://bitcointalk.org/index.php?topic=54451.msg649253#msg649253\">如何创建 Hash?</a></p>\n<p>现在是不是对完整的交易到区块有了更清晰的认识。</p>\n<h2 id=\"智能合约雏形-应用场景说明\"><a href=\"#智能合约雏形-应用场景说明\" class=\"headerlink\" title=\"智能合约雏形 - 应用场景说明\"></a>智能合约雏形 - 应用场景说明</h2><p>由于交易是通过脚本来实现，脚本语言可以表达出无数的条件变种。</p>\n<p>比特币的脚本目前常用的主要分为两种，一种是常见的 P2PKH（支付给公钥哈希），另一种是 P2SH（Pay-to-Script-Hash 支付脚本哈希）。<br>P2SH 支付中，锁定脚本被密码学哈希所取代，当一笔交易试图支付 UTXO 时，要解锁支付脚本，它必须含有与哈希相匹配的脚本。</p>\n<p>这里不展开技术细节，下面说明一些应用场景，以便大家有更直观的认识。</p>\n<ul>\n<li><p>多重签名应用<br>合伙经营中，如只有一半以上的的股东同意签名就可以进行支付，可为公司治理提供管控便利，同时也能有效防范盗窃、挪用和遗失。</p>\n<p>用于担保和争端调解，一个买家想和他不认识或不信任的某人交易，在一般情况交易正常进行时，买家不想任何第三方参与。那交易双方可以发起支付，但如果交易出现问题时，那第三方就可以根据裁定，使用自己的签名和裁定认可的一方共同签名来兑现这笔交易。</p>\n</li>\n<li><p>保证合同<br>保证合同是建造公众商品时的集资办法，公众商品是指一旦建成，任何人都可以免费享受到好处。标准的例子是灯塔，所有人都认同应该建造一个，但是对于个人航海者来说灯塔太贵了，灯塔同时也会方便其他航海者。<br>一个解决方案是向所有人集资，只有当筹集的资金超过所需的建造成本时，每个人才真正付钱，如果集资款不足，则谁都不用付钱。</p>\n</li>\n<li><p>依靠预言<br>假如老人想让他孙子继承遗产，继承时间是在他死后或者在孙子年满 18 岁时（也是一个带锁定时间交易），无论哪个条件先满足，他的孙子都可以得到遗产。<br>因为比特币节点可依靠预言对死亡条件进行判断，预言是指具有密钥对的服务器，当用户自定义的表达式被证明是真的，它能按照要求对交易签名。</p>\n</li>\n</ul>\n"},{"title":"什么是比特币","date":"2019-11-02T01:12:33.000Z","layout":"config.default_layout","_content":"### 比特币是什么\n\n> 比特币是一种基于分布式网络的数字货币。\n> 比特币系统（广义的比特币）则是用来构建这种数字货币的网络系统，是一个分布式的点对点网络系统。\n\n本文主要讲解狭义的比特币概念。\n\n### 数字货币是什么\n\n凯恩斯在《货币论》上讲，货币可以承载债务，价格的一般等价物。货币的本质是等价物，它可以是任何东西，如：一张纸，一个数字，只要人们认可它的价值。人民币，美元等作为国家信用货币，其价值由国家主权背书。而数字货币是一种不依赖信用和实物的新型货币，它的价值由大家的共识决定。比特币就是一种数字货币。（我们在网银，微信，支付宝的金额，准确来讲，它是信用货币的数字化，不是数字货币，不过央行也在研究比特币，准备发行数字货币）\n\n### 运行原理\n\n大家知道，在银行系统的数据库里记录着跟我们身份 id 对应的财产，下文称这样的记录为账本，如张三的卡 10 月 1 日转入 1w, 余额 10w。\n比特币系统也同样有这样的账本，不同银行由单一的组织负责记录，比特币的记账由所有运行系统的人（即节点，可以简单理解为一台电脑）共同参与记录，每个节点都保存（同步）一份完整的账本。\n同时使用简单多数原则，来保证账本的一致性。举个例子：如果有人在自己电脑上把自己的余额从 1 万改为 1 百万，他这个账本和大多数人的账本不一致，就会被比特币系统认为是无效的。","source":"_posts/block_chain/什么是比特币.md","raw":"---\ntitle: 什么是比特币\ndate: 2019-11-02 09:12:33\nlayout: config.default_layout\ncategories: 'block chain'\ntags:\n- 区块链\n- 比特币\n---\n### 比特币是什么\n\n> 比特币是一种基于分布式网络的数字货币。\n> 比特币系统（广义的比特币）则是用来构建这种数字货币的网络系统，是一个分布式的点对点网络系统。\n\n本文主要讲解狭义的比特币概念。\n\n### 数字货币是什么\n\n凯恩斯在《货币论》上讲，货币可以承载债务，价格的一般等价物。货币的本质是等价物，它可以是任何东西，如：一张纸，一个数字，只要人们认可它的价值。人民币，美元等作为国家信用货币，其价值由国家主权背书。而数字货币是一种不依赖信用和实物的新型货币，它的价值由大家的共识决定。比特币就是一种数字货币。（我们在网银，微信，支付宝的金额，准确来讲，它是信用货币的数字化，不是数字货币，不过央行也在研究比特币，准备发行数字货币）\n\n### 运行原理\n\n大家知道，在银行系统的数据库里记录着跟我们身份 id 对应的财产，下文称这样的记录为账本，如张三的卡 10 月 1 日转入 1w, 余额 10w。\n比特币系统也同样有这样的账本，不同银行由单一的组织负责记录，比特币的记账由所有运行系统的人（即节点，可以简单理解为一台电脑）共同参与记录，每个节点都保存（同步）一份完整的账本。\n同时使用简单多数原则，来保证账本的一致性。举个例子：如果有人在自己电脑上把自己的余额从 1 万改为 1 百万，他这个账本和大多数人的账本不一致，就会被比特币系统认为是无效的。","slug":"block_chain/什么是比特币","published":1,"updated":"2021-07-04T07:09:51.461Z","_id":"ckqotlggo00002zmzhhf1356a","comments":1,"photos":[],"link":"","content":"<h3 id=\"比特币是什么\"><a href=\"#比特币是什么\" class=\"headerlink\" title=\"比特币是什么\"></a>比特币是什么</h3><blockquote>\n<p>比特币是一种基于分布式网络的数字货币。<br>比特币系统（广义的比特币）则是用来构建这种数字货币的网络系统，是一个分布式的点对点网络系统。</p>\n</blockquote>\n<p>本文主要讲解狭义的比特币概念。</p>\n<h3 id=\"数字货币是什么\"><a href=\"#数字货币是什么\" class=\"headerlink\" title=\"数字货币是什么\"></a>数字货币是什么</h3><p>凯恩斯在《货币论》上讲，货币可以承载债务，价格的一般等价物。货币的本质是等价物，它可以是任何东西，如：一张纸，一个数字，只要人们认可它的价值。人民币，美元等作为国家信用货币，其价值由国家主权背书。而数字货币是一种不依赖信用和实物的新型货币，它的价值由大家的共识决定。比特币就是一种数字货币。（我们在网银，微信，支付宝的金额，准确来讲，它是信用货币的数字化，不是数字货币，不过央行也在研究比特币，准备发行数字货币）</p>\n<h3 id=\"运行原理\"><a href=\"#运行原理\" class=\"headerlink\" title=\"运行原理\"></a>运行原理</h3><p>大家知道，在银行系统的数据库里记录着跟我们身份 id 对应的财产，下文称这样的记录为账本，如张三的卡 10 月 1 日转入 1w, 余额 10w。<br>比特币系统也同样有这样的账本，不同银行由单一的组织负责记录，比特币的记账由所有运行系统的人（即节点，可以简单理解为一台电脑）共同参与记录，每个节点都保存（同步）一份完整的账本。<br>同时使用简单多数原则，来保证账本的一致性。举个例子：如果有人在自己电脑上把自己的余额从 1 万改为 1 百万，他这个账本和大多数人的账本不一致，就会被比特币系统认为是无效的。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"比特币是什么\"><a href=\"#比特币是什么\" class=\"headerlink\" title=\"比特币是什么\"></a>比特币是什么</h3><blockquote>\n<p>比特币是一种基于分布式网络的数字货币。<br>比特币系统（广义的比特币）则是用来构建这种数字货币的网络系统，是一个分布式的点对点网络系统。</p>\n</blockquote>\n<p>本文主要讲解狭义的比特币概念。</p>\n<h3 id=\"数字货币是什么\"><a href=\"#数字货币是什么\" class=\"headerlink\" title=\"数字货币是什么\"></a>数字货币是什么</h3><p>凯恩斯在《货币论》上讲，货币可以承载债务，价格的一般等价物。货币的本质是等价物，它可以是任何东西，如：一张纸，一个数字，只要人们认可它的价值。人民币，美元等作为国家信用货币，其价值由国家主权背书。而数字货币是一种不依赖信用和实物的新型货币，它的价值由大家的共识决定。比特币就是一种数字货币。（我们在网银，微信，支付宝的金额，准确来讲，它是信用货币的数字化，不是数字货币，不过央行也在研究比特币，准备发行数字货币）</p>\n<h3 id=\"运行原理\"><a href=\"#运行原理\" class=\"headerlink\" title=\"运行原理\"></a>运行原理</h3><p>大家知道，在银行系统的数据库里记录着跟我们身份 id 对应的财产，下文称这样的记录为账本，如张三的卡 10 月 1 日转入 1w, 余额 10w。<br>比特币系统也同样有这样的账本，不同银行由单一的组织负责记录，比特币的记账由所有运行系统的人（即节点，可以简单理解为一台电脑）共同参与记录，每个节点都保存（同步）一份完整的账本。<br>同时使用简单多数原则，来保证账本的一致性。举个例子：如果有人在自己电脑上把自己的余额从 1 万改为 1 百万，他这个账本和大多数人的账本不一致，就会被比特币系统认为是无效的。</p>\n"},{"title":"ReactNative-Java与JavaScript之间的通信","date":"2018-12-09T01:30:33.000Z","layout":"config.default_layout","_content":"# ReactNative-Java与JavaScript之间的通信\n\n## 几个重要的类\n\n\n\n- Java层 ReactContext(ReactApplicationContext)： React Native 封装后的 Android Context，通过其访问设置 RN 包装起来的核心类实现等；\n\n- Java层 ReactInstanceManager(ReactInstanceManagerImpl)： RN对 Android 层暴露的大内总管，负责掌管 CatalystInstanceImpl 实例、ReactRootView、Activity 生命周期等；\n\n- Java/C++层 CatalystInstance(CatalystInstanceImpl)： RN Java、C++、JS通信总舵主，统管 JS、Java 核心 Module 映射表、回调等等，三端入口与桥梁；\n\n- C++层 NativeToJsBridge： Java 调用 JS 的桥梁，用来调用 JS Module、回调 Java（通过JsToNativeBridge）等；\n\n- C++层 JsToNativeBridge： JS 调用 Java 的桥梁，用来调用 Java Module等；\n\n- C++层 JSCExecutor： 掌管 Webkit 的 JavaScriptCore，JS 与 C++ 的转换桥接都在这里中转处理；\n\n- JS层 MessageQueue： 队列栈，用来处理 JS 的调用队列、调用 Java 或者 JS Module 的方法、处理回调、管理 JS Module 等；\n\n- 多层 JavaScriptModule/BaseJavaModule(NativeModule)： 双端字典映射表中的模块，负责 Java/JS 到彼此的映射调用格式申明，由 CatalystInstance 统管；\n\n\n\n## Java调用JavaScript\n\n![img](https://cdn.nlark.com/yuque/0/2018/png/199077/1543751641173-8a70a3ba-ff6e-41af-bbfc-3bc04fc848d2.png)\n\n```c++\n\nvoid JSCExecutor::callFunction(const std::string& moduleId, const std::string& methodId, const folly::dynamic& arguments) {\n  ......\n  auto result = [&] {\n    try {\n        //m_callFunctionReturnFlushedQueueJS来自于JSCExecutor::bindBridge()方法中初始化，JSCExecutor::bindBridge()是在前面分析启动流程时被调用的，实质是负责通过 Webkit JSC 拿到 JS 端代码的相关对象和方法引用，譬如拿到 JS 端 BatchedBridge.js 的 __fbBatchedBridge 属性与 MessageQueue.js 的 callFunctionReturnFlushedQueue 方法引用。此处实质为调用 MessageQueue.js 的 callFunctionReturnFlushedQueue 方法。\n      return m_callFunctionReturnFlushedQueueJS->callAsFunction({\n        Value(m_context, String::createExpectingAscii(moduleId)),\n        Value(m_context, String::createExpectingAscii(methodId)),\n        Value::fromDynamic(m_context, std::move(arguments))\n      });\n    } catch (...) {\n      std::throw_with_nested(\n        std::runtime_error(\"Error calling function: \" + moduleId + \":\" + methodId));\n    }\n  }();\n    //调用 native 模块，暂时忽略，下一小节解释，这里重点关注 Java 调用 JS 通信\n  callNativeModules(std::move(result));\n}\n```\n\n\n\n## JavaScript调用Java\n\n\n\n### ![img](https://cdn.nlark.com/yuque/0/2018/png/199077/1543751615410-914290d1-f1a8-44e0-89e3-26176a5fe11a.png)Sample\n\n\n\n```js\n//通过NativeModules拿到ToastAndroid\nimport { NativeModules } from 'react-native';\nmodule.exports = NativeModules.ToastAndroid;\n\n//使用的地方在JS中相关逻辑处调用，官方文档标准\nimport ToastAndroid from './ToastAndroid';\nToastAndroid.show('Awesome', ToastAndroid.SHORT);\n```\n\n\n\n![img](file:///var/folders/v0/8dgsh1jd74qfkddq5pcp_znc0000gn/T/abnerworks.Typora/image-20181202165046268.png?lastModify=1543751522)\n\n```java\nfunction genModule(config: ?ModuleConfig, moduleID: number): ?{name: string, module?: Object} {\n  ......\n  //通过JSC拿到C++中从Java端获取的Java的Module映射表包装配置类\n  const [moduleName, constants, methods, promiseMethods, syncMethods] = config;\n  ......\n  const module = {};\n  //遍历构建module的属性方法\n  methods && methods.forEach((methodName, methodID) => {\n    const isPromise = promiseMethods && arrayContains(promiseMethods, methodID);\n    const isSync = syncMethods && arrayContains(syncMethods, methodID);\n    invariant(!isPromise || !isSync, 'Cannot have a method that is both async and a sync hook');\n    const methodType = isPromise ? 'promise' : isSync ? 'sync' : 'async';\n    //生成Module的函数方法\n    module[methodName] = genMethod(moduleID, methodID, methodType);\n  });\n  Object.assign(module, constants);\n  ......\n  //返回一个\n  return { name: moduleName, module };\n}\n\nenqueueNativeCall(moduleID: number, methodID: number, params: Array<any>, onFail: ?Function, onSucc: ?Function) {\n    ......\n    this._callID++;\n    //_queue是个队列，用于存放调用的模块、方法、参数信息\n    //把JS准备调用Java的模块名、方法名、调用参数放到数组里存起来\n    this._queue[MODULE_IDS].push(moduleID);\n    this._queue[METHOD_IDS].push(methodID);\n    ......\n    this._queue[PARAMS].push(params);\n\n    const now = new Date().getTime();\n    //如果5ms内有多个方法调用就先待在队列里防止过高频率，否则调用C++的nativeFlushQueueImmediate方法\n    if (global.nativeFlushQueueImmediate &&\n        now - this._lastFlush >= MIN_TIME_BETWEEN_FLUSHES_MS) {\n      global.nativeFlushQueueImmediate(this._queue);\n      this._queue = [[], [], [], this._callID];\n      this._lastFlush = now;\n    }\n    ......\n}\n```","source":"_posts/react_native/ReactNative通信机制.md","raw":"---\ntitle: ReactNative-Java与JavaScript之间的通信\ndate: 2018-12-09 09:30:33\nlayout: config.default_layout\ncategories: 'React Native'\ntags:\n- React Native\n---\n# ReactNative-Java与JavaScript之间的通信\n\n## 几个重要的类\n\n\n\n- Java层 ReactContext(ReactApplicationContext)： React Native 封装后的 Android Context，通过其访问设置 RN 包装起来的核心类实现等；\n\n- Java层 ReactInstanceManager(ReactInstanceManagerImpl)： RN对 Android 层暴露的大内总管，负责掌管 CatalystInstanceImpl 实例、ReactRootView、Activity 生命周期等；\n\n- Java/C++层 CatalystInstance(CatalystInstanceImpl)： RN Java、C++、JS通信总舵主，统管 JS、Java 核心 Module 映射表、回调等等，三端入口与桥梁；\n\n- C++层 NativeToJsBridge： Java 调用 JS 的桥梁，用来调用 JS Module、回调 Java（通过JsToNativeBridge）等；\n\n- C++层 JsToNativeBridge： JS 调用 Java 的桥梁，用来调用 Java Module等；\n\n- C++层 JSCExecutor： 掌管 Webkit 的 JavaScriptCore，JS 与 C++ 的转换桥接都在这里中转处理；\n\n- JS层 MessageQueue： 队列栈，用来处理 JS 的调用队列、调用 Java 或者 JS Module 的方法、处理回调、管理 JS Module 等；\n\n- 多层 JavaScriptModule/BaseJavaModule(NativeModule)： 双端字典映射表中的模块，负责 Java/JS 到彼此的映射调用格式申明，由 CatalystInstance 统管；\n\n\n\n## Java调用JavaScript\n\n![img](https://cdn.nlark.com/yuque/0/2018/png/199077/1543751641173-8a70a3ba-ff6e-41af-bbfc-3bc04fc848d2.png)\n\n```c++\n\nvoid JSCExecutor::callFunction(const std::string& moduleId, const std::string& methodId, const folly::dynamic& arguments) {\n  ......\n  auto result = [&] {\n    try {\n        //m_callFunctionReturnFlushedQueueJS来自于JSCExecutor::bindBridge()方法中初始化，JSCExecutor::bindBridge()是在前面分析启动流程时被调用的，实质是负责通过 Webkit JSC 拿到 JS 端代码的相关对象和方法引用，譬如拿到 JS 端 BatchedBridge.js 的 __fbBatchedBridge 属性与 MessageQueue.js 的 callFunctionReturnFlushedQueue 方法引用。此处实质为调用 MessageQueue.js 的 callFunctionReturnFlushedQueue 方法。\n      return m_callFunctionReturnFlushedQueueJS->callAsFunction({\n        Value(m_context, String::createExpectingAscii(moduleId)),\n        Value(m_context, String::createExpectingAscii(methodId)),\n        Value::fromDynamic(m_context, std::move(arguments))\n      });\n    } catch (...) {\n      std::throw_with_nested(\n        std::runtime_error(\"Error calling function: \" + moduleId + \":\" + methodId));\n    }\n  }();\n    //调用 native 模块，暂时忽略，下一小节解释，这里重点关注 Java 调用 JS 通信\n  callNativeModules(std::move(result));\n}\n```\n\n\n\n## JavaScript调用Java\n\n\n\n### ![img](https://cdn.nlark.com/yuque/0/2018/png/199077/1543751615410-914290d1-f1a8-44e0-89e3-26176a5fe11a.png)Sample\n\n\n\n```js\n//通过NativeModules拿到ToastAndroid\nimport { NativeModules } from 'react-native';\nmodule.exports = NativeModules.ToastAndroid;\n\n//使用的地方在JS中相关逻辑处调用，官方文档标准\nimport ToastAndroid from './ToastAndroid';\nToastAndroid.show('Awesome', ToastAndroid.SHORT);\n```\n\n\n\n![img](file:///var/folders/v0/8dgsh1jd74qfkddq5pcp_znc0000gn/T/abnerworks.Typora/image-20181202165046268.png?lastModify=1543751522)\n\n```java\nfunction genModule(config: ?ModuleConfig, moduleID: number): ?{name: string, module?: Object} {\n  ......\n  //通过JSC拿到C++中从Java端获取的Java的Module映射表包装配置类\n  const [moduleName, constants, methods, promiseMethods, syncMethods] = config;\n  ......\n  const module = {};\n  //遍历构建module的属性方法\n  methods && methods.forEach((methodName, methodID) => {\n    const isPromise = promiseMethods && arrayContains(promiseMethods, methodID);\n    const isSync = syncMethods && arrayContains(syncMethods, methodID);\n    invariant(!isPromise || !isSync, 'Cannot have a method that is both async and a sync hook');\n    const methodType = isPromise ? 'promise' : isSync ? 'sync' : 'async';\n    //生成Module的函数方法\n    module[methodName] = genMethod(moduleID, methodID, methodType);\n  });\n  Object.assign(module, constants);\n  ......\n  //返回一个\n  return { name: moduleName, module };\n}\n\nenqueueNativeCall(moduleID: number, methodID: number, params: Array<any>, onFail: ?Function, onSucc: ?Function) {\n    ......\n    this._callID++;\n    //_queue是个队列，用于存放调用的模块、方法、参数信息\n    //把JS准备调用Java的模块名、方法名、调用参数放到数组里存起来\n    this._queue[MODULE_IDS].push(moduleID);\n    this._queue[METHOD_IDS].push(methodID);\n    ......\n    this._queue[PARAMS].push(params);\n\n    const now = new Date().getTime();\n    //如果5ms内有多个方法调用就先待在队列里防止过高频率，否则调用C++的nativeFlushQueueImmediate方法\n    if (global.nativeFlushQueueImmediate &&\n        now - this._lastFlush >= MIN_TIME_BETWEEN_FLUSHES_MS) {\n      global.nativeFlushQueueImmediate(this._queue);\n      this._queue = [[], [], [], this._callID];\n      this._lastFlush = now;\n    }\n    ......\n}\n```","slug":"react_native/ReactNative通信机制","published":1,"updated":"2021-07-04T07:10:43.295Z","_id":"ckqou4ee300007mmzgirm13xr","comments":1,"photos":[],"link":"","content":"<h1 id=\"ReactNative-Java与JavaScript之间的通信\"><a href=\"#ReactNative-Java与JavaScript之间的通信\" class=\"headerlink\" title=\"ReactNative-Java与JavaScript之间的通信\"></a>ReactNative-Java与JavaScript之间的通信</h1><h2 id=\"几个重要的类\"><a href=\"#几个重要的类\" class=\"headerlink\" title=\"几个重要的类\"></a>几个重要的类</h2><ul>\n<li><p>Java层 ReactContext(ReactApplicationContext)： React Native 封装后的 Android Context，通过其访问设置 RN 包装起来的核心类实现等；</p>\n</li>\n<li><p>Java层 ReactInstanceManager(ReactInstanceManagerImpl)： RN对 Android 层暴露的大内总管，负责掌管 CatalystInstanceImpl 实例、ReactRootView、Activity 生命周期等；</p>\n</li>\n<li><p>Java/C++层 CatalystInstance(CatalystInstanceImpl)： RN Java、C++、JS通信总舵主，统管 JS、Java 核心 Module 映射表、回调等等，三端入口与桥梁；</p>\n</li>\n<li><p>C++层 NativeToJsBridge： Java 调用 JS 的桥梁，用来调用 JS Module、回调 Java（通过JsToNativeBridge）等；</p>\n</li>\n<li><p>C++层 JsToNativeBridge： JS 调用 Java 的桥梁，用来调用 Java Module等；</p>\n</li>\n<li><p>C++层 JSCExecutor： 掌管 Webkit 的 JavaScriptCore，JS 与 C++ 的转换桥接都在这里中转处理；</p>\n</li>\n<li><p>JS层 MessageQueue： 队列栈，用来处理 JS 的调用队列、调用 Java 或者 JS Module 的方法、处理回调、管理 JS Module 等；</p>\n</li>\n<li><p>多层 JavaScriptModule/BaseJavaModule(NativeModule)： 双端字典映射表中的模块，负责 Java/JS 到彼此的映射调用格式申明，由 CatalystInstance 统管；</p>\n</li>\n</ul>\n<h2 id=\"Java调用JavaScript\"><a href=\"#Java调用JavaScript\" class=\"headerlink\" title=\"Java调用JavaScript\"></a>Java调用JavaScript</h2><p><img src=\"https://cdn.nlark.com/yuque/0/2018/png/199077/1543751641173-8a70a3ba-ff6e-41af-bbfc-3bc04fc848d2.png\" alt=\"img\"></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">JSCExecutor::callFunction</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> std::string&amp; moduleId, <span class=\"hljs-keyword\">const</span> std::string&amp; methodId, <span class=\"hljs-keyword\">const</span> folly::dynamic&amp; arguments)</span> </span>&#123;<br>  ......<br>  <span class=\"hljs-keyword\">auto</span> result = [&amp;] &#123;<br>    <span class=\"hljs-keyword\">try</span> &#123;<br>        <span class=\"hljs-comment\">//m_callFunctionReturnFlushedQueueJS来自于JSCExecutor::bindBridge()方法中初始化，JSCExecutor::bindBridge()是在前面分析启动流程时被调用的，实质是负责通过 Webkit JSC 拿到 JS 端代码的相关对象和方法引用，譬如拿到 JS 端 BatchedBridge.js 的 __fbBatchedBridge 属性与 MessageQueue.js 的 callFunctionReturnFlushedQueue 方法引用。此处实质为调用 MessageQueue.js 的 callFunctionReturnFlushedQueue 方法。</span><br>      <span class=\"hljs-keyword\">return</span> m_callFunctionReturnFlushedQueueJS-&gt;<span class=\"hljs-built_in\">callAsFunction</span>(&#123;<br>        <span class=\"hljs-built_in\">Value</span>(m_context, String::<span class=\"hljs-built_in\">createExpectingAscii</span>(moduleId)),<br>        <span class=\"hljs-built_in\">Value</span>(m_context, String::<span class=\"hljs-built_in\">createExpectingAscii</span>(methodId)),<br>        Value::<span class=\"hljs-built_in\">fromDynamic</span>(m_context, std::<span class=\"hljs-built_in\">move</span>(arguments))<br>      &#125;);<br>    &#125; <span class=\"hljs-built_in\"><span class=\"hljs-keyword\">catch</span></span> (...) &#123;<br>      std::<span class=\"hljs-built_in\">throw_with_nested</span>(<br>        std::<span class=\"hljs-built_in\">runtime_error</span>(<span class=\"hljs-string\">&quot;Error calling function: &quot;</span> + moduleId + <span class=\"hljs-string\">&quot;:&quot;</span> + methodId));<br>    &#125;<br>  &#125;();<br>    <span class=\"hljs-comment\">//调用 native 模块，暂时忽略，下一小节解释，这里重点关注 Java 调用 JS 通信</span><br>  <span class=\"hljs-built_in\">callNativeModules</span>(std::<span class=\"hljs-built_in\">move</span>(result));<br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n\n\n<h2 id=\"JavaScript调用Java\"><a href=\"#JavaScript调用Java\" class=\"headerlink\" title=\"JavaScript调用Java\"></a>JavaScript调用Java</h2><h3 id=\"Sample\"><a href=\"#Sample\" class=\"headerlink\" title=\"Sample\"></a><img src=\"https://cdn.nlark.com/yuque/0/2018/png/199077/1543751615410-914290d1-f1a8-44e0-89e3-26176a5fe11a.png\" alt=\"img\">Sample</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">//通过NativeModules拿到ToastAndroid</span><br><span class=\"hljs-keyword\">import</span> &#123; NativeModules &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react-native&#x27;</span>;<br><span class=\"hljs-built_in\">module</span>.exports = NativeModules.ToastAndroid;<br><br><span class=\"hljs-comment\">//使用的地方在JS中相关逻辑处调用，官方文档标准</span><br><span class=\"hljs-keyword\">import</span> ToastAndroid <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./ToastAndroid&#x27;</span>;<br>ToastAndroid.show(<span class=\"hljs-string\">&#x27;Awesome&#x27;</span>, ToastAndroid.SHORT);<br></code></pre></div></td></tr></table></figure>\n\n\n\n<p><img src=\"file:///var/folders/v0/8dgsh1jd74qfkddq5pcp_znc0000gn/T/abnerworks.Typora/image-20181202165046268.png?lastModify=1543751522\" alt=\"img\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs java\"><span class=\"hljs-function\">function <span class=\"hljs-title\">genModule</span><span class=\"hljs-params\">(config: ?ModuleConfig, moduleID: number)</span>: ?</span>&#123;name: string, <span class=\"hljs-keyword\">module</span>?: Object&#125; &#123;<br>  ......<br>  <span class=\"hljs-comment\">//通过JSC拿到C++中从Java端获取的Java的Module映射表包装配置类</span><br>  <span class=\"hljs-keyword\">const</span> [moduleName, constants, methods, promiseMethods, syncMethods] = config;<br>  ......<br>  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">module</span> = &#123;&#125;;<br>  <span class=\"hljs-comment\">//遍历构建module的属性方法</span><br>  methods &amp;&amp; methods.forEach((methodName, methodID) =&gt; &#123;<br>    <span class=\"hljs-keyword\">const</span> isPromise = promiseMethods &amp;&amp; arrayContains(promiseMethods, methodID);<br>    <span class=\"hljs-keyword\">const</span> isSync = syncMethods &amp;&amp; arrayContains(syncMethods, methodID);<br>    invariant(!isPromise || !isSync, <span class=\"hljs-string\">&#x27;Cannot have a method that is both async and a sync hook&#x27;</span>);<br>    <span class=\"hljs-keyword\">const</span> methodType = isPromise ? <span class=\"hljs-string\">&#x27;promise&#x27;</span> : isSync ? <span class=\"hljs-string\">&#x27;sync&#x27;</span> : <span class=\"hljs-string\">&#x27;async&#x27;</span>;<br>    <span class=\"hljs-comment\">//生成Module的函数方法</span><br>    <span class=\"hljs-keyword\">module</span>[methodName] = genMethod(moduleID, methodID, methodType);<br>  &#125;);<br>  Object.assign(<span class=\"hljs-keyword\">module</span>, constants);<br>  ......<br>  <span class=\"hljs-comment\">//返回一个</span><br>  <span class=\"hljs-keyword\">return</span> &#123; name: moduleName, <span class=\"hljs-keyword\">module</span> &#125;;<br>&#125;<br><br>enqueueNativeCall(moduleID: number, methodID: number, params: Array&lt;any&gt;, onFail: ?Function, onSucc: ?Function) &#123;<br>    ......<br>    <span class=\"hljs-keyword\">this</span>._callID++;<br>    <span class=\"hljs-comment\">//_queue是个队列，用于存放调用的模块、方法、参数信息</span><br>    <span class=\"hljs-comment\">//把JS准备调用Java的模块名、方法名、调用参数放到数组里存起来</span><br>    <span class=\"hljs-keyword\">this</span>._queue[MODULE_IDS].push(moduleID);<br>    <span class=\"hljs-keyword\">this</span>._queue[METHOD_IDS].push(methodID);<br>    ......<br>    <span class=\"hljs-keyword\">this</span>._queue[PARAMS].push(params);<br><br>    <span class=\"hljs-keyword\">const</span> now = <span class=\"hljs-keyword\">new</span> Date().getTime();<br>    <span class=\"hljs-comment\">//如果5ms内有多个方法调用就先待在队列里防止过高频率，否则调用C++的nativeFlushQueueImmediate方法</span><br>    <span class=\"hljs-keyword\">if</span> (global.nativeFlushQueueImmediate &amp;&amp;<br>        now - <span class=\"hljs-keyword\">this</span>._lastFlush &gt;= MIN_TIME_BETWEEN_FLUSHES_MS) &#123;<br>      global.nativeFlushQueueImmediate(<span class=\"hljs-keyword\">this</span>._queue);<br>      <span class=\"hljs-keyword\">this</span>._queue = [[], [], [], <span class=\"hljs-keyword\">this</span>._callID];<br>      <span class=\"hljs-keyword\">this</span>._lastFlush = now;<br>    &#125;<br>    ......<br>&#125;<br></code></pre></div></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"ReactNative-Java与JavaScript之间的通信\"><a href=\"#ReactNative-Java与JavaScript之间的通信\" class=\"headerlink\" title=\"ReactNative-Java与JavaScript之间的通信\"></a>ReactNative-Java与JavaScript之间的通信</h1><h2 id=\"几个重要的类\"><a href=\"#几个重要的类\" class=\"headerlink\" title=\"几个重要的类\"></a>几个重要的类</h2><ul>\n<li><p>Java层 ReactContext(ReactApplicationContext)： React Native 封装后的 Android Context，通过其访问设置 RN 包装起来的核心类实现等；</p>\n</li>\n<li><p>Java层 ReactInstanceManager(ReactInstanceManagerImpl)： RN对 Android 层暴露的大内总管，负责掌管 CatalystInstanceImpl 实例、ReactRootView、Activity 生命周期等；</p>\n</li>\n<li><p>Java/C++层 CatalystInstance(CatalystInstanceImpl)： RN Java、C++、JS通信总舵主，统管 JS、Java 核心 Module 映射表、回调等等，三端入口与桥梁；</p>\n</li>\n<li><p>C++层 NativeToJsBridge： Java 调用 JS 的桥梁，用来调用 JS Module、回调 Java（通过JsToNativeBridge）等；</p>\n</li>\n<li><p>C++层 JsToNativeBridge： JS 调用 Java 的桥梁，用来调用 Java Module等；</p>\n</li>\n<li><p>C++层 JSCExecutor： 掌管 Webkit 的 JavaScriptCore，JS 与 C++ 的转换桥接都在这里中转处理；</p>\n</li>\n<li><p>JS层 MessageQueue： 队列栈，用来处理 JS 的调用队列、调用 Java 或者 JS Module 的方法、处理回调、管理 JS Module 等；</p>\n</li>\n<li><p>多层 JavaScriptModule/BaseJavaModule(NativeModule)： 双端字典映射表中的模块，负责 Java/JS 到彼此的映射调用格式申明，由 CatalystInstance 统管；</p>\n</li>\n</ul>\n<h2 id=\"Java调用JavaScript\"><a href=\"#Java调用JavaScript\" class=\"headerlink\" title=\"Java调用JavaScript\"></a>Java调用JavaScript</h2><p><img src=\"https://cdn.nlark.com/yuque/0/2018/png/199077/1543751641173-8a70a3ba-ff6e-41af-bbfc-3bc04fc848d2.png\" alt=\"img\"></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">JSCExecutor::callFunction</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> std::string&amp; moduleId, <span class=\"hljs-keyword\">const</span> std::string&amp; methodId, <span class=\"hljs-keyword\">const</span> folly::dynamic&amp; arguments)</span> </span>&#123;<br>  ......<br>  <span class=\"hljs-keyword\">auto</span> result = [&amp;] &#123;<br>    <span class=\"hljs-keyword\">try</span> &#123;<br>        <span class=\"hljs-comment\">//m_callFunctionReturnFlushedQueueJS来自于JSCExecutor::bindBridge()方法中初始化，JSCExecutor::bindBridge()是在前面分析启动流程时被调用的，实质是负责通过 Webkit JSC 拿到 JS 端代码的相关对象和方法引用，譬如拿到 JS 端 BatchedBridge.js 的 __fbBatchedBridge 属性与 MessageQueue.js 的 callFunctionReturnFlushedQueue 方法引用。此处实质为调用 MessageQueue.js 的 callFunctionReturnFlushedQueue 方法。</span><br>      <span class=\"hljs-keyword\">return</span> m_callFunctionReturnFlushedQueueJS-&gt;<span class=\"hljs-built_in\">callAsFunction</span>(&#123;<br>        <span class=\"hljs-built_in\">Value</span>(m_context, String::<span class=\"hljs-built_in\">createExpectingAscii</span>(moduleId)),<br>        <span class=\"hljs-built_in\">Value</span>(m_context, String::<span class=\"hljs-built_in\">createExpectingAscii</span>(methodId)),<br>        Value::<span class=\"hljs-built_in\">fromDynamic</span>(m_context, std::<span class=\"hljs-built_in\">move</span>(arguments))<br>      &#125;);<br>    &#125; <span class=\"hljs-built_in\"><span class=\"hljs-keyword\">catch</span></span> (...) &#123;<br>      std::<span class=\"hljs-built_in\">throw_with_nested</span>(<br>        std::<span class=\"hljs-built_in\">runtime_error</span>(<span class=\"hljs-string\">&quot;Error calling function: &quot;</span> + moduleId + <span class=\"hljs-string\">&quot;:&quot;</span> + methodId));<br>    &#125;<br>  &#125;();<br>    <span class=\"hljs-comment\">//调用 native 模块，暂时忽略，下一小节解释，这里重点关注 Java 调用 JS 通信</span><br>  <span class=\"hljs-built_in\">callNativeModules</span>(std::<span class=\"hljs-built_in\">move</span>(result));<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"JavaScript调用Java\"><a href=\"#JavaScript调用Java\" class=\"headerlink\" title=\"JavaScript调用Java\"></a>JavaScript调用Java</h2><h3 id=\"Sample\"><a href=\"#Sample\" class=\"headerlink\" title=\"Sample\"></a><img src=\"https://cdn.nlark.com/yuque/0/2018/png/199077/1543751615410-914290d1-f1a8-44e0-89e3-26176a5fe11a.png\" alt=\"img\">Sample</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">//通过NativeModules拿到ToastAndroid</span><br><span class=\"hljs-keyword\">import</span> &#123; NativeModules &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;react-native&#x27;</span>;<br><span class=\"hljs-built_in\">module</span>.exports = NativeModules.ToastAndroid;<br><br><span class=\"hljs-comment\">//使用的地方在JS中相关逻辑处调用，官方文档标准</span><br><span class=\"hljs-keyword\">import</span> ToastAndroid <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./ToastAndroid&#x27;</span>;<br>ToastAndroid.show(<span class=\"hljs-string\">&#x27;Awesome&#x27;</span>, ToastAndroid.SHORT);<br></code></pre></td></tr></table></figure>\n\n\n\n<p><img src=\"file:///var/folders/v0/8dgsh1jd74qfkddq5pcp_znc0000gn/T/abnerworks.Typora/image-20181202165046268.png?lastModify=1543751522\" alt=\"img\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-function\">function <span class=\"hljs-title\">genModule</span><span class=\"hljs-params\">(config: ?ModuleConfig, moduleID: number)</span>: ?</span>&#123;name: string, <span class=\"hljs-keyword\">module</span>?: Object&#125; &#123;<br>  ......<br>  <span class=\"hljs-comment\">//通过JSC拿到C++中从Java端获取的Java的Module映射表包装配置类</span><br>  <span class=\"hljs-keyword\">const</span> [moduleName, constants, methods, promiseMethods, syncMethods] = config;<br>  ......<br>  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">module</span> = &#123;&#125;;<br>  <span class=\"hljs-comment\">//遍历构建module的属性方法</span><br>  methods &amp;&amp; methods.forEach((methodName, methodID) =&gt; &#123;<br>    <span class=\"hljs-keyword\">const</span> isPromise = promiseMethods &amp;&amp; arrayContains(promiseMethods, methodID);<br>    <span class=\"hljs-keyword\">const</span> isSync = syncMethods &amp;&amp; arrayContains(syncMethods, methodID);<br>    invariant(!isPromise || !isSync, <span class=\"hljs-string\">&#x27;Cannot have a method that is both async and a sync hook&#x27;</span>);<br>    <span class=\"hljs-keyword\">const</span> methodType = isPromise ? <span class=\"hljs-string\">&#x27;promise&#x27;</span> : isSync ? <span class=\"hljs-string\">&#x27;sync&#x27;</span> : <span class=\"hljs-string\">&#x27;async&#x27;</span>;<br>    <span class=\"hljs-comment\">//生成Module的函数方法</span><br>    <span class=\"hljs-keyword\">module</span>[methodName] = genMethod(moduleID, methodID, methodType);<br>  &#125;);<br>  Object.assign(<span class=\"hljs-keyword\">module</span>, constants);<br>  ......<br>  <span class=\"hljs-comment\">//返回一个</span><br>  <span class=\"hljs-keyword\">return</span> &#123; name: moduleName, <span class=\"hljs-keyword\">module</span> &#125;;<br>&#125;<br><br>enqueueNativeCall(moduleID: number, methodID: number, params: Array&lt;any&gt;, onFail: ?Function, onSucc: ?Function) &#123;<br>    ......<br>    <span class=\"hljs-keyword\">this</span>._callID++;<br>    <span class=\"hljs-comment\">//_queue是个队列，用于存放调用的模块、方法、参数信息</span><br>    <span class=\"hljs-comment\">//把JS准备调用Java的模块名、方法名、调用参数放到数组里存起来</span><br>    <span class=\"hljs-keyword\">this</span>._queue[MODULE_IDS].push(moduleID);<br>    <span class=\"hljs-keyword\">this</span>._queue[METHOD_IDS].push(methodID);<br>    ......<br>    <span class=\"hljs-keyword\">this</span>._queue[PARAMS].push(params);<br><br>    <span class=\"hljs-keyword\">const</span> now = <span class=\"hljs-keyword\">new</span> Date().getTime();<br>    <span class=\"hljs-comment\">//如果5ms内有多个方法调用就先待在队列里防止过高频率，否则调用C++的nativeFlushQueueImmediate方法</span><br>    <span class=\"hljs-keyword\">if</span> (global.nativeFlushQueueImmediate &amp;&amp;<br>        now - <span class=\"hljs-keyword\">this</span>._lastFlush &gt;= MIN_TIME_BETWEEN_FLUSHES_MS) &#123;<br>      global.nativeFlushQueueImmediate(<span class=\"hljs-keyword\">this</span>._queue);<br>      <span class=\"hljs-keyword\">this</span>._queue = [[], [], [], <span class=\"hljs-keyword\">this</span>._callID];<br>      <span class=\"hljs-keyword\">this</span>._lastFlush = now;<br>    &#125;<br>    ......<br>&#125;<br></code></pre></td></tr></table></figure>"},{"title":"ReactNative-启动流程","date":"2018-12-09T01:30:33.000Z","layout":"config.default_layout","_content":"# ReactNative-启动流程\n\n## 背景\n\nReactNative在真机iOS和Android上，使用的是**JavaScriptCore**引擎，也就是Safari所使用的JavaScript引擎。但是在iOS上JavaScriptCore并没有使用即时编译技术（JIT），因为在iOS中应用无权拥有可写可执行的内存页（因而无法动态生成代码），在安卓上，理论上是可以使用的。JavaScriptCore引擎也是使用C++编写，在iOS和安卓中，JavaScriptCore都做了一层封装，可以无须关心引擎和系统桥接的那一层。iOS/Android系统通JavaScriptCore引擎将定制好的各种原生组件注入。我们编写少量Java代码大量JavaScript代码，中间作为桥梁的核心是 C/C++ 来处理的。\n\n![img](https://cdn.nlark.com/yuque/0/2018/png/199077/1542525129415-a4873dbe-d967-4554-a866-aa6a275c2594.png)\n\n## RN 启动流程框架浅析\n\n集成 RN 无非就是通过继承 ReactActivity 或者自己通过 ReactRootView 进行处理，但是实质都是触发了ReactRootView 的 startReactApplication 方法\n\n- ReactActivity\n\n先来看看ReactActivity,明显的代理模式，实际操作全部交给了ReactActivityDelegate\n\n```\npublic abstract class ReactActivity extends Activity\n    implements DefaultHardwareBackBtnHandler, PermissionAwareActivity {\n  private final ReactActivityDelegate mDelegate;\n  protected ReactActivity() {\n    mDelegate = createReactActivityDelegate();\n  } \n  @Override\n  protected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    mDelegate.onCreate(savedInstanceState);\n  }\n  @Override\n  protected void onPause() {\n    super.onPause();\n    mDelegate.onPause();\n  }\n  @Override\n  protected void onResume() {\n    super.onResume();\n    mDelegate.onResume();\n  }\n   ..........\n}\n```\n\n- ReactActivityDelegate\n\n再来看看ReactActivityDelegate,可以看见，ReactActivityDelegate 只是一个抽出来的封装，上面的实质就是 new 了一个 ReactRootView（实质是 Android 的 FrameLayout），接着调用 ReactRootView 的 startReactApplication 方法，完事就像常规 Android 代码一样直接通过 Activity 的 setContentView 方法把 View 设置进去。所以可以看出来，RN 的神秘之处一定在于 ReactRootView 中，Activity 对于 RN 来说只是为了让 RN 依附符合 Android 的框架而已，所以说，说白了 RN 依旧是标准 Android，因此在我们集成开发中我们可以选择整个界面（包含多级跳转）都用 React Native 实现，或者一个 Android 现有界面中部分采用 React Native 实现，因为这货就是一个 View.\n\n```\npublic class ReactActivityDelegate {\n\n  protected void onCreate(Bundle savedInstanceState) {\n    //启动流程一定会执行的，mMainComponentName为我们设置的，与JS边保持一致\n    if (mMainComponentName != null) {\n      loadApp(mMainComponentName);\n    }\n    mDoubleTapReloadRecognizer = new DoubleTapReloadRecognizer();\n  }\n\n  protected void loadApp(String appKey) {\n    if (mReactRootView != null) {\n      throw new IllegalStateException(\"Cannot loadApp while app is already running.\");\n    }\n    // createRootView其实就是create了一个FrameLayout，核心方法 \n    mReactRootView = createRootView();\n    mReactRootView.startReactApplication(\n      getReactNativeHost().getReactInstanceManager(),\n      appKey,\n      getLaunchOptions());\n    // 把view设置进Activity\n    getPlainActivity().setContentView(mReactRootView);\n  }\n}\n```\n\n- ReactRootView\n\n既然明白了 RN 就是个 View，那就接着看看 ReactRootView，如下：\n\n可以看见，ReactRootView的英文注释已经交代很清楚用途和地位了，直接看上面代码的startReactApplication 方法，可以看见他又调用了一个三个参数的同名方法，具体这三个参数来历如下（也是我们自己集成 RN 时手动 builder 模式创建的）：\n\n1. reactInstanceManager： 大内总管接口类，提供一个构造者模式的初始化 Builder, 这类也是我们在集成 RN 时 new ReactRootView 的之前自己创建的。 \n\n1. moduleName： 与 JS 代码约定的 String 类型识别 name，JS 端通过 AppRegistry.registerComponent 方法设置这个 name，Java 端重写基类的 getMainComponentName 方法设置这个 name，这样两边入口就对上了。 \n\n1. launchOptions： 这里默认是 null 的，如果自己不继承 ReactActivity 而自己实现的话可以通过这个参数在 startActivity 时传入一些参数到 JS 代码，用来依据参数初始化 JS 端代码。\n\n可以看见接着调用了 mReactInstanceManager createReactContextInBackground 方法，mReactInstanceManager 就是上面说的第一个参数，实质是通过一个构造者模式创建的\n\n```\n/**\n React Native 的 RootView，负责监听标准 Android 的 View 相关的事件分发和子View 渲染等。\n */\npublic class ReactRootView extends SizeMonitoringFrameLayout implements RootView {\n  public void startReactApplication(ReactInstanceManager reactInstanceManager, String moduleName) {\n    startReactApplication(reactInstanceManager, moduleName, null);\n  }\n\n/**\n调度react component的渲染，使用reactInstanceManager讲js模块attch到JS Context中。一些初始化参数可以通过launchOptions传递给react component\n*/\n  public void startReactApplication(\n      ReactInstanceManager reactInstanceManager,\n      String moduleName,\n      @Nullable Bundle initialProperties) {\n    Systrace.beginSection(TRACE_TAG_REACT_JAVA_BRIDGE, \"startReactApplication\");\n    try {\n      UiThreadUtil.assertOnUiThread();\n      Assertions.assertCondition(\n        mReactInstanceManager == null,\n        \"This root view has already been attached to a catalyst instance manager\");\n      mReactInstanceManager = reactInstanceManager;\n      mJSModuleName = moduleName;\n      mAppProperties = initialProperties;\n      // 核心创建ReactContext，先判断是否初始化了\n      if (!mReactInstanceManager.hasStartedCreatingInitialContext()) {\n        mReactInstanceManager.createReactContextInBackground();\n      }\n      attachToReactInstanceManager();\n    } finally {\n      Systrace.endSection(TRACE_TAG_REACT_JAVA_BRIDGE);\n    }\n  }\n}\n```\n\n- ReactInstanceManager\n\nReactInstanceManager的createReactContextInBackground 方法看看，如下：\n\n可以看到createReactContext经过一系列的包装，最终开启了一个新线程去创建ReactContext,先从initParams中获取JavaScriptExecutor和JsBundleLoader，JsBundleLoader负责JsBundle的加载，实际情况中我们可以修改加载起实现热更新。开始创建后，有几个核心方法createReactContext和setupReactContext，接下来我们来看看createReactContext:\n\n总的来说，createReactContext()把nativeModules注册到CatalysInstanceImpl里,然后把这两张映射表交给 CatalystInstanceImpl，同时包装创建 ReactContext 对象，然后通过 CatalystInstanceImpl 的 runJSBundle() 方法把 JS bundle 文件的 JS 代码加载进来等待 Task 结束以后调用 JS 入口进行渲染 RN。CatalystInstanceImpl 的 build 方法中调用的 CatalystInstanceImpl 构造方法到底干了什么\n\n\n\nbuild()中其实就是构造者模式，实例化CatalystInstanceImpl, CatalystInstanceImpl 就是个封装总管，负责了 Java 层代码到 JNI 封装初始化的任务和 Java 与 JS 调用的 Java 端控制中心。核心方法是initializeBridge,这是个native方法，我们看看他穿了什么参数进去：\n\n1. ReactCallBack是CatalystInstanceImpl 的内部静态实现类 BridgeCallback，负责相关接口回传和回\n\n1. jsExecutor参数： 前面分析的 XReactInstanceManagerImpl 中赋值为 JSCJavaScriptExecutor 实例，JSCJavaScriptExecutor 中也有自己的 native initHybrid 的 C++ 方法被初始化时调用，具体在 OnLoad.cpp 的 JSCJavaScriptExecutorHolder 类中。 \n\n1. jsQueue参数： 来自于 mReactQueueConfiguration.getJSQueueThread()，mReactQueueConfiguration就是 CatalystInstanceImpl 中创建的 ReactQueueConfigurationImpl.create( ReactQueueConfigurationSpec, new NativeExceptionHandler()); 第一个参数来自于 XReactInstanceManagerImpl 中 CatalystInstanceImpl 的建造者，实质为包装相关线程名字、类型等，然后通过 ReactQueueConfigurationImpl 的 create 创建对应线程的 Handler，这里就是名字为 js 的后台线程 Handler，第二个参数为异常捕获回调实现。 \n\n1. moduleQueue参数： 来自于 mReactQueueConfiguration.getNativeModulesQueueThread（）mReactQueueConfiguration同上\n\n1. javaModules: 来自mNativeModuleRegistry.getJavaModules(this),mNativeModuleRegistry就是构建CatalysInstanceImpl时传入的javaModules。\n\n1. cxxModules：来自mNativeModuleRegistry.getCxxModules(),mNativeModuleRegistry就是构建CatalysInstanceImpl时传入的javaModules，获取c++模块\n\nCatalystInstanceImpl 自己在 Java 层直接把持住了 JavaScriptModuleRegistry 映射表，把 NativeModuleRegistry 映射表、BridgeCallback 回调、JSCJavaScriptExecutor、js 队列 MessageQueueThread、native 队列 MessageQueueThread 都通过 JNI 嫁接到了 C++ 中。那我们现在先把目光转移到 CatalystInstanceImpl.cpp 的 initializeBridge 方法上（关于 JNI 的 OnLoad 中初始化注册模块等等就不介绍了），如下：\n\n```\n @ThreadConfined(UI)\npublic void recreateReactContextInBackground() {\n   Assertions.assertCondition(\n       mHasStartedCreatingInitialContext,\n       \"recreateReactContextInBackground should only be called after the initial \" +\n           \"createReactContextInBackground call.\");\n   recreateReactContextInBackgroundInner();\n }\n\n@ThreadConfined(UI)\n private void recreateReactContextInBackgroundInner() {\n   if (mUseDeveloperSupport\n       && mJSMainModulePath != null\n       && !Systrace.isTracing(TRACE_TAG_REACT_APPS | TRACE_TAG_REACT_JS_VM_CALLS)) {\n     final DeveloperSettings devSettings = mDevSupportManager.getDevSettings();\n\n     // If remote JS debugging is enabled, load from dev server.\n     if (mDevSupportManager.hasUpToDateJSBundleInCache() &&\n         !devSettings.isRemoteJSDebugEnabled()) {\n       // If there is a up-to-date bundle downloaded from server,\n       // with remote JS debugging disabled, always use that.\n       ........\n     return;\n   }\n    //非调试模式，真实环境下去加载Bundle\n   recreateReactContextInBackgroundFromBundleLoader();\n }\n     \n public void createReactContextInBackground() {\n   ......\n   recreateReactContextInBackgroundInner();\n }\n\n private void recreateReactContextInBackgroundInner() {\n   UiThreadUtil.assertOnUiThread();\n   \n   if (mUseDeveloperSupport && mJSMainModuleName != null) {\n   //如果是 dev 模式，BuildConfig.DEBUG=true就走这里，在线更新bundle，手机晃动出现调试菜单等等。\n   //这个路线属于RN调试流程原理，后面再写文章分析，这里我们抓住主线分析\n ......\n return;\n}\n    //非调试模式，即BuildConfig.DEBUG=false时执行\n    recreateReactContextInBackgroundFromBundleLoader();\n}\n\nprivate void recreateReactContextInBackgroundFromBundleLoader() {\n   //在后台创建ReactContext，两个参数是重点。\n   //包装了JavaScript执行上下文的JavaScriptExecutorFactory\n   //自定义热更新时setJSBundleFile方法参数就是巧妙的利用这里是走JSBundleLoader.createAssetLoader还是JSBundleLoader.createFileLoader！！！！！！\n     recreateReactContextInBackground(mJavaScriptExecutorFactory, mBundleLoader);\n}\n\n@ThreadConfined(UI)\n private void recreateReactContextInBackground(\n   JavaScriptExecutorFactory jsExecutorFactory,\n   JSBundleLoader jsBundleLoader) {\n     //包装一下JsExecutorFactor\n   final ReactContextInitParams initParams = new ReactContextInitParams(\n     jsExecutorFactory,\n     jsBundleLoader);\n     // 开线程差创建ReactContext\n   if (mCreateReactContextThread == null) {\n     runCreateReactContextOnNewThread(initParams);\n   } else {\n     mPendingReactContextInitParams = initParams;\n   }\n }\n\n @ThreadConfined(UI)\n private void runCreateReactContextOnNewThread(final ReactContextInitParams initParams) {\n   .....\n   //开线程创建ReactContext\n   mCreateReactContextThread =\n       new Thread(\n           new Runnable() {\n             @Override\n             public void run() {\n           .....\n               try {\n                 Process.setThreadPriority(Process.THREAD_PRIORITY_DISPLAY);\n                 //创建ReactContext的核心方法，createReactContext\n                 final ReactApplicationContext reactApplicationContext =\n                     createReactContext(\n                         initParams.getJsExecutorFactory().create(),\n                         initParams.getJsBundleLoader());\n\n                 mCreateReactContextThread = null;\n                 \n                 final Runnable maybeRecreateReactContextRunnable =\n                     new Runnable() {\n                       @Override\n                       public void run() {\n                         if (mPendingReactContextInitParams != null) {\n                           runCreateReactContextOnNewThread(mPendingReactContextInitParams);\n                           mPendingReactContextInitParams = null;\n                         }\n                       }\n                 };\n                 Runnable setupReactContextRunnable =\n                     new Runnable() {\n                       @Override\n                       public void run() {\n                         try {\n                           setupReactContext(reactApplicationContext);\n                         } catch (Exception e) {\n                           mDevSupportManager.handleException(e);\n                         }\n                       }\n                  };\n        reactApplicationContext.runOnNativeModulesQueueThread(setupReactContextRunnable);\n                 UiThreadUtil.runOnUiThread(maybeRecreateReactContextRunnable);\n               } catch (Exception e) {\n                 mDevSupportManager.handleException(e);\n               }\n             }\n           });\n   mCreateReactContextThread.start();\n }\n  /**\n   * @return instance of {@link ReactContext} configured a {@link CatalystInstance} set\n   */\n  private ReactApplicationContext createReactContext(\n      JavaScriptExecutor jsExecutor,\n      JSBundleLoader jsBundleLoader) {\n    final ReactApplicationContext reactContext = new ReactApplicationContext(mApplicationContext);\n// 是否处于开发者模式，提供一些异常处理的机制，捕获崩溃显示在红色弹窗\n    if (mUseDeveloperSupport) {\n      reactContext.setNativeModuleCallExceptionHandler(mDevSupportManager);\n    }\n// Java层模块注册表，通过它把NativeModules注册到CatalystInstance.包括我们自定义的继承自NativeModule的Java代码\n    NativeModuleRegistry nativeModuleRegistry = processPackages(reactContext, mPackages, false);\n// 异常处理Handler\n      NativeModuleCallExceptionHandler exceptionHandler = mNativeModuleCallExceptionHandler != null\n      ? mNativeModuleCallExceptionHandler\n      : mDevSupportManager;\n// 开始构建CatalystInstance \n    CatalystInstanceImpl.Builder catalystInstanceBuilder = new CatalystInstanceImpl.Builder()\n      .setReactQueueConfigurationSpec(ReactQueueConfigurationSpec.createDefault())\n      .setJSExecutor(jsExecutor)\n      .setRegistry(nativeModuleRegistry)\n      .setJSBundleLoader(jsBundleLoader)\n      .setNativeModuleCallExceptionHandler(exceptionHandler);\n    ........\n    catalystInstance.runJSBundle();\n    reactContext.initializeWithInstance(catalystInstance);\n\n    return reactContext;\n  }\nprivate CatalystInstanceImpl(\n      final ReactQueueConfigurationSpec reactQueueConfigurationSpec,\n      final JavaScriptExecutor jsExecutor,\n      final NativeModuleRegistry nativeModuleRegistry,\n      final JSBundleLoader jsBundleLoader,\n      NativeModuleCallExceptionHandler nativeModuleCallExceptionHandler) {\n    Log.d(ReactConstants.TAG, \"Initializing React Xplat Bridge.\");\n    mHybridData = initHybrid();\n\n    mReactQueueConfiguration = ReactQueueConfigurationImpl.create(\n        reactQueueConfigurationSpec,\n        new NativeExceptionHandler());\n    mBridgeIdleListeners = new CopyOnWriteArrayList<>();\n    mNativeModuleRegistry = nativeModuleRegistry;\n    mJSModuleRegistry = new JavaScriptModuleRegistry();\n    mJSBundleLoader = jsBundleLoader;\n    mNativeModuleCallExceptionHandler = nativeModuleCallExceptionHandler;\n    mNativeModulesQueueThread = mReactQueueConfiguration.getNativeModulesQueueThread();\n    mTraceListener = new JSProfilerTraceListener(this);\n\n    Log.d(ReactConstants.TAG, \"Initializing React Xplat Bridge before initializeBridge\");\n    initializeBridge(\n      new BridgeCallback(this),\n      jsExecutor,\n      mReactQueueConfiguration.getJSQueueThread(),\n      mNativeModulesQueueThread,\n      mNativeModuleRegistry.getJavaModules(this),\n      mNativeModuleRegistry.getCxxModules());\n    Log.d(ReactConstants.TAG, \"Initializing React Xplat Bridge after initializeBridge\");\n\n    mJavaScriptContextHolder = new JavaScriptContextHolder(getJavaScriptContext());\n  }\n  \n    private native void initializeBridge(\n      ReactCallback callback,\n      JavaScriptExecutor jsExecutor,\n      MessageQueueThread jsQueue,\n      MessageQueueThread moduleQueue,\n      Collection<JavaModuleWrapper> javaModules,\n      Collection<ModuleHolder> cxxModules);\n```\n\n- CatalystInstance\n\n到此 CatalystInstance 的实例 CatalystInstanceImpl 对象也就初始化 OK 了，同时通过 initializeBridge 建立了 Bridge 连接。关于这个 Bridge 在RN 中是通过 libjsc.so 中 JSObjectRef.h 的 JSObjectSetProperty(m_context, globalObject, jsPropertyName, valueToInject, 0, NULL); 来关联的，这样就可以在 Native 设置 JS 执行，反之同理。\n\n这一小节我们只讨论 RN 的加载启动流程，所以 initializeBridge 的具体实现我们下面分析互相通信交互时再仔细分析，故我们先把思路还是回到 XReactInstanceManagerImpl 中 createReactContext 方法的 reactContext.initializeWithInstance(catalystInstance); 一行，可以看见，这行代码意思就是将刚刚初始化的 catalystInstance 传递给全局唯一的 reactContext 对象，同时在 reactContext 中通过 catalystInstance 拿到 JS、Native、UI 几个 Thread 的引用，方便快速访问使用这些对象。接着调用了 catalystInstance.runJSBundle(); 方法，这个方法实现如下：\n\n通过注释我们假设 Loader 是默认的，也即 JSBundleLoader 类的如下方法：\n\n可以看见，它实质又调用了 CatalystInstanceImpl 的 loadScriptFromAssets 方法，我们继续跟踪 CatalystInstanceImpl 的这个方法吧，如下：\n\n说白了就是 CatalystInstanceImpl.java 中 CatalystInstanceImpl 构造方法中调用 C++ 的 initializeBridge 方法时传入的第一个参数 BridgeCallback 么，就是说 JS bundle 文件被加载完成以后 JS 端调用 Java 端时会触发 Callback 的 onBatchComplete 方法，这货最终又会触发 OnBatchCompleteListener 接口的 onBatchComplete 方法，这不就把 JS Bundle 文件加载完成以后回调 Java 通知 OK 了么。最后我们还差一个runCreateContextOnNewThread中的setupReactContext任务还没分析，方法如下：\n\n这里的核心在rootView.invokeJsEntryPoint(),追踪一下源码，发现最后调用了如下方法\n\n我们知道 AppRegistry.class 是 JS 端暴露给 Java 端的接口方法，所以catalystInstance.getJSModule(AppRegistry.class) 实质就桥接到 JS 端代码去了，那就去看看AppRegistry中写了写啥\n\n到这里ReactNative的启动终于到头了，但react-native还有很多细节，这里先介绍React'Native的启动流程，搭建去Bridge，至于通信方式在后面继续介绍。\n\n```\nvoid CatalystInstanceImpl::initializeBridge(\n    jni::alias_ref<ReactCallback::javaobject> callback,\n    // This executor is actually a factory holder.\n    JavaScriptExecutorHolder* jseh,\n    jni::alias_ref<JavaMessageQueueThread::javaobject> jsQueue,\n    jni::alias_ref<JavaMessageQueueThread::javaobject> moduleQueue,\n    ModuleRegistryHolder* mrh) {\n    ......\n  // Java CatalystInstanceImpl -> C++ CatalystInstanceImpl -> Bridge -> Bridge::Callback\n  // --weak--> ReactCallback -> Java CatalystInstanceImpl\n    ......\n    //instance_为ReactCommon目录下 Instance.h 中类的实例；\n    //第一个参数为JInstanceCallback实现类，父类在cxxreact/Instance.h中。\n    //第二个参数为JavaScriptExecutorHolder，实质对应java中JavaScriptExecutor，也就是上面分析java的initializeBridge方法第二个参数JSCJavaScriptExecutor。\n    //第三第四个参数都是java线程透传到C++，纯C++的JMessageQueueThread。\n    //第五个参数为C++的ModuleRegistryHolder的getModuleRegistry()方法。\n  instance_->initializeBridge(folly::make_unique<JInstanceCallback>(callback),\n                              jseh->getExecutorFactory(),\n                              folly::make_unique<JMessageQueueThread>(jsQueue),\n                              folly::make_unique<JMessageQueueThread>(moduleQueue),\n                              mrh->getModuleRegistry());\n}\n@Override\n  public void runJSBundle() {\n    ......\n    mJSBundleHasLoaded = true;\n    //mJSBundleLoader就是前面分析的依据不同设置决定是JSBundleLoader的createAssetLoader还是createFileLoader等静态方法的匿名实现类。\n    // incrementPendingJSCalls();\n    mJSBundleLoader.loadScript(CatalystInstanceImpl.this);\n    ......\n  }\npublic static JSBundleLoader createAssetLoader(\n      final Context context,\n      final String assetUrl) {\n    return new JSBundleLoader() {\n      @Override\n      public void loadScript(CatalystInstanceImpl instance) {\n        instance.loadScriptFromAssets(context.getAssets(), assetUrl);\n      }\n\n​```\n  @Override\n  public String getSourceUrl() {\n    return assetUrl;\n  }\n};\n  }\nnative void loadScriptFromAssets(AssetManager assetManager, String assetURL);\n1\nloadScriptFromAssets 既然是一个 native 方法，我们去 CatalystInstanceImpl.cpp 看下这个方法的实现，如下：\n\nvoid CatalystInstanceImpl::loadScriptFromAssets(jobject assetManager,\n                                                const std::string& assetURL) {\n  const int kAssetsLength = 9;  // strlen(\"assets://\");\n  //获取source路径名，不计前缀，这里默认就是index.android.bundle\n  auto sourceURL = assetURL.substr(kAssetsLength);\n    //assetManager是Java传递的AssetManager。\n    //extractAssetManager是JSLoader.cpp中通过系统动态链接库android/asset_manager_jni.h的AAssetManager_fromJava方法来获取AAssetManager对象的。\n  auto manager = react::extractAssetManager(assetManager);\n    //通过JSLoader对象的loadScriptFromAssets方法读文件，得到大字符串script（即index.android.bundle文件的JS内容）。\n  auto script = react::loadScriptFromAssets(manager, sourceURL);\n    //判断是不是Unbundle，这里不是Unbundle，因为打包命令我们用了react.gradle的默认bundle，没用unbundle命令（感兴趣的自己分析这条路线）。\n  if (JniJSModulesUnbundle::isUnbundle(manager, sourceURL)) {\n    instance_->loadUnbundle(\n      folly::make_unique<JniJSModulesUnbundle>(manager, sourceURL),\n      std::move(script),\n      sourceURL);\n    return;\n  } else {\n    //bundle命令打包的，所以走这里。\n    //instance_为ReactCommon目录下 Instance.h 中类的实例，前面分析过了。\n    instance_->loadScriptFromString(std::move(script), sourceURL);\n  }\n}\nprivate void setupReactContext(final ReactApplicationContext reactContext) {\n\n    //Initialize all the native modules\n    catalystInstance.initialize();\n    //重置devSupportManager中的reactContext\n    mDevSupportManager.onNewReactContextCreated(reactContext);\n    mMemoryPressureRouter.addMemoryPressureListener(catalystInstance);\n    //置位生命周期\n    moveReactContextToCurrentLifecycleState();\n// 核心方法\n    synchronized (mAttachedRootViews) {\n      for (ReactRootView rootView : mAttachedRootViews) {\n        attachRootViewToInstance(rootView, catalystInstance);\n      }\n    }\n// 通知UI更新\n    UiThreadUtil.runOnUiThread(\n        new Runnable() {\n          @Override\n          public void run() {\n            for (ReactInstanceEventListener listener : finalListeners) {\n              listener.onReactContextInitialized(reactContext);\n            }\n          }\n        });\n    // 开启JS消息队列线程\n    reactContext.runOnJSQueueThread(\n        new Runnable() {\n          @Override\n          public void run() {\n            Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);\n          }\n        });\n    //开启Native消息队列线程\n    reactContext.runOnNativeModulesQueueThread(\n        new Runnable() {\n          @Override\n          public void run() {\n            Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);\n          }\n        });\n  }\n\n  private void attachRootViewToInstance(\n      final ReactRootView rootView,\n      CatalystInstance catalystInstance) {\n       //通过UIManagerModule设置根布局为ReactRootView\n    UIManagerModule uiManagerModule = catalystInstance.getNativeModule(UIManagerModule.class);\n        //设置相关tag\n    final int rootTag = uiManagerModule.addRootView(rootView);\n    rootView.setRootViewTag(rootTag);\n      //Calls into JS to start the React application. \n    rootView.invokeJSEntryPoint();\n    ......\n    UiThreadUtil.runOnUiThread(new Runnable() {\n      @Override\n      public void run() {\n        //\n        rootView.onAttachedToReactInstance();\n      }\n    });\n  }\n/**\n   * Calls the default entry point into JS which is AppRegistry.runApplication()\n   */\n  private void defaultJSEntryPoint() {\n      try {\n        if (mReactInstanceManager == null || !mIsAttachedToInstance) {\n          return;\n        }\n        ReactContext reactContext = mReactInstanceManager.getCurrentReactContext();\n        if (reactContext == null) {\n          return;\n        }\n        CatalystInstance catalystInstance = reactContext.getCatalystInstance();\n          // 包装相关参数，传给js，rootTag用来告诉js端对应的是native 端哪一个view\n        WritableNativeMap appParams = new WritableNativeMap();\n        appParams.putDouble(\"rootTag\", getRootViewTag());\n        @Nullable Bundle appProperties = getAppProperties();\n        if (appProperties != null) {\n          appParams.putMap(\"initialProps\", Arguments.fromBundle(appProperties));\n        }\n        ....\n        //核心！！！ReactNative真正的启动流程就是在这里被调用起来的\n        String jsAppModuleName = getJSModuleName();\n        catalystInstance.getJSModule(AppRegistry.class).runApplication(jsAppModuleName, appParams);\n      } finally {\n        Systrace.endSection(TRACE_TAG_REACT_JAVA_BRIDGE);\n      }\n  }\n\n//`AppRegistry` is the JS entry point to running all React Native apps.  App\n// root components should register themselves with\nvar AppRegistry = {\n    ......\n    //我们JS端自己在index.android.js文件中调用的入口就是：\n    //AppRegistry.registerComponent('TestRN', () => TestRN);\n  registerComponent: function(appKey: string, getComponentFunc: ComponentProvider): string {\n    runnables[appKey] = {\n      run: (appParameters) =>\n        renderApplication(getComponentFunc(), appParameters.initialProps, appParameters.rootTag)\n    };\n    return appKey;\n  },\n    ......\n    //上面java端 AppRegistry 调用的 JS 端就是这个方法，索引到我们设置的appkey=TestRN字符串的JS入口\n  runApplication: function(appKey: string, appParameters: any): void {\n    ......\n    runnables[appKey].run(appParameters);\n  },\n    ......\n};\n\n```\n\n## 小结\n\n到这里ReactNative的启动流程就差不多了，我们小梳理总结，如下图：\n\n![img](https://i.loli.net/2018/11/18/5bf0e39e53802.jpg)上面这幅图已经囊括了我们上面说到的启动流程的全部流程分析","source":"_posts/react_native/ReactNative启动流程.md","raw":"---\ntitle: ReactNative-启动流程\ndate: 2018-12-09 09:30:33\nlayout: config.default_layout\ncategories: 'React Native'\ntags:\n- React Native\n---\n# ReactNative-启动流程\n\n## 背景\n\nReactNative在真机iOS和Android上，使用的是**JavaScriptCore**引擎，也就是Safari所使用的JavaScript引擎。但是在iOS上JavaScriptCore并没有使用即时编译技术（JIT），因为在iOS中应用无权拥有可写可执行的内存页（因而无法动态生成代码），在安卓上，理论上是可以使用的。JavaScriptCore引擎也是使用C++编写，在iOS和安卓中，JavaScriptCore都做了一层封装，可以无须关心引擎和系统桥接的那一层。iOS/Android系统通JavaScriptCore引擎将定制好的各种原生组件注入。我们编写少量Java代码大量JavaScript代码，中间作为桥梁的核心是 C/C++ 来处理的。\n\n![img](https://cdn.nlark.com/yuque/0/2018/png/199077/1542525129415-a4873dbe-d967-4554-a866-aa6a275c2594.png)\n\n## RN 启动流程框架浅析\n\n集成 RN 无非就是通过继承 ReactActivity 或者自己通过 ReactRootView 进行处理，但是实质都是触发了ReactRootView 的 startReactApplication 方法\n\n- ReactActivity\n\n先来看看ReactActivity,明显的代理模式，实际操作全部交给了ReactActivityDelegate\n\n```\npublic abstract class ReactActivity extends Activity\n    implements DefaultHardwareBackBtnHandler, PermissionAwareActivity {\n  private final ReactActivityDelegate mDelegate;\n  protected ReactActivity() {\n    mDelegate = createReactActivityDelegate();\n  } \n  @Override\n  protected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    mDelegate.onCreate(savedInstanceState);\n  }\n  @Override\n  protected void onPause() {\n    super.onPause();\n    mDelegate.onPause();\n  }\n  @Override\n  protected void onResume() {\n    super.onResume();\n    mDelegate.onResume();\n  }\n   ..........\n}\n```\n\n- ReactActivityDelegate\n\n再来看看ReactActivityDelegate,可以看见，ReactActivityDelegate 只是一个抽出来的封装，上面的实质就是 new 了一个 ReactRootView（实质是 Android 的 FrameLayout），接着调用 ReactRootView 的 startReactApplication 方法，完事就像常规 Android 代码一样直接通过 Activity 的 setContentView 方法把 View 设置进去。所以可以看出来，RN 的神秘之处一定在于 ReactRootView 中，Activity 对于 RN 来说只是为了让 RN 依附符合 Android 的框架而已，所以说，说白了 RN 依旧是标准 Android，因此在我们集成开发中我们可以选择整个界面（包含多级跳转）都用 React Native 实现，或者一个 Android 现有界面中部分采用 React Native 实现，因为这货就是一个 View.\n\n```\npublic class ReactActivityDelegate {\n\n  protected void onCreate(Bundle savedInstanceState) {\n    //启动流程一定会执行的，mMainComponentName为我们设置的，与JS边保持一致\n    if (mMainComponentName != null) {\n      loadApp(mMainComponentName);\n    }\n    mDoubleTapReloadRecognizer = new DoubleTapReloadRecognizer();\n  }\n\n  protected void loadApp(String appKey) {\n    if (mReactRootView != null) {\n      throw new IllegalStateException(\"Cannot loadApp while app is already running.\");\n    }\n    // createRootView其实就是create了一个FrameLayout，核心方法 \n    mReactRootView = createRootView();\n    mReactRootView.startReactApplication(\n      getReactNativeHost().getReactInstanceManager(),\n      appKey,\n      getLaunchOptions());\n    // 把view设置进Activity\n    getPlainActivity().setContentView(mReactRootView);\n  }\n}\n```\n\n- ReactRootView\n\n既然明白了 RN 就是个 View，那就接着看看 ReactRootView，如下：\n\n可以看见，ReactRootView的英文注释已经交代很清楚用途和地位了，直接看上面代码的startReactApplication 方法，可以看见他又调用了一个三个参数的同名方法，具体这三个参数来历如下（也是我们自己集成 RN 时手动 builder 模式创建的）：\n\n1. reactInstanceManager： 大内总管接口类，提供一个构造者模式的初始化 Builder, 这类也是我们在集成 RN 时 new ReactRootView 的之前自己创建的。 \n\n1. moduleName： 与 JS 代码约定的 String 类型识别 name，JS 端通过 AppRegistry.registerComponent 方法设置这个 name，Java 端重写基类的 getMainComponentName 方法设置这个 name，这样两边入口就对上了。 \n\n1. launchOptions： 这里默认是 null 的，如果自己不继承 ReactActivity 而自己实现的话可以通过这个参数在 startActivity 时传入一些参数到 JS 代码，用来依据参数初始化 JS 端代码。\n\n可以看见接着调用了 mReactInstanceManager createReactContextInBackground 方法，mReactInstanceManager 就是上面说的第一个参数，实质是通过一个构造者模式创建的\n\n```\n/**\n React Native 的 RootView，负责监听标准 Android 的 View 相关的事件分发和子View 渲染等。\n */\npublic class ReactRootView extends SizeMonitoringFrameLayout implements RootView {\n  public void startReactApplication(ReactInstanceManager reactInstanceManager, String moduleName) {\n    startReactApplication(reactInstanceManager, moduleName, null);\n  }\n\n/**\n调度react component的渲染，使用reactInstanceManager讲js模块attch到JS Context中。一些初始化参数可以通过launchOptions传递给react component\n*/\n  public void startReactApplication(\n      ReactInstanceManager reactInstanceManager,\n      String moduleName,\n      @Nullable Bundle initialProperties) {\n    Systrace.beginSection(TRACE_TAG_REACT_JAVA_BRIDGE, \"startReactApplication\");\n    try {\n      UiThreadUtil.assertOnUiThread();\n      Assertions.assertCondition(\n        mReactInstanceManager == null,\n        \"This root view has already been attached to a catalyst instance manager\");\n      mReactInstanceManager = reactInstanceManager;\n      mJSModuleName = moduleName;\n      mAppProperties = initialProperties;\n      // 核心创建ReactContext，先判断是否初始化了\n      if (!mReactInstanceManager.hasStartedCreatingInitialContext()) {\n        mReactInstanceManager.createReactContextInBackground();\n      }\n      attachToReactInstanceManager();\n    } finally {\n      Systrace.endSection(TRACE_TAG_REACT_JAVA_BRIDGE);\n    }\n  }\n}\n```\n\n- ReactInstanceManager\n\nReactInstanceManager的createReactContextInBackground 方法看看，如下：\n\n可以看到createReactContext经过一系列的包装，最终开启了一个新线程去创建ReactContext,先从initParams中获取JavaScriptExecutor和JsBundleLoader，JsBundleLoader负责JsBundle的加载，实际情况中我们可以修改加载起实现热更新。开始创建后，有几个核心方法createReactContext和setupReactContext，接下来我们来看看createReactContext:\n\n总的来说，createReactContext()把nativeModules注册到CatalysInstanceImpl里,然后把这两张映射表交给 CatalystInstanceImpl，同时包装创建 ReactContext 对象，然后通过 CatalystInstanceImpl 的 runJSBundle() 方法把 JS bundle 文件的 JS 代码加载进来等待 Task 结束以后调用 JS 入口进行渲染 RN。CatalystInstanceImpl 的 build 方法中调用的 CatalystInstanceImpl 构造方法到底干了什么\n\n\n\nbuild()中其实就是构造者模式，实例化CatalystInstanceImpl, CatalystInstanceImpl 就是个封装总管，负责了 Java 层代码到 JNI 封装初始化的任务和 Java 与 JS 调用的 Java 端控制中心。核心方法是initializeBridge,这是个native方法，我们看看他穿了什么参数进去：\n\n1. ReactCallBack是CatalystInstanceImpl 的内部静态实现类 BridgeCallback，负责相关接口回传和回\n\n1. jsExecutor参数： 前面分析的 XReactInstanceManagerImpl 中赋值为 JSCJavaScriptExecutor 实例，JSCJavaScriptExecutor 中也有自己的 native initHybrid 的 C++ 方法被初始化时调用，具体在 OnLoad.cpp 的 JSCJavaScriptExecutorHolder 类中。 \n\n1. jsQueue参数： 来自于 mReactQueueConfiguration.getJSQueueThread()，mReactQueueConfiguration就是 CatalystInstanceImpl 中创建的 ReactQueueConfigurationImpl.create( ReactQueueConfigurationSpec, new NativeExceptionHandler()); 第一个参数来自于 XReactInstanceManagerImpl 中 CatalystInstanceImpl 的建造者，实质为包装相关线程名字、类型等，然后通过 ReactQueueConfigurationImpl 的 create 创建对应线程的 Handler，这里就是名字为 js 的后台线程 Handler，第二个参数为异常捕获回调实现。 \n\n1. moduleQueue参数： 来自于 mReactQueueConfiguration.getNativeModulesQueueThread（）mReactQueueConfiguration同上\n\n1. javaModules: 来自mNativeModuleRegistry.getJavaModules(this),mNativeModuleRegistry就是构建CatalysInstanceImpl时传入的javaModules。\n\n1. cxxModules：来自mNativeModuleRegistry.getCxxModules(),mNativeModuleRegistry就是构建CatalysInstanceImpl时传入的javaModules，获取c++模块\n\nCatalystInstanceImpl 自己在 Java 层直接把持住了 JavaScriptModuleRegistry 映射表，把 NativeModuleRegistry 映射表、BridgeCallback 回调、JSCJavaScriptExecutor、js 队列 MessageQueueThread、native 队列 MessageQueueThread 都通过 JNI 嫁接到了 C++ 中。那我们现在先把目光转移到 CatalystInstanceImpl.cpp 的 initializeBridge 方法上（关于 JNI 的 OnLoad 中初始化注册模块等等就不介绍了），如下：\n\n```\n @ThreadConfined(UI)\npublic void recreateReactContextInBackground() {\n   Assertions.assertCondition(\n       mHasStartedCreatingInitialContext,\n       \"recreateReactContextInBackground should only be called after the initial \" +\n           \"createReactContextInBackground call.\");\n   recreateReactContextInBackgroundInner();\n }\n\n@ThreadConfined(UI)\n private void recreateReactContextInBackgroundInner() {\n   if (mUseDeveloperSupport\n       && mJSMainModulePath != null\n       && !Systrace.isTracing(TRACE_TAG_REACT_APPS | TRACE_TAG_REACT_JS_VM_CALLS)) {\n     final DeveloperSettings devSettings = mDevSupportManager.getDevSettings();\n\n     // If remote JS debugging is enabled, load from dev server.\n     if (mDevSupportManager.hasUpToDateJSBundleInCache() &&\n         !devSettings.isRemoteJSDebugEnabled()) {\n       // If there is a up-to-date bundle downloaded from server,\n       // with remote JS debugging disabled, always use that.\n       ........\n     return;\n   }\n    //非调试模式，真实环境下去加载Bundle\n   recreateReactContextInBackgroundFromBundleLoader();\n }\n     \n public void createReactContextInBackground() {\n   ......\n   recreateReactContextInBackgroundInner();\n }\n\n private void recreateReactContextInBackgroundInner() {\n   UiThreadUtil.assertOnUiThread();\n   \n   if (mUseDeveloperSupport && mJSMainModuleName != null) {\n   //如果是 dev 模式，BuildConfig.DEBUG=true就走这里，在线更新bundle，手机晃动出现调试菜单等等。\n   //这个路线属于RN调试流程原理，后面再写文章分析，这里我们抓住主线分析\n ......\n return;\n}\n    //非调试模式，即BuildConfig.DEBUG=false时执行\n    recreateReactContextInBackgroundFromBundleLoader();\n}\n\nprivate void recreateReactContextInBackgroundFromBundleLoader() {\n   //在后台创建ReactContext，两个参数是重点。\n   //包装了JavaScript执行上下文的JavaScriptExecutorFactory\n   //自定义热更新时setJSBundleFile方法参数就是巧妙的利用这里是走JSBundleLoader.createAssetLoader还是JSBundleLoader.createFileLoader！！！！！！\n     recreateReactContextInBackground(mJavaScriptExecutorFactory, mBundleLoader);\n}\n\n@ThreadConfined(UI)\n private void recreateReactContextInBackground(\n   JavaScriptExecutorFactory jsExecutorFactory,\n   JSBundleLoader jsBundleLoader) {\n     //包装一下JsExecutorFactor\n   final ReactContextInitParams initParams = new ReactContextInitParams(\n     jsExecutorFactory,\n     jsBundleLoader);\n     // 开线程差创建ReactContext\n   if (mCreateReactContextThread == null) {\n     runCreateReactContextOnNewThread(initParams);\n   } else {\n     mPendingReactContextInitParams = initParams;\n   }\n }\n\n @ThreadConfined(UI)\n private void runCreateReactContextOnNewThread(final ReactContextInitParams initParams) {\n   .....\n   //开线程创建ReactContext\n   mCreateReactContextThread =\n       new Thread(\n           new Runnable() {\n             @Override\n             public void run() {\n           .....\n               try {\n                 Process.setThreadPriority(Process.THREAD_PRIORITY_DISPLAY);\n                 //创建ReactContext的核心方法，createReactContext\n                 final ReactApplicationContext reactApplicationContext =\n                     createReactContext(\n                         initParams.getJsExecutorFactory().create(),\n                         initParams.getJsBundleLoader());\n\n                 mCreateReactContextThread = null;\n                 \n                 final Runnable maybeRecreateReactContextRunnable =\n                     new Runnable() {\n                       @Override\n                       public void run() {\n                         if (mPendingReactContextInitParams != null) {\n                           runCreateReactContextOnNewThread(mPendingReactContextInitParams);\n                           mPendingReactContextInitParams = null;\n                         }\n                       }\n                 };\n                 Runnable setupReactContextRunnable =\n                     new Runnable() {\n                       @Override\n                       public void run() {\n                         try {\n                           setupReactContext(reactApplicationContext);\n                         } catch (Exception e) {\n                           mDevSupportManager.handleException(e);\n                         }\n                       }\n                  };\n        reactApplicationContext.runOnNativeModulesQueueThread(setupReactContextRunnable);\n                 UiThreadUtil.runOnUiThread(maybeRecreateReactContextRunnable);\n               } catch (Exception e) {\n                 mDevSupportManager.handleException(e);\n               }\n             }\n           });\n   mCreateReactContextThread.start();\n }\n  /**\n   * @return instance of {@link ReactContext} configured a {@link CatalystInstance} set\n   */\n  private ReactApplicationContext createReactContext(\n      JavaScriptExecutor jsExecutor,\n      JSBundleLoader jsBundleLoader) {\n    final ReactApplicationContext reactContext = new ReactApplicationContext(mApplicationContext);\n// 是否处于开发者模式，提供一些异常处理的机制，捕获崩溃显示在红色弹窗\n    if (mUseDeveloperSupport) {\n      reactContext.setNativeModuleCallExceptionHandler(mDevSupportManager);\n    }\n// Java层模块注册表，通过它把NativeModules注册到CatalystInstance.包括我们自定义的继承自NativeModule的Java代码\n    NativeModuleRegistry nativeModuleRegistry = processPackages(reactContext, mPackages, false);\n// 异常处理Handler\n      NativeModuleCallExceptionHandler exceptionHandler = mNativeModuleCallExceptionHandler != null\n      ? mNativeModuleCallExceptionHandler\n      : mDevSupportManager;\n// 开始构建CatalystInstance \n    CatalystInstanceImpl.Builder catalystInstanceBuilder = new CatalystInstanceImpl.Builder()\n      .setReactQueueConfigurationSpec(ReactQueueConfigurationSpec.createDefault())\n      .setJSExecutor(jsExecutor)\n      .setRegistry(nativeModuleRegistry)\n      .setJSBundleLoader(jsBundleLoader)\n      .setNativeModuleCallExceptionHandler(exceptionHandler);\n    ........\n    catalystInstance.runJSBundle();\n    reactContext.initializeWithInstance(catalystInstance);\n\n    return reactContext;\n  }\nprivate CatalystInstanceImpl(\n      final ReactQueueConfigurationSpec reactQueueConfigurationSpec,\n      final JavaScriptExecutor jsExecutor,\n      final NativeModuleRegistry nativeModuleRegistry,\n      final JSBundleLoader jsBundleLoader,\n      NativeModuleCallExceptionHandler nativeModuleCallExceptionHandler) {\n    Log.d(ReactConstants.TAG, \"Initializing React Xplat Bridge.\");\n    mHybridData = initHybrid();\n\n    mReactQueueConfiguration = ReactQueueConfigurationImpl.create(\n        reactQueueConfigurationSpec,\n        new NativeExceptionHandler());\n    mBridgeIdleListeners = new CopyOnWriteArrayList<>();\n    mNativeModuleRegistry = nativeModuleRegistry;\n    mJSModuleRegistry = new JavaScriptModuleRegistry();\n    mJSBundleLoader = jsBundleLoader;\n    mNativeModuleCallExceptionHandler = nativeModuleCallExceptionHandler;\n    mNativeModulesQueueThread = mReactQueueConfiguration.getNativeModulesQueueThread();\n    mTraceListener = new JSProfilerTraceListener(this);\n\n    Log.d(ReactConstants.TAG, \"Initializing React Xplat Bridge before initializeBridge\");\n    initializeBridge(\n      new BridgeCallback(this),\n      jsExecutor,\n      mReactQueueConfiguration.getJSQueueThread(),\n      mNativeModulesQueueThread,\n      mNativeModuleRegistry.getJavaModules(this),\n      mNativeModuleRegistry.getCxxModules());\n    Log.d(ReactConstants.TAG, \"Initializing React Xplat Bridge after initializeBridge\");\n\n    mJavaScriptContextHolder = new JavaScriptContextHolder(getJavaScriptContext());\n  }\n  \n    private native void initializeBridge(\n      ReactCallback callback,\n      JavaScriptExecutor jsExecutor,\n      MessageQueueThread jsQueue,\n      MessageQueueThread moduleQueue,\n      Collection<JavaModuleWrapper> javaModules,\n      Collection<ModuleHolder> cxxModules);\n```\n\n- CatalystInstance\n\n到此 CatalystInstance 的实例 CatalystInstanceImpl 对象也就初始化 OK 了，同时通过 initializeBridge 建立了 Bridge 连接。关于这个 Bridge 在RN 中是通过 libjsc.so 中 JSObjectRef.h 的 JSObjectSetProperty(m_context, globalObject, jsPropertyName, valueToInject, 0, NULL); 来关联的，这样就可以在 Native 设置 JS 执行，反之同理。\n\n这一小节我们只讨论 RN 的加载启动流程，所以 initializeBridge 的具体实现我们下面分析互相通信交互时再仔细分析，故我们先把思路还是回到 XReactInstanceManagerImpl 中 createReactContext 方法的 reactContext.initializeWithInstance(catalystInstance); 一行，可以看见，这行代码意思就是将刚刚初始化的 catalystInstance 传递给全局唯一的 reactContext 对象，同时在 reactContext 中通过 catalystInstance 拿到 JS、Native、UI 几个 Thread 的引用，方便快速访问使用这些对象。接着调用了 catalystInstance.runJSBundle(); 方法，这个方法实现如下：\n\n通过注释我们假设 Loader 是默认的，也即 JSBundleLoader 类的如下方法：\n\n可以看见，它实质又调用了 CatalystInstanceImpl 的 loadScriptFromAssets 方法，我们继续跟踪 CatalystInstanceImpl 的这个方法吧，如下：\n\n说白了就是 CatalystInstanceImpl.java 中 CatalystInstanceImpl 构造方法中调用 C++ 的 initializeBridge 方法时传入的第一个参数 BridgeCallback 么，就是说 JS bundle 文件被加载完成以后 JS 端调用 Java 端时会触发 Callback 的 onBatchComplete 方法，这货最终又会触发 OnBatchCompleteListener 接口的 onBatchComplete 方法，这不就把 JS Bundle 文件加载完成以后回调 Java 通知 OK 了么。最后我们还差一个runCreateContextOnNewThread中的setupReactContext任务还没分析，方法如下：\n\n这里的核心在rootView.invokeJsEntryPoint(),追踪一下源码，发现最后调用了如下方法\n\n我们知道 AppRegistry.class 是 JS 端暴露给 Java 端的接口方法，所以catalystInstance.getJSModule(AppRegistry.class) 实质就桥接到 JS 端代码去了，那就去看看AppRegistry中写了写啥\n\n到这里ReactNative的启动终于到头了，但react-native还有很多细节，这里先介绍React'Native的启动流程，搭建去Bridge，至于通信方式在后面继续介绍。\n\n```\nvoid CatalystInstanceImpl::initializeBridge(\n    jni::alias_ref<ReactCallback::javaobject> callback,\n    // This executor is actually a factory holder.\n    JavaScriptExecutorHolder* jseh,\n    jni::alias_ref<JavaMessageQueueThread::javaobject> jsQueue,\n    jni::alias_ref<JavaMessageQueueThread::javaobject> moduleQueue,\n    ModuleRegistryHolder* mrh) {\n    ......\n  // Java CatalystInstanceImpl -> C++ CatalystInstanceImpl -> Bridge -> Bridge::Callback\n  // --weak--> ReactCallback -> Java CatalystInstanceImpl\n    ......\n    //instance_为ReactCommon目录下 Instance.h 中类的实例；\n    //第一个参数为JInstanceCallback实现类，父类在cxxreact/Instance.h中。\n    //第二个参数为JavaScriptExecutorHolder，实质对应java中JavaScriptExecutor，也就是上面分析java的initializeBridge方法第二个参数JSCJavaScriptExecutor。\n    //第三第四个参数都是java线程透传到C++，纯C++的JMessageQueueThread。\n    //第五个参数为C++的ModuleRegistryHolder的getModuleRegistry()方法。\n  instance_->initializeBridge(folly::make_unique<JInstanceCallback>(callback),\n                              jseh->getExecutorFactory(),\n                              folly::make_unique<JMessageQueueThread>(jsQueue),\n                              folly::make_unique<JMessageQueueThread>(moduleQueue),\n                              mrh->getModuleRegistry());\n}\n@Override\n  public void runJSBundle() {\n    ......\n    mJSBundleHasLoaded = true;\n    //mJSBundleLoader就是前面分析的依据不同设置决定是JSBundleLoader的createAssetLoader还是createFileLoader等静态方法的匿名实现类。\n    // incrementPendingJSCalls();\n    mJSBundleLoader.loadScript(CatalystInstanceImpl.this);\n    ......\n  }\npublic static JSBundleLoader createAssetLoader(\n      final Context context,\n      final String assetUrl) {\n    return new JSBundleLoader() {\n      @Override\n      public void loadScript(CatalystInstanceImpl instance) {\n        instance.loadScriptFromAssets(context.getAssets(), assetUrl);\n      }\n\n​```\n  @Override\n  public String getSourceUrl() {\n    return assetUrl;\n  }\n};\n  }\nnative void loadScriptFromAssets(AssetManager assetManager, String assetURL);\n1\nloadScriptFromAssets 既然是一个 native 方法，我们去 CatalystInstanceImpl.cpp 看下这个方法的实现，如下：\n\nvoid CatalystInstanceImpl::loadScriptFromAssets(jobject assetManager,\n                                                const std::string& assetURL) {\n  const int kAssetsLength = 9;  // strlen(\"assets://\");\n  //获取source路径名，不计前缀，这里默认就是index.android.bundle\n  auto sourceURL = assetURL.substr(kAssetsLength);\n    //assetManager是Java传递的AssetManager。\n    //extractAssetManager是JSLoader.cpp中通过系统动态链接库android/asset_manager_jni.h的AAssetManager_fromJava方法来获取AAssetManager对象的。\n  auto manager = react::extractAssetManager(assetManager);\n    //通过JSLoader对象的loadScriptFromAssets方法读文件，得到大字符串script（即index.android.bundle文件的JS内容）。\n  auto script = react::loadScriptFromAssets(manager, sourceURL);\n    //判断是不是Unbundle，这里不是Unbundle，因为打包命令我们用了react.gradle的默认bundle，没用unbundle命令（感兴趣的自己分析这条路线）。\n  if (JniJSModulesUnbundle::isUnbundle(manager, sourceURL)) {\n    instance_->loadUnbundle(\n      folly::make_unique<JniJSModulesUnbundle>(manager, sourceURL),\n      std::move(script),\n      sourceURL);\n    return;\n  } else {\n    //bundle命令打包的，所以走这里。\n    //instance_为ReactCommon目录下 Instance.h 中类的实例，前面分析过了。\n    instance_->loadScriptFromString(std::move(script), sourceURL);\n  }\n}\nprivate void setupReactContext(final ReactApplicationContext reactContext) {\n\n    //Initialize all the native modules\n    catalystInstance.initialize();\n    //重置devSupportManager中的reactContext\n    mDevSupportManager.onNewReactContextCreated(reactContext);\n    mMemoryPressureRouter.addMemoryPressureListener(catalystInstance);\n    //置位生命周期\n    moveReactContextToCurrentLifecycleState();\n// 核心方法\n    synchronized (mAttachedRootViews) {\n      for (ReactRootView rootView : mAttachedRootViews) {\n        attachRootViewToInstance(rootView, catalystInstance);\n      }\n    }\n// 通知UI更新\n    UiThreadUtil.runOnUiThread(\n        new Runnable() {\n          @Override\n          public void run() {\n            for (ReactInstanceEventListener listener : finalListeners) {\n              listener.onReactContextInitialized(reactContext);\n            }\n          }\n        });\n    // 开启JS消息队列线程\n    reactContext.runOnJSQueueThread(\n        new Runnable() {\n          @Override\n          public void run() {\n            Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);\n          }\n        });\n    //开启Native消息队列线程\n    reactContext.runOnNativeModulesQueueThread(\n        new Runnable() {\n          @Override\n          public void run() {\n            Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);\n          }\n        });\n  }\n\n  private void attachRootViewToInstance(\n      final ReactRootView rootView,\n      CatalystInstance catalystInstance) {\n       //通过UIManagerModule设置根布局为ReactRootView\n    UIManagerModule uiManagerModule = catalystInstance.getNativeModule(UIManagerModule.class);\n        //设置相关tag\n    final int rootTag = uiManagerModule.addRootView(rootView);\n    rootView.setRootViewTag(rootTag);\n      //Calls into JS to start the React application. \n    rootView.invokeJSEntryPoint();\n    ......\n    UiThreadUtil.runOnUiThread(new Runnable() {\n      @Override\n      public void run() {\n        //\n        rootView.onAttachedToReactInstance();\n      }\n    });\n  }\n/**\n   * Calls the default entry point into JS which is AppRegistry.runApplication()\n   */\n  private void defaultJSEntryPoint() {\n      try {\n        if (mReactInstanceManager == null || !mIsAttachedToInstance) {\n          return;\n        }\n        ReactContext reactContext = mReactInstanceManager.getCurrentReactContext();\n        if (reactContext == null) {\n          return;\n        }\n        CatalystInstance catalystInstance = reactContext.getCatalystInstance();\n          // 包装相关参数，传给js，rootTag用来告诉js端对应的是native 端哪一个view\n        WritableNativeMap appParams = new WritableNativeMap();\n        appParams.putDouble(\"rootTag\", getRootViewTag());\n        @Nullable Bundle appProperties = getAppProperties();\n        if (appProperties != null) {\n          appParams.putMap(\"initialProps\", Arguments.fromBundle(appProperties));\n        }\n        ....\n        //核心！！！ReactNative真正的启动流程就是在这里被调用起来的\n        String jsAppModuleName = getJSModuleName();\n        catalystInstance.getJSModule(AppRegistry.class).runApplication(jsAppModuleName, appParams);\n      } finally {\n        Systrace.endSection(TRACE_TAG_REACT_JAVA_BRIDGE);\n      }\n  }\n\n//`AppRegistry` is the JS entry point to running all React Native apps.  App\n// root components should register themselves with\nvar AppRegistry = {\n    ......\n    //我们JS端自己在index.android.js文件中调用的入口就是：\n    //AppRegistry.registerComponent('TestRN', () => TestRN);\n  registerComponent: function(appKey: string, getComponentFunc: ComponentProvider): string {\n    runnables[appKey] = {\n      run: (appParameters) =>\n        renderApplication(getComponentFunc(), appParameters.initialProps, appParameters.rootTag)\n    };\n    return appKey;\n  },\n    ......\n    //上面java端 AppRegistry 调用的 JS 端就是这个方法，索引到我们设置的appkey=TestRN字符串的JS入口\n  runApplication: function(appKey: string, appParameters: any): void {\n    ......\n    runnables[appKey].run(appParameters);\n  },\n    ......\n};\n\n```\n\n## 小结\n\n到这里ReactNative的启动流程就差不多了，我们小梳理总结，如下图：\n\n![img](https://i.loli.net/2018/11/18/5bf0e39e53802.jpg)上面这幅图已经囊括了我们上面说到的启动流程的全部流程分析","slug":"react_native/ReactNative启动流程","published":1,"updated":"2021-07-04T07:15:28.830Z","_id":"ckqou4ee800017mmz5rna4a3b","comments":1,"photos":[],"link":"","content":"<h1 id=\"ReactNative-启动流程\"><a href=\"#ReactNative-启动流程\" class=\"headerlink\" title=\"ReactNative-启动流程\"></a>ReactNative-启动流程</h1><h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>ReactNative在真机iOS和Android上，使用的是<strong>JavaScriptCore</strong>引擎，也就是Safari所使用的JavaScript引擎。但是在iOS上JavaScriptCore并没有使用即时编译技术（JIT），因为在iOS中应用无权拥有可写可执行的内存页（因而无法动态生成代码），在安卓上，理论上是可以使用的。JavaScriptCore引擎也是使用C++编写，在iOS和安卓中，JavaScriptCore都做了一层封装，可以无须关心引擎和系统桥接的那一层。iOS/Android系统通JavaScriptCore引擎将定制好的各种原生组件注入。我们编写少量Java代码大量JavaScript代码，中间作为桥梁的核心是 C/C++ 来处理的。</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2018/png/199077/1542525129415-a4873dbe-d967-4554-a866-aa6a275c2594.png\" alt=\"img\"></p>\n<h2 id=\"RN-启动流程框架浅析\"><a href=\"#RN-启动流程框架浅析\" class=\"headerlink\" title=\"RN 启动流程框架浅析\"></a>RN 启动流程框架浅析</h2><p>集成 RN 无非就是通过继承 ReactActivity 或者自己通过 ReactRootView 进行处理，但是实质都是触发了ReactRootView 的 startReactApplication 方法</p>\n<ul>\n<li>ReactActivity</li>\n</ul>\n<p>先来看看ReactActivity,明显的代理模式，实际操作全部交给了ReactActivityDelegate</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs typescript\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ReactActivity</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Activity</span></span><br><span class=\"hljs-class\">    <span class=\"hljs-title\">implements</span> <span class=\"hljs-title\">DefaultHardwareBackBtnHandler</span>, <span class=\"hljs-title\">PermissionAwareActivity</span> </span>&#123;<br>  <span class=\"hljs-keyword\">private</span> final ReactActivityDelegate mDelegate;<br>  <span class=\"hljs-keyword\">protected</span> <span class=\"hljs-function\"><span class=\"hljs-title\">ReactActivity</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    mDelegate = createReactActivityDelegate();<br>  &#125; <br>  <span class=\"hljs-meta\">@Override</span><br>  <span class=\"hljs-keyword\">protected</span> <span class=\"hljs-built_in\">void</span> <span class=\"hljs-function\"><span class=\"hljs-title\">onCreate</span>(<span class=\"hljs-params\">Bundle savedInstanceState</span>)</span> &#123;<br>    <span class=\"hljs-built_in\">super</span>.onCreate(savedInstanceState);<br>    mDelegate.onCreate(savedInstanceState);<br>  &#125;<br>  <span class=\"hljs-meta\">@Override</span><br>  <span class=\"hljs-keyword\">protected</span> <span class=\"hljs-built_in\">void</span> <span class=\"hljs-function\"><span class=\"hljs-title\">onPause</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-built_in\">super</span>.onPause();<br>    mDelegate.onPause();<br>  &#125;<br>  <span class=\"hljs-meta\">@Override</span><br>  <span class=\"hljs-keyword\">protected</span> <span class=\"hljs-built_in\">void</span> <span class=\"hljs-function\"><span class=\"hljs-title\">onResume</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-built_in\">super</span>.onResume();<br>    mDelegate.onResume();<br>  &#125;<br>   ..........<br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<ul>\n<li>ReactActivityDelegate</li>\n</ul>\n<p>再来看看ReactActivityDelegate,可以看见，ReactActivityDelegate 只是一个抽出来的封装，上面的实质就是 new 了一个 ReactRootView（实质是 Android 的 FrameLayout），接着调用 ReactRootView 的 startReactApplication 方法，完事就像常规 Android 代码一样直接通过 Activity 的 setContentView 方法把 View 设置进去。所以可以看出来，RN 的神秘之处一定在于 ReactRootView 中，Activity 对于 RN 来说只是为了让 RN 依附符合 Android 的框架而已，所以说，说白了 RN 依旧是标准 Android，因此在我们集成开发中我们可以选择整个界面（包含多级跳转）都用 React Native 实现，或者一个 Android 现有界面中部分采用 React Native 实现，因为这货就是一个 View.</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs typescript\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ReactActivityDelegate</span> </span>&#123;<br><br>  <span class=\"hljs-keyword\">protected</span> <span class=\"hljs-built_in\">void</span> <span class=\"hljs-function\"><span class=\"hljs-title\">onCreate</span>(<span class=\"hljs-params\">Bundle savedInstanceState</span>)</span> &#123;<br>    <span class=\"hljs-comment\">//启动流程一定会执行的，mMainComponentName为我们设置的，与JS边保持一致</span><br>    <span class=\"hljs-keyword\">if</span> (mMainComponentName != <span class=\"hljs-literal\">null</span>) &#123;<br>      loadApp(mMainComponentName);<br>    &#125;<br>    mDoubleTapReloadRecognizer = <span class=\"hljs-keyword\">new</span> DoubleTapReloadRecognizer();<br>  &#125;<br><br>  <span class=\"hljs-keyword\">protected</span> <span class=\"hljs-built_in\">void</span> <span class=\"hljs-function\"><span class=\"hljs-title\">loadApp</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">String</span> appKey</span>)</span> &#123;<br>    <span class=\"hljs-keyword\">if</span> (mReactRootView != <span class=\"hljs-literal\">null</span>) &#123;<br>      <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IllegalStateException(<span class=\"hljs-string\">&quot;Cannot loadApp while app is already running.&quot;</span>);<br>    &#125;<br>    <span class=\"hljs-comment\">// createRootView其实就是create了一个FrameLayout，核心方法 </span><br>    mReactRootView = createRootView();<br>    mReactRootView.startReactApplication(<br>      getReactNativeHost().getReactInstanceManager(),<br>      appKey,<br>      getLaunchOptions());<br>    <span class=\"hljs-comment\">// 把view设置进Activity</span><br>    getPlainActivity().setContentView(mReactRootView);<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<ul>\n<li>ReactRootView</li>\n</ul>\n<p>既然明白了 RN 就是个 View，那就接着看看 ReactRootView，如下：</p>\n<p>可以看见，ReactRootView的英文注释已经交代很清楚用途和地位了，直接看上面代码的startReactApplication 方法，可以看见他又调用了一个三个参数的同名方法，具体这三个参数来历如下（也是我们自己集成 RN 时手动 builder 模式创建的）：</p>\n<ol>\n<li><p>reactInstanceManager： 大内总管接口类，提供一个构造者模式的初始化 Builder, 这类也是我们在集成 RN 时 new ReactRootView 的之前自己创建的。 </p>\n</li>\n<li><p>moduleName： 与 JS 代码约定的 String 类型识别 name，JS 端通过 AppRegistry.registerComponent 方法设置这个 name，Java 端重写基类的 getMainComponentName 方法设置这个 name，这样两边入口就对上了。 </p>\n</li>\n<li><p>launchOptions： 这里默认是 null 的，如果自己不继承 ReactActivity 而自己实现的话可以通过这个参数在 startActivity 时传入一些参数到 JS 代码，用来依据参数初始化 JS 端代码。</p>\n</li>\n</ol>\n<p>可以看见接着调用了 mReactInstanceManager createReactContextInBackground 方法，mReactInstanceManager 就是上面说的第一个参数，实质是通过一个构造者模式创建的</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs scala\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> React Native 的 RootView，负责监听标准 Android 的 View 相关的事件分发和子View 渲染等。</span><br><span class=\"hljs-comment\"> */</span><br>public <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ReactRootView</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">SizeMonitoringFrameLayout</span> <span class=\"hljs-title\">implements</span> <span class=\"hljs-title\">RootView</span> </span>&#123;<br>  public void startReactApplication(<span class=\"hljs-type\">ReactInstanceManager</span> reactInstanceManager, <span class=\"hljs-type\">String</span> moduleName) &#123;<br>    startReactApplication(reactInstanceManager, moduleName, <span class=\"hljs-literal\">null</span>);<br>  &#125;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">调度react component的渲染，使用reactInstanceManager讲js模块attch到JS Context中。一些初始化参数可以通过launchOptions传递给react component</span><br><span class=\"hljs-comment\">*/</span><br>  public void startReactApplication(<br>      <span class=\"hljs-type\">ReactInstanceManager</span> reactInstanceManager,<br>      <span class=\"hljs-type\">String</span> moduleName,<br>      <span class=\"hljs-meta\">@Nullable</span> <span class=\"hljs-type\">Bundle</span> initialProperties) &#123;<br>    <span class=\"hljs-type\">Systrace</span>.beginSection(<span class=\"hljs-type\">TRACE_TAG_REACT_JAVA_BRIDGE</span>, <span class=\"hljs-string\">&quot;startReactApplication&quot;</span>);<br>    <span class=\"hljs-keyword\">try</span> &#123;<br>      <span class=\"hljs-type\">UiThreadUtil</span>.assertOnUiThread();<br>      <span class=\"hljs-type\">Assertions</span>.assertCondition(<br>        mReactInstanceManager == <span class=\"hljs-literal\">null</span>,<br>        <span class=\"hljs-string\">&quot;This root view has already been attached to a catalyst instance manager&quot;</span>);<br>      mReactInstanceManager = reactInstanceManager;<br>      mJSModuleName = moduleName;<br>      mAppProperties = initialProperties;<br>      <span class=\"hljs-comment\">// 核心创建ReactContext，先判断是否初始化了</span><br>      <span class=\"hljs-keyword\">if</span> (!mReactInstanceManager.hasStartedCreatingInitialContext()) &#123;<br>        mReactInstanceManager.createReactContextInBackground();<br>      &#125;<br>      attachToReactInstanceManager();<br>    &#125; <span class=\"hljs-keyword\">finally</span> &#123;<br>      <span class=\"hljs-type\">Systrace</span>.endSection(<span class=\"hljs-type\">TRACE_TAG_REACT_JAVA_BRIDGE</span>);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>\n\n<ul>\n<li>ReactInstanceManager</li>\n</ul>\n<p>ReactInstanceManager的createReactContextInBackground 方法看看，如下：</p>\n<p>可以看到createReactContext经过一系列的包装，最终开启了一个新线程去创建ReactContext,先从initParams中获取JavaScriptExecutor和JsBundleLoader，JsBundleLoader负责JsBundle的加载，实际情况中我们可以修改加载起实现热更新。开始创建后，有几个核心方法createReactContext和setupReactContext，接下来我们来看看createReactContext:</p>\n<p>总的来说，createReactContext()把nativeModules注册到CatalysInstanceImpl里,然后把这两张映射表交给 CatalystInstanceImpl，同时包装创建 ReactContext 对象，然后通过 CatalystInstanceImpl 的 runJSBundle() 方法把 JS bundle 文件的 JS 代码加载进来等待 Task 结束以后调用 JS 入口进行渲染 RN。CatalystInstanceImpl 的 build 方法中调用的 CatalystInstanceImpl 构造方法到底干了什么</p>\n<p>build()中其实就是构造者模式，实例化CatalystInstanceImpl, CatalystInstanceImpl 就是个封装总管，负责了 Java 层代码到 JNI 封装初始化的任务和 Java 与 JS 调用的 Java 端控制中心。核心方法是initializeBridge,这是个native方法，我们看看他穿了什么参数进去：</p>\n<ol>\n<li><p>ReactCallBack是CatalystInstanceImpl 的内部静态实现类 BridgeCallback，负责相关接口回传和回</p>\n</li>\n<li><p>jsExecutor参数： 前面分析的 XReactInstanceManagerImpl 中赋值为 JSCJavaScriptExecutor 实例，JSCJavaScriptExecutor 中也有自己的 native initHybrid 的 C++ 方法被初始化时调用，具体在 OnLoad.cpp 的 JSCJavaScriptExecutorHolder 类中。 </p>\n</li>\n<li><p>jsQueue参数： 来自于 mReactQueueConfiguration.getJSQueueThread()，mReactQueueConfiguration就是 CatalystInstanceImpl 中创建的 ReactQueueConfigurationImpl.create( ReactQueueConfigurationSpec, new NativeExceptionHandler()); 第一个参数来自于 XReactInstanceManagerImpl 中 CatalystInstanceImpl 的建造者，实质为包装相关线程名字、类型等，然后通过 ReactQueueConfigurationImpl 的 create 创建对应线程的 Handler，这里就是名字为 js 的后台线程 Handler，第二个参数为异常捕获回调实现。 </p>\n</li>\n<li><p>moduleQueue参数： 来自于 mReactQueueConfiguration.getNativeModulesQueueThread（）mReactQueueConfiguration同上</p>\n</li>\n<li><p>javaModules: 来自mNativeModuleRegistry.getJavaModules(this),mNativeModuleRegistry就是构建CatalysInstanceImpl时传入的javaModules。</p>\n</li>\n<li><p>cxxModules：来自mNativeModuleRegistry.getCxxModules(),mNativeModuleRegistry就是构建CatalysInstanceImpl时传入的javaModules，获取c++模块</p>\n</li>\n</ol>\n<p>CatalystInstanceImpl 自己在 Java 层直接把持住了 JavaScriptModuleRegistry 映射表，把 NativeModuleRegistry 映射表、BridgeCallback 回调、JSCJavaScriptExecutor、js 队列 MessageQueueThread、native 队列 MessageQueueThread 都通过 JNI 嫁接到了 C++ 中。那我们现在先把目光转移到 CatalystInstanceImpl.cpp 的 initializeBridge 方法上（关于 JNI 的 OnLoad 中初始化注册模块等等就不介绍了），如下：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs typescript\"> <span class=\"hljs-meta\">@ThreadConfined</span>(UI)<br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-built_in\">void</span> <span class=\"hljs-function\"><span class=\"hljs-title\">recreateReactContextInBackground</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>   Assertions.assertCondition(<br>       mHasStartedCreatingInitialContext,<br>       <span class=\"hljs-string\">&quot;recreateReactContextInBackground should only be called after the initial &quot;</span> +<br>           <span class=\"hljs-string\">&quot;createReactContextInBackground call.&quot;</span>);<br>   recreateReactContextInBackgroundInner();<br> &#125;<br><br><span class=\"hljs-meta\">@ThreadConfined</span>(UI)<br> <span class=\"hljs-keyword\">private</span> <span class=\"hljs-built_in\">void</span> <span class=\"hljs-function\"><span class=\"hljs-title\">recreateReactContextInBackgroundInner</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>   <span class=\"hljs-keyword\">if</span> (mUseDeveloperSupport<br>       &amp;&amp; mJSMainModulePath != <span class=\"hljs-literal\">null</span><br>       &amp;&amp; !Systrace.isTracing(TRACE_TAG_REACT_APPS | TRACE_TAG_REACT_JS_VM_CALLS)) &#123;<br>     final DeveloperSettings devSettings = mDevSupportManager.getDevSettings();<br><br>     <span class=\"hljs-comment\">// If remote JS debugging is enabled, load from dev server.</span><br>     <span class=\"hljs-keyword\">if</span> (mDevSupportManager.hasUpToDateJSBundleInCache() &amp;&amp;<br>         !devSettings.isRemoteJSDebugEnabled()) &#123;<br>       <span class=\"hljs-comment\">// If there is a up-to-date bundle downloaded from server,</span><br>       <span class=\"hljs-comment\">// with remote JS debugging disabled, always use that.</span><br>       ........<br>     <span class=\"hljs-keyword\">return</span>;<br>   &#125;<br>    <span class=\"hljs-comment\">//非调试模式，真实环境下去加载Bundle</span><br>   recreateReactContextInBackgroundFromBundleLoader();<br> &#125;<br>     <br> <span class=\"hljs-keyword\">public</span> <span class=\"hljs-built_in\">void</span> <span class=\"hljs-function\"><span class=\"hljs-title\">createReactContextInBackground</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>   ......<br>   recreateReactContextInBackgroundInner();<br> &#125;<br><br> <span class=\"hljs-keyword\">private</span> <span class=\"hljs-built_in\">void</span> <span class=\"hljs-function\"><span class=\"hljs-title\">recreateReactContextInBackgroundInner</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>   UiThreadUtil.assertOnUiThread();<br>   <br>   <span class=\"hljs-keyword\">if</span> (mUseDeveloperSupport &amp;&amp; mJSMainModuleName != <span class=\"hljs-literal\">null</span>) &#123;<br>   <span class=\"hljs-comment\">//如果是 dev 模式，BuildConfig.DEBUG=true就走这里，在线更新bundle，手机晃动出现调试菜单等等。</span><br>   <span class=\"hljs-comment\">//这个路线属于RN调试流程原理，后面再写文章分析，这里我们抓住主线分析</span><br> ......<br> <span class=\"hljs-keyword\">return</span>;<br>&#125;<br>    <span class=\"hljs-comment\">//非调试模式，即BuildConfig.DEBUG=false时执行</span><br>    recreateReactContextInBackgroundFromBundleLoader();<br>&#125;<br><br><span class=\"hljs-keyword\">private</span> <span class=\"hljs-built_in\">void</span> <span class=\"hljs-function\"><span class=\"hljs-title\">recreateReactContextInBackgroundFromBundleLoader</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>   <span class=\"hljs-comment\">//在后台创建ReactContext，两个参数是重点。</span><br>   <span class=\"hljs-comment\">//包装了JavaScript执行上下文的JavaScriptExecutorFactory</span><br>   <span class=\"hljs-comment\">//自定义热更新时setJSBundleFile方法参数就是巧妙的利用这里是走JSBundleLoader.createAssetLoader还是JSBundleLoader.createFileLoader！！！！！！</span><br>     recreateReactContextInBackground(mJavaScriptExecutorFactory, mBundleLoader);<br>&#125;<br><br><span class=\"hljs-meta\">@ThreadConfined</span>(UI)<br> <span class=\"hljs-keyword\">private</span> <span class=\"hljs-built_in\">void</span> <span class=\"hljs-function\"><span class=\"hljs-title\">recreateReactContextInBackground</span>(<span class=\"hljs-params\"></span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">   JavaScriptExecutorFactory jsExecutorFactory,</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">   JSBundleLoader jsBundleLoader</span>)</span> &#123;<br>     <span class=\"hljs-comment\">//包装一下JsExecutorFactor</span><br>   final ReactContextInitParams initParams = <span class=\"hljs-keyword\">new</span> ReactContextInitParams(<br>     jsExecutorFactory,<br>     jsBundleLoader);<br>     <span class=\"hljs-comment\">// 开线程差创建ReactContext</span><br>   <span class=\"hljs-keyword\">if</span> (mCreateReactContextThread == <span class=\"hljs-literal\">null</span>) &#123;<br>     runCreateReactContextOnNewThread(initParams);<br>   &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>     mPendingReactContextInitParams = initParams;<br>   &#125;<br> &#125;<br><br> <span class=\"hljs-meta\">@ThreadConfined</span>(UI)<br> <span class=\"hljs-keyword\">private</span> <span class=\"hljs-built_in\">void</span> <span class=\"hljs-function\"><span class=\"hljs-title\">runCreateReactContextOnNewThread</span>(<span class=\"hljs-params\">final ReactContextInitParams initParams</span>)</span> &#123;<br>   .....<br>   <span class=\"hljs-comment\">//开线程创建ReactContext</span><br>   mCreateReactContextThread =<br>       <span class=\"hljs-keyword\">new</span> Thread(<br>           <span class=\"hljs-keyword\">new</span> <span class=\"hljs-function\"><span class=\"hljs-title\">Runnable</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>             <span class=\"hljs-meta\">@Override</span><br>             <span class=\"hljs-keyword\">public</span> <span class=\"hljs-built_in\">void</span> <span class=\"hljs-function\"><span class=\"hljs-title\">run</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>           .....<br>               <span class=\"hljs-keyword\">try</span> &#123;<br>                 Process.setThreadPriority(Process.THREAD_PRIORITY_DISPLAY);<br>                 <span class=\"hljs-comment\">//创建ReactContext的核心方法，createReactContext</span><br>                 final ReactApplicationContext reactApplicationContext =<br>                     createReactContext(<br>                         initParams.getJsExecutorFactory().create(),<br>                         initParams.getJsBundleLoader());<br><br>                 mCreateReactContextThread = <span class=\"hljs-literal\">null</span>;<br>                 <br>                 final Runnable maybeRecreateReactContextRunnable =<br>                     <span class=\"hljs-keyword\">new</span> <span class=\"hljs-function\"><span class=\"hljs-title\">Runnable</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>                       <span class=\"hljs-meta\">@Override</span><br>                       <span class=\"hljs-keyword\">public</span> <span class=\"hljs-built_in\">void</span> <span class=\"hljs-function\"><span class=\"hljs-title\">run</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>                         <span class=\"hljs-keyword\">if</span> (mPendingReactContextInitParams != <span class=\"hljs-literal\">null</span>) &#123;<br>                           runCreateReactContextOnNewThread(mPendingReactContextInitParams);<br>                           mPendingReactContextInitParams = <span class=\"hljs-literal\">null</span>;<br>                         &#125;<br>                       &#125;<br>                 &#125;;<br>                 Runnable setupReactContextRunnable =<br>                     <span class=\"hljs-keyword\">new</span> <span class=\"hljs-function\"><span class=\"hljs-title\">Runnable</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>                       <span class=\"hljs-meta\">@Override</span><br>                       <span class=\"hljs-keyword\">public</span> <span class=\"hljs-built_in\">void</span> <span class=\"hljs-function\"><span class=\"hljs-title\">run</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>                         <span class=\"hljs-keyword\">try</span> &#123;<br>                           setupReactContext(reactApplicationContext);<br>                         &#125; <span class=\"hljs-keyword\">catch</span> (Exception e) &#123;<br>                           mDevSupportManager.handleException(e);<br>                         &#125;<br>                       &#125;<br>                  &#125;;<br>        reactApplicationContext.runOnNativeModulesQueueThread(setupReactContextRunnable);<br>                 UiThreadUtil.runOnUiThread(maybeRecreateReactContextRunnable);<br>               &#125; <span class=\"hljs-keyword\">catch</span> (Exception e) &#123;<br>                 mDevSupportManager.handleException(e);<br>               &#125;<br>             &#125;<br>           &#125;);<br>   mCreateReactContextThread.start();<br> &#125;<br>  <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">   * <span class=\"hljs-doctag\">@return </span>instance of &#123;<span class=\"hljs-doctag\">@link </span>ReactContext&#125; configured a &#123;<span class=\"hljs-doctag\">@link </span>CatalystInstance&#125; set</span><br><span class=\"hljs-comment\">   */</span><br>  <span class=\"hljs-keyword\">private</span> ReactApplicationContext <span class=\"hljs-function\"><span class=\"hljs-title\">createReactContext</span>(<span class=\"hljs-params\"></span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">      JavaScriptExecutor jsExecutor,</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">      JSBundleLoader jsBundleLoader</span>)</span> &#123;<br>    final ReactApplicationContext reactContext = <span class=\"hljs-keyword\">new</span> ReactApplicationContext(mApplicationContext);<br><span class=\"hljs-comment\">// 是否处于开发者模式，提供一些异常处理的机制，捕获崩溃显示在红色弹窗</span><br>    <span class=\"hljs-keyword\">if</span> (mUseDeveloperSupport) &#123;<br>      reactContext.setNativeModuleCallExceptionHandler(mDevSupportManager);<br>    &#125;<br><span class=\"hljs-comment\">// Java层模块注册表，通过它把NativeModules注册到CatalystInstance.包括我们自定义的继承自NativeModule的Java代码</span><br>    NativeModuleRegistry nativeModuleRegistry = processPackages(reactContext, mPackages, <span class=\"hljs-literal\">false</span>);<br><span class=\"hljs-comment\">// 异常处理Handler</span><br>      NativeModuleCallExceptionHandler exceptionHandler = mNativeModuleCallExceptionHandler != <span class=\"hljs-literal\">null</span><br>      ? mNativeModuleCallExceptionHandler<br>      : mDevSupportManager;<br><span class=\"hljs-comment\">// 开始构建CatalystInstance </span><br>    CatalystInstanceImpl.Builder catalystInstanceBuilder = <span class=\"hljs-keyword\">new</span> CatalystInstanceImpl.Builder()<br>      .setReactQueueConfigurationSpec(ReactQueueConfigurationSpec.createDefault())<br>      .setJSExecutor(jsExecutor)<br>      .setRegistry(nativeModuleRegistry)<br>      .setJSBundleLoader(jsBundleLoader)<br>      .setNativeModuleCallExceptionHandler(exceptionHandler);<br>    ........<br>    catalystInstance.runJSBundle();<br>    reactContext.initializeWithInstance(catalystInstance);<br><br>    <span class=\"hljs-keyword\">return</span> reactContext;<br>  &#125;<br><span class=\"hljs-keyword\">private</span> <span class=\"hljs-function\"><span class=\"hljs-title\">CatalystInstanceImpl</span>(<span class=\"hljs-params\"></span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">      final ReactQueueConfigurationSpec reactQueueConfigurationSpec,</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">      final JavaScriptExecutor jsExecutor,</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">      final NativeModuleRegistry nativeModuleRegistry,</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">      final JSBundleLoader jsBundleLoader,</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">      NativeModuleCallExceptionHandler nativeModuleCallExceptionHandler</span>)</span> &#123;<br>    Log.d(ReactConstants.TAG, <span class=\"hljs-string\">&quot;Initializing React Xplat Bridge.&quot;</span>);<br>    mHybridData = initHybrid();<br><br>    mReactQueueConfiguration = ReactQueueConfigurationImpl.create(<br>        reactQueueConfigurationSpec,<br>        <span class=\"hljs-keyword\">new</span> NativeExceptionHandler());<br>    mBridgeIdleListeners = <span class=\"hljs-keyword\">new</span> CopyOnWriteArrayList&lt;&gt;();<br>    mNativeModuleRegistry = nativeModuleRegistry;<br>    mJSModuleRegistry = <span class=\"hljs-keyword\">new</span> JavaScriptModuleRegistry();<br>    mJSBundleLoader = jsBundleLoader;<br>    mNativeModuleCallExceptionHandler = nativeModuleCallExceptionHandler;<br>    mNativeModulesQueueThread = mReactQueueConfiguration.getNativeModulesQueueThread();<br>    mTraceListener = <span class=\"hljs-keyword\">new</span> JSProfilerTraceListener(<span class=\"hljs-built_in\">this</span>);<br><br>    Log.d(ReactConstants.TAG, <span class=\"hljs-string\">&quot;Initializing React Xplat Bridge before initializeBridge&quot;</span>);<br>    initializeBridge(<br>      <span class=\"hljs-keyword\">new</span> BridgeCallback(<span class=\"hljs-built_in\">this</span>),<br>      jsExecutor,<br>      mReactQueueConfiguration.getJSQueueThread(),<br>      mNativeModulesQueueThread,<br>      mNativeModuleRegistry.getJavaModules(<span class=\"hljs-built_in\">this</span>),<br>      mNativeModuleRegistry.getCxxModules());<br>    Log.d(ReactConstants.TAG, <span class=\"hljs-string\">&quot;Initializing React Xplat Bridge after initializeBridge&quot;</span>);<br><br>    mJavaScriptContextHolder = <span class=\"hljs-keyword\">new</span> JavaScriptContextHolder(getJavaScriptContext());<br>  &#125;<br>  <br>    <span class=\"hljs-keyword\">private</span> native <span class=\"hljs-built_in\">void</span> initializeBridge(<br>      ReactCallback callback,<br>      JavaScriptExecutor jsExecutor,<br>      MessageQueueThread jsQueue,<br>      MessageQueueThread moduleQueue,<br>      Collection&lt;JavaModuleWrapper&gt; javaModules,<br>      Collection&lt;ModuleHolder&gt; cxxModules);<br></code></pre></div></td></tr></table></figure>\n\n<ul>\n<li>CatalystInstance</li>\n</ul>\n<p>到此 CatalystInstance 的实例 CatalystInstanceImpl 对象也就初始化 OK 了，同时通过 initializeBridge 建立了 Bridge 连接。关于这个 Bridge 在RN 中是通过 libjsc.so 中 JSObjectRef.h 的 JSObjectSetProperty(m_context, globalObject, jsPropertyName, valueToInject, 0, NULL); 来关联的，这样就可以在 Native 设置 JS 执行，反之同理。</p>\n<p>这一小节我们只讨论 RN 的加载启动流程，所以 initializeBridge 的具体实现我们下面分析互相通信交互时再仔细分析，故我们先把思路还是回到 XReactInstanceManagerImpl 中 createReactContext 方法的 reactContext.initializeWithInstance(catalystInstance); 一行，可以看见，这行代码意思就是将刚刚初始化的 catalystInstance 传递给全局唯一的 reactContext 对象，同时在 reactContext 中通过 catalystInstance 拿到 JS、Native、UI 几个 Thread 的引用，方便快速访问使用这些对象。接着调用了 catalystInstance.runJSBundle(); 方法，这个方法实现如下：</p>\n<p>通过注释我们假设 Loader 是默认的，也即 JSBundleLoader 类的如下方法：</p>\n<p>可以看见，它实质又调用了 CatalystInstanceImpl 的 loadScriptFromAssets 方法，我们继续跟踪 CatalystInstanceImpl 的这个方法吧，如下：</p>\n<p>说白了就是 CatalystInstanceImpl.java 中 CatalystInstanceImpl 构造方法中调用 C++ 的 initializeBridge 方法时传入的第一个参数 BridgeCallback 么，就是说 JS bundle 文件被加载完成以后 JS 端调用 Java 端时会触发 Callback 的 onBatchComplete 方法，这货最终又会触发 OnBatchCompleteListener 接口的 onBatchComplete 方法，这不就把 JS Bundle 文件加载完成以后回调 Java 通知 OK 了么。最后我们还差一个runCreateContextOnNewThread中的setupReactContext任务还没分析，方法如下：</p>\n<p>这里的核心在rootView.invokeJsEntryPoint(),追踪一下源码，发现最后调用了如下方法</p>\n<p>我们知道 AppRegistry.class 是 JS 端暴露给 Java 端的接口方法，所以catalystInstance.getJSModule(AppRegistry.class) 实质就桥接到 JS 端代码去了，那就去看看AppRegistry中写了写啥</p>\n<p>到这里ReactNative的启动终于到头了，但react-native还有很多细节，这里先介绍React’Native的启动流程，搭建去Bridge，至于通信方式在后面继续介绍。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs php\"><span class=\"hljs-keyword\">void</span> CatalystInstanceImpl::initializeBridge(<br>    jni::alias_ref&lt;ReactCallback::javaobject&gt; callback,<br>    <span class=\"hljs-comment\">// This executor is actually a factory holder.</span><br>    JavaScriptExecutorHolder* jseh,<br>    jni::alias_ref&lt;JavaMessageQueueThread::javaobject&gt; jsQueue,<br>    jni::alias_ref&lt;JavaMessageQueueThread::javaobject&gt; moduleQueue,<br>    ModuleRegistryHolder* mrh) &#123;<br>    ......<br>  <span class=\"hljs-comment\">// Java CatalystInstanceImpl -&gt; C++ CatalystInstanceImpl -&gt; Bridge -&gt; Bridge::Callback</span><br>  <span class=\"hljs-comment\">// --weak--&gt; ReactCallback -&gt; Java CatalystInstanceImpl</span><br>    ......<br>    <span class=\"hljs-comment\">//instance_为ReactCommon目录下 Instance.h 中类的实例；</span><br>    <span class=\"hljs-comment\">//第一个参数为JInstanceCallback实现类，父类在cxxreact/Instance.h中。</span><br>    <span class=\"hljs-comment\">//第二个参数为JavaScriptExecutorHolder，实质对应java中JavaScriptExecutor，也就是上面分析java的initializeBridge方法第二个参数JSCJavaScriptExecutor。</span><br>    <span class=\"hljs-comment\">//第三第四个参数都是java线程透传到C++，纯C++的JMessageQueueThread。</span><br>    <span class=\"hljs-comment\">//第五个参数为C++的ModuleRegistryHolder的getModuleRegistry()方法。</span><br>  instance_-&gt;initializeBridge(folly::make_unique&lt;JInstanceCallback&gt;(callback),<br>                              jseh-&gt;getExecutorFactory(),<br>                              folly::make_unique&lt;JMessageQueueThread&gt;(jsQueue),<br>                              folly::make_unique&lt;JMessageQueueThread&gt;(moduleQueue),<br>                              mrh-&gt;getModuleRegistry());<br>&#125;<br>@Override<br>  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> runJSBundle() &#123;<br>    ......<br>    mJSBundleHasLoaded = <span class=\"hljs-literal\">true</span>;<br>    <span class=\"hljs-comment\">//mJSBundleLoader就是前面分析的依据不同设置决定是JSBundleLoader的createAssetLoader还是createFileLoader等静态方法的匿名实现类。</span><br>    <span class=\"hljs-comment\">// incrementPendingJSCalls();</span><br>    mJSBundleLoader.loadScript(CatalystInstanceImpl.this);<br>    ......<br>  &#125;<br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-built_in\">static</span> JSBundleLoader createAssetLoader(<br>      <span class=\"hljs-keyword\">final</span> Context context,<br>      <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">String</span> assetUrl) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> JSBundleLoader() &#123;<br>      @Override<br>      <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> loadScript(CatalystInstanceImpl instance) &#123;<br>        instance.loadScriptFromAssets(context.getAssets(), assetUrl);<br>      &#125;<br><br>​```<br>  @Override<br>  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">String</span> getSourceUrl() &#123;<br>    <span class=\"hljs-keyword\">return</span> assetUrl;<br>  &#125;<br>&#125;;<br>  &#125;<br>native <span class=\"hljs-keyword\">void</span> loadScriptFromAssets(AssetManager assetManager, <span class=\"hljs-keyword\">String</span> assetURL);<br><span class=\"hljs-number\">1</span><br>loadScriptFromAssets 既然是一个 native 方法，我们去 CatalystInstanceImpl.cpp 看下这个方法的实现，如下：<br><br><span class=\"hljs-keyword\">void</span> CatalystInstanceImpl::loadScriptFromAssets(jobject assetManager,<br>                                                <span class=\"hljs-keyword\">const</span> std::string&amp; assetURL) &#123;<br>  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">int</span> kAssetsLength = <span class=\"hljs-number\">9</span>;  <span class=\"hljs-comment\">// strlen(&quot;assets://&quot;);</span><br>  <span class=\"hljs-comment\">//获取source路径名，不计前缀，这里默认就是index.android.bundle</span><br>  auto sourceURL = assetURL.substr(kAssetsLength);<br>    <span class=\"hljs-comment\">//assetManager是Java传递的AssetManager。</span><br>    <span class=\"hljs-comment\">//extractAssetManager是JSLoader.cpp中通过系统动态链接库android/asset_manager_jni.h的AAssetManager_fromJava方法来获取AAssetManager对象的。</span><br>  auto manager = react::extractAssetManager(assetManager);<br>    <span class=\"hljs-comment\">//通过JSLoader对象的loadScriptFromAssets方法读文件，得到大字符串script（即index.android.bundle文件的JS内容）。</span><br>  auto script = react::loadScriptFromAssets(manager, sourceURL);<br>    <span class=\"hljs-comment\">//判断是不是Unbundle，这里不是Unbundle，因为打包命令我们用了react.gradle的默认bundle，没用unbundle命令（感兴趣的自己分析这条路线）。</span><br>  <span class=\"hljs-keyword\">if</span> (JniJSModulesUnbundle::isUnbundle(manager, sourceURL)) &#123;<br>    instance_-&gt;loadUnbundle(<br>      folly::make_unique&lt;JniJSModulesUnbundle&gt;(manager, sourceURL),<br>      std::move(script),<br>      sourceURL);<br>    <span class=\"hljs-keyword\">return</span>;<br>  &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>    <span class=\"hljs-comment\">//bundle命令打包的，所以走这里。</span><br>    <span class=\"hljs-comment\">//instance_为ReactCommon目录下 Instance.h 中类的实例，前面分析过了。</span><br>    instance_-&gt;loadScriptFromString(std::move(script), sourceURL);<br>  &#125;<br>&#125;<br><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> setupReactContext(<span class=\"hljs-keyword\">final</span> ReactApplicationContext reactContext) &#123;<br><br>    <span class=\"hljs-comment\">//Initialize all the native modules</span><br>    catalystInstance.initialize();<br>    <span class=\"hljs-comment\">//重置devSupportManager中的reactContext</span><br>    mDevSupportManager.onNewReactContextCreated(reactContext);<br>    mMemoryPressureRouter.addMemoryPressureListener(catalystInstance);<br>    <span class=\"hljs-comment\">//置位生命周期</span><br>    moveReactContextToCurrentLifecycleState();<br><span class=\"hljs-comment\">// 核心方法</span><br>    synchronized (mAttachedRootViews) &#123;<br>      <span class=\"hljs-keyword\">for</span> (ReactRootView rootView : mAttachedRootViews) &#123;<br>        attachRootViewToInstance(rootView, catalystInstance);<br>      &#125;<br>    &#125;<br><span class=\"hljs-comment\">// 通知UI更新</span><br>    UiThreadUtil.runOnUiThread(<br>        <span class=\"hljs-keyword\">new</span> Runnable() &#123;<br>          @Override<br>          <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> run() &#123;<br>            <span class=\"hljs-keyword\">for</span> (ReactInstanceEventListener listener : finalListeners) &#123;<br>              listener.onReactContextInitialized(reactContext);<br>            &#125;<br>          &#125;<br>        &#125;);<br>    <span class=\"hljs-comment\">// 开启JS消息队列线程</span><br>    reactContext.runOnJSQueueThread(<br>        <span class=\"hljs-keyword\">new</span> Runnable() &#123;<br>          @Override<br>          <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> run() &#123;<br>            Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);<br>          &#125;<br>        &#125;);<br>    <span class=\"hljs-comment\">//开启Native消息队列线程</span><br>    reactContext.runOnNativeModulesQueueThread(<br>        <span class=\"hljs-keyword\">new</span> Runnable() &#123;<br>          @Override<br>          <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> run() &#123;<br>            Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);<br>          &#125;<br>        &#125;);<br>  &#125;<br><br>  <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> attachRootViewToInstance(<br>      <span class=\"hljs-keyword\">final</span> ReactRootView rootView,<br>      CatalystInstance catalystInstance) &#123;<br>       <span class=\"hljs-comment\">//通过UIManagerModule设置根布局为ReactRootView</span><br>    UIManagerModule uiManagerModule = catalystInstance.getNativeModule(UIManagerModule.<span class=\"hljs-keyword\">class</span>);<br>        <span class=\"hljs-comment\">//设置相关tag</span><br>    <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> rootTag = uiManagerModule.addRootView(rootView);<br>    rootView.setRootViewTag(rootTag);<br>      <span class=\"hljs-comment\">//Calls into JS to start the React application. </span><br>    rootView.invokeJSEntryPoint();<br>    ......<br>    UiThreadUtil.runOnUiThread(<span class=\"hljs-keyword\">new</span> Runnable() &#123;<br>      @Override<br>      <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> run() &#123;<br>        <span class=\"hljs-comment\">//</span><br>        rootView.onAttachedToReactInstance();<br>      &#125;<br>    &#125;);<br>  &#125;<br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">   * Calls the default entry point into JS which is AppRegistry.runApplication()</span><br><span class=\"hljs-comment\">   */</span><br>  <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> defaultJSEntryPoint() &#123;<br>      <span class=\"hljs-keyword\">try</span> &#123;<br>        <span class=\"hljs-keyword\">if</span> (mReactInstanceManager == <span class=\"hljs-literal\">null</span> || !mIsAttachedToInstance) &#123;<br>          <span class=\"hljs-keyword\">return</span>;<br>        &#125;<br>        ReactContext reactContext = mReactInstanceManager.getCurrentReactContext();<br>        <span class=\"hljs-keyword\">if</span> (reactContext == <span class=\"hljs-literal\">null</span>) &#123;<br>          <span class=\"hljs-keyword\">return</span>;<br>        &#125;<br>        CatalystInstance catalystInstance = reactContext.getCatalystInstance();<br>          <span class=\"hljs-comment\">// 包装相关参数，传给js，rootTag用来告诉js端对应的是native 端哪一个view</span><br>        WritableNativeMap appParams = <span class=\"hljs-keyword\">new</span> WritableNativeMap();<br>        appParams.putDouble(<span class=\"hljs-string\">&quot;rootTag&quot;</span>, getRootViewTag());<br>        @Nullable Bundle appProperties = getAppProperties();<br>        <span class=\"hljs-keyword\">if</span> (appProperties != <span class=\"hljs-literal\">null</span>) &#123;<br>          appParams.putMap(<span class=\"hljs-string\">&quot;initialProps&quot;</span>, Arguments.fromBundle(appProperties));<br>        &#125;<br>        ....<br>        <span class=\"hljs-comment\">//核心！！！ReactNative真正的启动流程就是在这里被调用起来的</span><br>        <span class=\"hljs-keyword\">String</span> jsAppModuleName = getJSModuleName();<br>        catalystInstance.getJSModule(AppRegistry.<span class=\"hljs-keyword\">class</span>).runApplication(jsAppModuleName, appParams);<br>      &#125; <span class=\"hljs-keyword\">finally</span> &#123;<br>        Systrace.endSection(TRACE_TAG_REACT_JAVA_BRIDGE);<br>      &#125;<br>  &#125;<br><br><span class=\"hljs-comment\">//`AppRegistry` is the JS entry point to running all React Native apps.  App</span><br><span class=\"hljs-comment\">// root components should register themselves with</span><br><span class=\"hljs-keyword\">var</span> AppRegistry = &#123;<br>    ......<br>    <span class=\"hljs-comment\">//我们JS端自己在index.android.js文件中调用的入口就是：</span><br>    <span class=\"hljs-comment\">//AppRegistry.registerComponent(&#x27;TestRN&#x27;, () =&gt; TestRN);</span><br>  registerComponent: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">appKey: <span class=\"hljs-keyword\">string</span>, getComponentFunc: ComponentProvider</span>): <span class=\"hljs-title\">string</span> </span>&#123;<br>    runnables[appKey] = &#123;<br>      run: (appParameters) =&gt;<br>        renderApplication(getComponentFunc(), appParameters.initialProps, appParameters.rootTag)<br>    &#125;;<br>    <span class=\"hljs-keyword\">return</span> appKey;<br>  &#125;,<br>    ......<br>    <span class=\"hljs-comment\">//上面java端 AppRegistry 调用的 JS 端就是这个方法，索引到我们设置的appkey=TestRN字符串的JS入口</span><br>  runApplication: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">appKey: <span class=\"hljs-keyword\">string</span>, appParameters: any</span>): <span class=\"hljs-title\">void</span> </span>&#123;<br>    ......<br>    runnables[appKey].run(appParameters);<br>  &#125;,<br>    ......<br>&#125;;<br><br></code></pre></div></td></tr></table></figure>\n\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>到这里ReactNative的启动流程就差不多了，我们小梳理总结，如下图：</p>\n<p><img src=\"https://i.loli.net/2018/11/18/5bf0e39e53802.jpg\" alt=\"img\">上面这幅图已经囊括了我们上面说到的启动流程的全部流程分析</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"ReactNative-启动流程\"><a href=\"#ReactNative-启动流程\" class=\"headerlink\" title=\"ReactNative-启动流程\"></a>ReactNative-启动流程</h1><h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>ReactNative在真机iOS和Android上，使用的是<strong>JavaScriptCore</strong>引擎，也就是Safari所使用的JavaScript引擎。但是在iOS上JavaScriptCore并没有使用即时编译技术（JIT），因为在iOS中应用无权拥有可写可执行的内存页（因而无法动态生成代码），在安卓上，理论上是可以使用的。JavaScriptCore引擎也是使用C++编写，在iOS和安卓中，JavaScriptCore都做了一层封装，可以无须关心引擎和系统桥接的那一层。iOS/Android系统通JavaScriptCore引擎将定制好的各种原生组件注入。我们编写少量Java代码大量JavaScript代码，中间作为桥梁的核心是 C/C++ 来处理的。</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2018/png/199077/1542525129415-a4873dbe-d967-4554-a866-aa6a275c2594.png\" alt=\"img\"></p>\n<h2 id=\"RN-启动流程框架浅析\"><a href=\"#RN-启动流程框架浅析\" class=\"headerlink\" title=\"RN 启动流程框架浅析\"></a>RN 启动流程框架浅析</h2><p>集成 RN 无非就是通过继承 ReactActivity 或者自己通过 ReactRootView 进行处理，但是实质都是触发了ReactRootView 的 startReactApplication 方法</p>\n<ul>\n<li>ReactActivity</li>\n</ul>\n<p>先来看看ReactActivity,明显的代理模式，实际操作全部交给了ReactActivityDelegate</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ReactActivity</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Activity</span></span><br><span class=\"hljs-class\">    <span class=\"hljs-title\">implements</span> <span class=\"hljs-title\">DefaultHardwareBackBtnHandler</span>, <span class=\"hljs-title\">PermissionAwareActivity</span> </span>&#123;<br>  <span class=\"hljs-keyword\">private</span> final ReactActivityDelegate mDelegate;<br>  <span class=\"hljs-keyword\">protected</span> <span class=\"hljs-function\"><span class=\"hljs-title\">ReactActivity</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    mDelegate = createReactActivityDelegate();<br>  &#125; <br>  <span class=\"hljs-meta\">@Override</span><br>  <span class=\"hljs-keyword\">protected</span> <span class=\"hljs-built_in\">void</span> <span class=\"hljs-function\"><span class=\"hljs-title\">onCreate</span>(<span class=\"hljs-params\">Bundle savedInstanceState</span>)</span> &#123;<br>    <span class=\"hljs-built_in\">super</span>.onCreate(savedInstanceState);<br>    mDelegate.onCreate(savedInstanceState);<br>  &#125;<br>  <span class=\"hljs-meta\">@Override</span><br>  <span class=\"hljs-keyword\">protected</span> <span class=\"hljs-built_in\">void</span> <span class=\"hljs-function\"><span class=\"hljs-title\">onPause</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-built_in\">super</span>.onPause();<br>    mDelegate.onPause();<br>  &#125;<br>  <span class=\"hljs-meta\">@Override</span><br>  <span class=\"hljs-keyword\">protected</span> <span class=\"hljs-built_in\">void</span> <span class=\"hljs-function\"><span class=\"hljs-title\">onResume</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-built_in\">super</span>.onResume();<br>    mDelegate.onResume();<br>  &#125;<br>   ..........<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>ReactActivityDelegate</li>\n</ul>\n<p>再来看看ReactActivityDelegate,可以看见，ReactActivityDelegate 只是一个抽出来的封装，上面的实质就是 new 了一个 ReactRootView（实质是 Android 的 FrameLayout），接着调用 ReactRootView 的 startReactApplication 方法，完事就像常规 Android 代码一样直接通过 Activity 的 setContentView 方法把 View 设置进去。所以可以看出来，RN 的神秘之处一定在于 ReactRootView 中，Activity 对于 RN 来说只是为了让 RN 依附符合 Android 的框架而已，所以说，说白了 RN 依旧是标准 Android，因此在我们集成开发中我们可以选择整个界面（包含多级跳转）都用 React Native 实现，或者一个 Android 现有界面中部分采用 React Native 实现，因为这货就是一个 View.</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ReactActivityDelegate</span> </span>&#123;<br><br>  <span class=\"hljs-keyword\">protected</span> <span class=\"hljs-built_in\">void</span> <span class=\"hljs-function\"><span class=\"hljs-title\">onCreate</span>(<span class=\"hljs-params\">Bundle savedInstanceState</span>)</span> &#123;<br>    <span class=\"hljs-comment\">//启动流程一定会执行的，mMainComponentName为我们设置的，与JS边保持一致</span><br>    <span class=\"hljs-keyword\">if</span> (mMainComponentName != <span class=\"hljs-literal\">null</span>) &#123;<br>      loadApp(mMainComponentName);<br>    &#125;<br>    mDoubleTapReloadRecognizer = <span class=\"hljs-keyword\">new</span> DoubleTapReloadRecognizer();<br>  &#125;<br><br>  <span class=\"hljs-keyword\">protected</span> <span class=\"hljs-built_in\">void</span> <span class=\"hljs-function\"><span class=\"hljs-title\">loadApp</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">String</span> appKey</span>)</span> &#123;<br>    <span class=\"hljs-keyword\">if</span> (mReactRootView != <span class=\"hljs-literal\">null</span>) &#123;<br>      <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IllegalStateException(<span class=\"hljs-string\">&quot;Cannot loadApp while app is already running.&quot;</span>);<br>    &#125;<br>    <span class=\"hljs-comment\">// createRootView其实就是create了一个FrameLayout，核心方法 </span><br>    mReactRootView = createRootView();<br>    mReactRootView.startReactApplication(<br>      getReactNativeHost().getReactInstanceManager(),<br>      appKey,<br>      getLaunchOptions());<br>    <span class=\"hljs-comment\">// 把view设置进Activity</span><br>    getPlainActivity().setContentView(mReactRootView);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>ReactRootView</li>\n</ul>\n<p>既然明白了 RN 就是个 View，那就接着看看 ReactRootView，如下：</p>\n<p>可以看见，ReactRootView的英文注释已经交代很清楚用途和地位了，直接看上面代码的startReactApplication 方法，可以看见他又调用了一个三个参数的同名方法，具体这三个参数来历如下（也是我们自己集成 RN 时手动 builder 模式创建的）：</p>\n<ol>\n<li><p>reactInstanceManager： 大内总管接口类，提供一个构造者模式的初始化 Builder, 这类也是我们在集成 RN 时 new ReactRootView 的之前自己创建的。 </p>\n</li>\n<li><p>moduleName： 与 JS 代码约定的 String 类型识别 name，JS 端通过 AppRegistry.registerComponent 方法设置这个 name，Java 端重写基类的 getMainComponentName 方法设置这个 name，这样两边入口就对上了。 </p>\n</li>\n<li><p>launchOptions： 这里默认是 null 的，如果自己不继承 ReactActivity 而自己实现的话可以通过这个参数在 startActivity 时传入一些参数到 JS 代码，用来依据参数初始化 JS 端代码。</p>\n</li>\n</ol>\n<p>可以看见接着调用了 mReactInstanceManager createReactContextInBackground 方法，mReactInstanceManager 就是上面说的第一个参数，实质是通过一个构造者模式创建的</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs scala\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> React Native 的 RootView，负责监听标准 Android 的 View 相关的事件分发和子View 渲染等。</span><br><span class=\"hljs-comment\"> */</span><br>public <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ReactRootView</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">SizeMonitoringFrameLayout</span> <span class=\"hljs-title\">implements</span> <span class=\"hljs-title\">RootView</span> </span>&#123;<br>  public void startReactApplication(<span class=\"hljs-type\">ReactInstanceManager</span> reactInstanceManager, <span class=\"hljs-type\">String</span> moduleName) &#123;<br>    startReactApplication(reactInstanceManager, moduleName, <span class=\"hljs-literal\">null</span>);<br>  &#125;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">调度react component的渲染，使用reactInstanceManager讲js模块attch到JS Context中。一些初始化参数可以通过launchOptions传递给react component</span><br><span class=\"hljs-comment\">*/</span><br>  public void startReactApplication(<br>      <span class=\"hljs-type\">ReactInstanceManager</span> reactInstanceManager,<br>      <span class=\"hljs-type\">String</span> moduleName,<br>      <span class=\"hljs-meta\">@Nullable</span> <span class=\"hljs-type\">Bundle</span> initialProperties) &#123;<br>    <span class=\"hljs-type\">Systrace</span>.beginSection(<span class=\"hljs-type\">TRACE_TAG_REACT_JAVA_BRIDGE</span>, <span class=\"hljs-string\">&quot;startReactApplication&quot;</span>);<br>    <span class=\"hljs-keyword\">try</span> &#123;<br>      <span class=\"hljs-type\">UiThreadUtil</span>.assertOnUiThread();<br>      <span class=\"hljs-type\">Assertions</span>.assertCondition(<br>        mReactInstanceManager == <span class=\"hljs-literal\">null</span>,<br>        <span class=\"hljs-string\">&quot;This root view has already been attached to a catalyst instance manager&quot;</span>);<br>      mReactInstanceManager = reactInstanceManager;<br>      mJSModuleName = moduleName;<br>      mAppProperties = initialProperties;<br>      <span class=\"hljs-comment\">// 核心创建ReactContext，先判断是否初始化了</span><br>      <span class=\"hljs-keyword\">if</span> (!mReactInstanceManager.hasStartedCreatingInitialContext()) &#123;<br>        mReactInstanceManager.createReactContextInBackground();<br>      &#125;<br>      attachToReactInstanceManager();<br>    &#125; <span class=\"hljs-keyword\">finally</span> &#123;<br>      <span class=\"hljs-type\">Systrace</span>.endSection(<span class=\"hljs-type\">TRACE_TAG_REACT_JAVA_BRIDGE</span>);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>ReactInstanceManager</li>\n</ul>\n<p>ReactInstanceManager的createReactContextInBackground 方法看看，如下：</p>\n<p>可以看到createReactContext经过一系列的包装，最终开启了一个新线程去创建ReactContext,先从initParams中获取JavaScriptExecutor和JsBundleLoader，JsBundleLoader负责JsBundle的加载，实际情况中我们可以修改加载起实现热更新。开始创建后，有几个核心方法createReactContext和setupReactContext，接下来我们来看看createReactContext:</p>\n<p>总的来说，createReactContext()把nativeModules注册到CatalysInstanceImpl里,然后把这两张映射表交给 CatalystInstanceImpl，同时包装创建 ReactContext 对象，然后通过 CatalystInstanceImpl 的 runJSBundle() 方法把 JS bundle 文件的 JS 代码加载进来等待 Task 结束以后调用 JS 入口进行渲染 RN。CatalystInstanceImpl 的 build 方法中调用的 CatalystInstanceImpl 构造方法到底干了什么</p>\n<p>build()中其实就是构造者模式，实例化CatalystInstanceImpl, CatalystInstanceImpl 就是个封装总管，负责了 Java 层代码到 JNI 封装初始化的任务和 Java 与 JS 调用的 Java 端控制中心。核心方法是initializeBridge,这是个native方法，我们看看他穿了什么参数进去：</p>\n<ol>\n<li><p>ReactCallBack是CatalystInstanceImpl 的内部静态实现类 BridgeCallback，负责相关接口回传和回</p>\n</li>\n<li><p>jsExecutor参数： 前面分析的 XReactInstanceManagerImpl 中赋值为 JSCJavaScriptExecutor 实例，JSCJavaScriptExecutor 中也有自己的 native initHybrid 的 C++ 方法被初始化时调用，具体在 OnLoad.cpp 的 JSCJavaScriptExecutorHolder 类中。 </p>\n</li>\n<li><p>jsQueue参数： 来自于 mReactQueueConfiguration.getJSQueueThread()，mReactQueueConfiguration就是 CatalystInstanceImpl 中创建的 ReactQueueConfigurationImpl.create( ReactQueueConfigurationSpec, new NativeExceptionHandler()); 第一个参数来自于 XReactInstanceManagerImpl 中 CatalystInstanceImpl 的建造者，实质为包装相关线程名字、类型等，然后通过 ReactQueueConfigurationImpl 的 create 创建对应线程的 Handler，这里就是名字为 js 的后台线程 Handler，第二个参数为异常捕获回调实现。 </p>\n</li>\n<li><p>moduleQueue参数： 来自于 mReactQueueConfiguration.getNativeModulesQueueThread（）mReactQueueConfiguration同上</p>\n</li>\n<li><p>javaModules: 来自mNativeModuleRegistry.getJavaModules(this),mNativeModuleRegistry就是构建CatalysInstanceImpl时传入的javaModules。</p>\n</li>\n<li><p>cxxModules：来自mNativeModuleRegistry.getCxxModules(),mNativeModuleRegistry就是构建CatalysInstanceImpl时传入的javaModules，获取c++模块</p>\n</li>\n</ol>\n<p>CatalystInstanceImpl 自己在 Java 层直接把持住了 JavaScriptModuleRegistry 映射表，把 NativeModuleRegistry 映射表、BridgeCallback 回调、JSCJavaScriptExecutor、js 队列 MessageQueueThread、native 队列 MessageQueueThread 都通过 JNI 嫁接到了 C++ 中。那我们现在先把目光转移到 CatalystInstanceImpl.cpp 的 initializeBridge 方法上（关于 JNI 的 OnLoad 中初始化注册模块等等就不介绍了），如下：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs typescript\"> <span class=\"hljs-meta\">@ThreadConfined</span>(UI)<br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-built_in\">void</span> <span class=\"hljs-function\"><span class=\"hljs-title\">recreateReactContextInBackground</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>   Assertions.assertCondition(<br>       mHasStartedCreatingInitialContext,<br>       <span class=\"hljs-string\">&quot;recreateReactContextInBackground should only be called after the initial &quot;</span> +<br>           <span class=\"hljs-string\">&quot;createReactContextInBackground call.&quot;</span>);<br>   recreateReactContextInBackgroundInner();<br> &#125;<br><br><span class=\"hljs-meta\">@ThreadConfined</span>(UI)<br> <span class=\"hljs-keyword\">private</span> <span class=\"hljs-built_in\">void</span> <span class=\"hljs-function\"><span class=\"hljs-title\">recreateReactContextInBackgroundInner</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>   <span class=\"hljs-keyword\">if</span> (mUseDeveloperSupport<br>       &amp;&amp; mJSMainModulePath != <span class=\"hljs-literal\">null</span><br>       &amp;&amp; !Systrace.isTracing(TRACE_TAG_REACT_APPS | TRACE_TAG_REACT_JS_VM_CALLS)) &#123;<br>     final DeveloperSettings devSettings = mDevSupportManager.getDevSettings();<br><br>     <span class=\"hljs-comment\">// If remote JS debugging is enabled, load from dev server.</span><br>     <span class=\"hljs-keyword\">if</span> (mDevSupportManager.hasUpToDateJSBundleInCache() &amp;&amp;<br>         !devSettings.isRemoteJSDebugEnabled()) &#123;<br>       <span class=\"hljs-comment\">// If there is a up-to-date bundle downloaded from server,</span><br>       <span class=\"hljs-comment\">// with remote JS debugging disabled, always use that.</span><br>       ........<br>     <span class=\"hljs-keyword\">return</span>;<br>   &#125;<br>    <span class=\"hljs-comment\">//非调试模式，真实环境下去加载Bundle</span><br>   recreateReactContextInBackgroundFromBundleLoader();<br> &#125;<br>     <br> <span class=\"hljs-keyword\">public</span> <span class=\"hljs-built_in\">void</span> <span class=\"hljs-function\"><span class=\"hljs-title\">createReactContextInBackground</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>   ......<br>   recreateReactContextInBackgroundInner();<br> &#125;<br><br> <span class=\"hljs-keyword\">private</span> <span class=\"hljs-built_in\">void</span> <span class=\"hljs-function\"><span class=\"hljs-title\">recreateReactContextInBackgroundInner</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>   UiThreadUtil.assertOnUiThread();<br>   <br>   <span class=\"hljs-keyword\">if</span> (mUseDeveloperSupport &amp;&amp; mJSMainModuleName != <span class=\"hljs-literal\">null</span>) &#123;<br>   <span class=\"hljs-comment\">//如果是 dev 模式，BuildConfig.DEBUG=true就走这里，在线更新bundle，手机晃动出现调试菜单等等。</span><br>   <span class=\"hljs-comment\">//这个路线属于RN调试流程原理，后面再写文章分析，这里我们抓住主线分析</span><br> ......<br> <span class=\"hljs-keyword\">return</span>;<br>&#125;<br>    <span class=\"hljs-comment\">//非调试模式，即BuildConfig.DEBUG=false时执行</span><br>    recreateReactContextInBackgroundFromBundleLoader();<br>&#125;<br><br><span class=\"hljs-keyword\">private</span> <span class=\"hljs-built_in\">void</span> <span class=\"hljs-function\"><span class=\"hljs-title\">recreateReactContextInBackgroundFromBundleLoader</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>   <span class=\"hljs-comment\">//在后台创建ReactContext，两个参数是重点。</span><br>   <span class=\"hljs-comment\">//包装了JavaScript执行上下文的JavaScriptExecutorFactory</span><br>   <span class=\"hljs-comment\">//自定义热更新时setJSBundleFile方法参数就是巧妙的利用这里是走JSBundleLoader.createAssetLoader还是JSBundleLoader.createFileLoader！！！！！！</span><br>     recreateReactContextInBackground(mJavaScriptExecutorFactory, mBundleLoader);<br>&#125;<br><br><span class=\"hljs-meta\">@ThreadConfined</span>(UI)<br> <span class=\"hljs-keyword\">private</span> <span class=\"hljs-built_in\">void</span> <span class=\"hljs-function\"><span class=\"hljs-title\">recreateReactContextInBackground</span>(<span class=\"hljs-params\"></span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">   JavaScriptExecutorFactory jsExecutorFactory,</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">   JSBundleLoader jsBundleLoader</span>)</span> &#123;<br>     <span class=\"hljs-comment\">//包装一下JsExecutorFactor</span><br>   final ReactContextInitParams initParams = <span class=\"hljs-keyword\">new</span> ReactContextInitParams(<br>     jsExecutorFactory,<br>     jsBundleLoader);<br>     <span class=\"hljs-comment\">// 开线程差创建ReactContext</span><br>   <span class=\"hljs-keyword\">if</span> (mCreateReactContextThread == <span class=\"hljs-literal\">null</span>) &#123;<br>     runCreateReactContextOnNewThread(initParams);<br>   &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>     mPendingReactContextInitParams = initParams;<br>   &#125;<br> &#125;<br><br> <span class=\"hljs-meta\">@ThreadConfined</span>(UI)<br> <span class=\"hljs-keyword\">private</span> <span class=\"hljs-built_in\">void</span> <span class=\"hljs-function\"><span class=\"hljs-title\">runCreateReactContextOnNewThread</span>(<span class=\"hljs-params\">final ReactContextInitParams initParams</span>)</span> &#123;<br>   .....<br>   <span class=\"hljs-comment\">//开线程创建ReactContext</span><br>   mCreateReactContextThread =<br>       <span class=\"hljs-keyword\">new</span> Thread(<br>           <span class=\"hljs-keyword\">new</span> <span class=\"hljs-function\"><span class=\"hljs-title\">Runnable</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>             <span class=\"hljs-meta\">@Override</span><br>             <span class=\"hljs-keyword\">public</span> <span class=\"hljs-built_in\">void</span> <span class=\"hljs-function\"><span class=\"hljs-title\">run</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>           .....<br>               <span class=\"hljs-keyword\">try</span> &#123;<br>                 Process.setThreadPriority(Process.THREAD_PRIORITY_DISPLAY);<br>                 <span class=\"hljs-comment\">//创建ReactContext的核心方法，createReactContext</span><br>                 final ReactApplicationContext reactApplicationContext =<br>                     createReactContext(<br>                         initParams.getJsExecutorFactory().create(),<br>                         initParams.getJsBundleLoader());<br><br>                 mCreateReactContextThread = <span class=\"hljs-literal\">null</span>;<br>                 <br>                 final Runnable maybeRecreateReactContextRunnable =<br>                     <span class=\"hljs-keyword\">new</span> <span class=\"hljs-function\"><span class=\"hljs-title\">Runnable</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>                       <span class=\"hljs-meta\">@Override</span><br>                       <span class=\"hljs-keyword\">public</span> <span class=\"hljs-built_in\">void</span> <span class=\"hljs-function\"><span class=\"hljs-title\">run</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>                         <span class=\"hljs-keyword\">if</span> (mPendingReactContextInitParams != <span class=\"hljs-literal\">null</span>) &#123;<br>                           runCreateReactContextOnNewThread(mPendingReactContextInitParams);<br>                           mPendingReactContextInitParams = <span class=\"hljs-literal\">null</span>;<br>                         &#125;<br>                       &#125;<br>                 &#125;;<br>                 Runnable setupReactContextRunnable =<br>                     <span class=\"hljs-keyword\">new</span> <span class=\"hljs-function\"><span class=\"hljs-title\">Runnable</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>                       <span class=\"hljs-meta\">@Override</span><br>                       <span class=\"hljs-keyword\">public</span> <span class=\"hljs-built_in\">void</span> <span class=\"hljs-function\"><span class=\"hljs-title\">run</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>                         <span class=\"hljs-keyword\">try</span> &#123;<br>                           setupReactContext(reactApplicationContext);<br>                         &#125; <span class=\"hljs-keyword\">catch</span> (Exception e) &#123;<br>                           mDevSupportManager.handleException(e);<br>                         &#125;<br>                       &#125;<br>                  &#125;;<br>        reactApplicationContext.runOnNativeModulesQueueThread(setupReactContextRunnable);<br>                 UiThreadUtil.runOnUiThread(maybeRecreateReactContextRunnable);<br>               &#125; <span class=\"hljs-keyword\">catch</span> (Exception e) &#123;<br>                 mDevSupportManager.handleException(e);<br>               &#125;<br>             &#125;<br>           &#125;);<br>   mCreateReactContextThread.start();<br> &#125;<br>  <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">   * <span class=\"hljs-doctag\">@return </span>instance of &#123;<span class=\"hljs-doctag\">@link </span>ReactContext&#125; configured a &#123;<span class=\"hljs-doctag\">@link </span>CatalystInstance&#125; set</span><br><span class=\"hljs-comment\">   */</span><br>  <span class=\"hljs-keyword\">private</span> ReactApplicationContext <span class=\"hljs-function\"><span class=\"hljs-title\">createReactContext</span>(<span class=\"hljs-params\"></span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">      JavaScriptExecutor jsExecutor,</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">      JSBundleLoader jsBundleLoader</span>)</span> &#123;<br>    final ReactApplicationContext reactContext = <span class=\"hljs-keyword\">new</span> ReactApplicationContext(mApplicationContext);<br><span class=\"hljs-comment\">// 是否处于开发者模式，提供一些异常处理的机制，捕获崩溃显示在红色弹窗</span><br>    <span class=\"hljs-keyword\">if</span> (mUseDeveloperSupport) &#123;<br>      reactContext.setNativeModuleCallExceptionHandler(mDevSupportManager);<br>    &#125;<br><span class=\"hljs-comment\">// Java层模块注册表，通过它把NativeModules注册到CatalystInstance.包括我们自定义的继承自NativeModule的Java代码</span><br>    NativeModuleRegistry nativeModuleRegistry = processPackages(reactContext, mPackages, <span class=\"hljs-literal\">false</span>);<br><span class=\"hljs-comment\">// 异常处理Handler</span><br>      NativeModuleCallExceptionHandler exceptionHandler = mNativeModuleCallExceptionHandler != <span class=\"hljs-literal\">null</span><br>      ? mNativeModuleCallExceptionHandler<br>      : mDevSupportManager;<br><span class=\"hljs-comment\">// 开始构建CatalystInstance </span><br>    CatalystInstanceImpl.Builder catalystInstanceBuilder = <span class=\"hljs-keyword\">new</span> CatalystInstanceImpl.Builder()<br>      .setReactQueueConfigurationSpec(ReactQueueConfigurationSpec.createDefault())<br>      .setJSExecutor(jsExecutor)<br>      .setRegistry(nativeModuleRegistry)<br>      .setJSBundleLoader(jsBundleLoader)<br>      .setNativeModuleCallExceptionHandler(exceptionHandler);<br>    ........<br>    catalystInstance.runJSBundle();<br>    reactContext.initializeWithInstance(catalystInstance);<br><br>    <span class=\"hljs-keyword\">return</span> reactContext;<br>  &#125;<br><span class=\"hljs-keyword\">private</span> <span class=\"hljs-function\"><span class=\"hljs-title\">CatalystInstanceImpl</span>(<span class=\"hljs-params\"></span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">      final ReactQueueConfigurationSpec reactQueueConfigurationSpec,</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">      final JavaScriptExecutor jsExecutor,</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">      final NativeModuleRegistry nativeModuleRegistry,</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">      final JSBundleLoader jsBundleLoader,</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">      NativeModuleCallExceptionHandler nativeModuleCallExceptionHandler</span>)</span> &#123;<br>    Log.d(ReactConstants.TAG, <span class=\"hljs-string\">&quot;Initializing React Xplat Bridge.&quot;</span>);<br>    mHybridData = initHybrid();<br><br>    mReactQueueConfiguration = ReactQueueConfigurationImpl.create(<br>        reactQueueConfigurationSpec,<br>        <span class=\"hljs-keyword\">new</span> NativeExceptionHandler());<br>    mBridgeIdleListeners = <span class=\"hljs-keyword\">new</span> CopyOnWriteArrayList&lt;&gt;();<br>    mNativeModuleRegistry = nativeModuleRegistry;<br>    mJSModuleRegistry = <span class=\"hljs-keyword\">new</span> JavaScriptModuleRegistry();<br>    mJSBundleLoader = jsBundleLoader;<br>    mNativeModuleCallExceptionHandler = nativeModuleCallExceptionHandler;<br>    mNativeModulesQueueThread = mReactQueueConfiguration.getNativeModulesQueueThread();<br>    mTraceListener = <span class=\"hljs-keyword\">new</span> JSProfilerTraceListener(<span class=\"hljs-built_in\">this</span>);<br><br>    Log.d(ReactConstants.TAG, <span class=\"hljs-string\">&quot;Initializing React Xplat Bridge before initializeBridge&quot;</span>);<br>    initializeBridge(<br>      <span class=\"hljs-keyword\">new</span> BridgeCallback(<span class=\"hljs-built_in\">this</span>),<br>      jsExecutor,<br>      mReactQueueConfiguration.getJSQueueThread(),<br>      mNativeModulesQueueThread,<br>      mNativeModuleRegistry.getJavaModules(<span class=\"hljs-built_in\">this</span>),<br>      mNativeModuleRegistry.getCxxModules());<br>    Log.d(ReactConstants.TAG, <span class=\"hljs-string\">&quot;Initializing React Xplat Bridge after initializeBridge&quot;</span>);<br><br>    mJavaScriptContextHolder = <span class=\"hljs-keyword\">new</span> JavaScriptContextHolder(getJavaScriptContext());<br>  &#125;<br>  <br>    <span class=\"hljs-keyword\">private</span> native <span class=\"hljs-built_in\">void</span> initializeBridge(<br>      ReactCallback callback,<br>      JavaScriptExecutor jsExecutor,<br>      MessageQueueThread jsQueue,<br>      MessageQueueThread moduleQueue,<br>      Collection&lt;JavaModuleWrapper&gt; javaModules,<br>      Collection&lt;ModuleHolder&gt; cxxModules);<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>CatalystInstance</li>\n</ul>\n<p>到此 CatalystInstance 的实例 CatalystInstanceImpl 对象也就初始化 OK 了，同时通过 initializeBridge 建立了 Bridge 连接。关于这个 Bridge 在RN 中是通过 libjsc.so 中 JSObjectRef.h 的 JSObjectSetProperty(m_context, globalObject, jsPropertyName, valueToInject, 0, NULL); 来关联的，这样就可以在 Native 设置 JS 执行，反之同理。</p>\n<p>这一小节我们只讨论 RN 的加载启动流程，所以 initializeBridge 的具体实现我们下面分析互相通信交互时再仔细分析，故我们先把思路还是回到 XReactInstanceManagerImpl 中 createReactContext 方法的 reactContext.initializeWithInstance(catalystInstance); 一行，可以看见，这行代码意思就是将刚刚初始化的 catalystInstance 传递给全局唯一的 reactContext 对象，同时在 reactContext 中通过 catalystInstance 拿到 JS、Native、UI 几个 Thread 的引用，方便快速访问使用这些对象。接着调用了 catalystInstance.runJSBundle(); 方法，这个方法实现如下：</p>\n<p>通过注释我们假设 Loader 是默认的，也即 JSBundleLoader 类的如下方法：</p>\n<p>可以看见，它实质又调用了 CatalystInstanceImpl 的 loadScriptFromAssets 方法，我们继续跟踪 CatalystInstanceImpl 的这个方法吧，如下：</p>\n<p>说白了就是 CatalystInstanceImpl.java 中 CatalystInstanceImpl 构造方法中调用 C++ 的 initializeBridge 方法时传入的第一个参数 BridgeCallback 么，就是说 JS bundle 文件被加载完成以后 JS 端调用 Java 端时会触发 Callback 的 onBatchComplete 方法，这货最终又会触发 OnBatchCompleteListener 接口的 onBatchComplete 方法，这不就把 JS Bundle 文件加载完成以后回调 Java 通知 OK 了么。最后我们还差一个runCreateContextOnNewThread中的setupReactContext任务还没分析，方法如下：</p>\n<p>这里的核心在rootView.invokeJsEntryPoint(),追踪一下源码，发现最后调用了如下方法</p>\n<p>我们知道 AppRegistry.class 是 JS 端暴露给 Java 端的接口方法，所以catalystInstance.getJSModule(AppRegistry.class) 实质就桥接到 JS 端代码去了，那就去看看AppRegistry中写了写啥</p>\n<p>到这里ReactNative的启动终于到头了，但react-native还有很多细节，这里先介绍React’Native的启动流程，搭建去Bridge，至于通信方式在后面继续介绍。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs php\"><span class=\"hljs-keyword\">void</span> CatalystInstanceImpl::initializeBridge(<br>    jni::alias_ref&lt;ReactCallback::javaobject&gt; callback,<br>    <span class=\"hljs-comment\">// This executor is actually a factory holder.</span><br>    JavaScriptExecutorHolder* jseh,<br>    jni::alias_ref&lt;JavaMessageQueueThread::javaobject&gt; jsQueue,<br>    jni::alias_ref&lt;JavaMessageQueueThread::javaobject&gt; moduleQueue,<br>    ModuleRegistryHolder* mrh) &#123;<br>    ......<br>  <span class=\"hljs-comment\">// Java CatalystInstanceImpl -&gt; C++ CatalystInstanceImpl -&gt; Bridge -&gt; Bridge::Callback</span><br>  <span class=\"hljs-comment\">// --weak--&gt; ReactCallback -&gt; Java CatalystInstanceImpl</span><br>    ......<br>    <span class=\"hljs-comment\">//instance_为ReactCommon目录下 Instance.h 中类的实例；</span><br>    <span class=\"hljs-comment\">//第一个参数为JInstanceCallback实现类，父类在cxxreact/Instance.h中。</span><br>    <span class=\"hljs-comment\">//第二个参数为JavaScriptExecutorHolder，实质对应java中JavaScriptExecutor，也就是上面分析java的initializeBridge方法第二个参数JSCJavaScriptExecutor。</span><br>    <span class=\"hljs-comment\">//第三第四个参数都是java线程透传到C++，纯C++的JMessageQueueThread。</span><br>    <span class=\"hljs-comment\">//第五个参数为C++的ModuleRegistryHolder的getModuleRegistry()方法。</span><br>  instance_-&gt;initializeBridge(folly::make_unique&lt;JInstanceCallback&gt;(callback),<br>                              jseh-&gt;getExecutorFactory(),<br>                              folly::make_unique&lt;JMessageQueueThread&gt;(jsQueue),<br>                              folly::make_unique&lt;JMessageQueueThread&gt;(moduleQueue),<br>                              mrh-&gt;getModuleRegistry());<br>&#125;<br>@Override<br>  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> runJSBundle() &#123;<br>    ......<br>    mJSBundleHasLoaded = <span class=\"hljs-literal\">true</span>;<br>    <span class=\"hljs-comment\">//mJSBundleLoader就是前面分析的依据不同设置决定是JSBundleLoader的createAssetLoader还是createFileLoader等静态方法的匿名实现类。</span><br>    <span class=\"hljs-comment\">// incrementPendingJSCalls();</span><br>    mJSBundleLoader.loadScript(CatalystInstanceImpl.this);<br>    ......<br>  &#125;<br><span class=\"hljs-keyword\">public</span> <span class=\"hljs-built_in\">static</span> JSBundleLoader createAssetLoader(<br>      <span class=\"hljs-keyword\">final</span> Context context,<br>      <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">String</span> assetUrl) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> JSBundleLoader() &#123;<br>      @Override<br>      <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> loadScript(CatalystInstanceImpl instance) &#123;<br>        instance.loadScriptFromAssets(context.getAssets(), assetUrl);<br>      &#125;<br><br>​```<br>  @Override<br>  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">String</span> getSourceUrl() &#123;<br>    <span class=\"hljs-keyword\">return</span> assetUrl;<br>  &#125;<br>&#125;;<br>  &#125;<br>native <span class=\"hljs-keyword\">void</span> loadScriptFromAssets(AssetManager assetManager, <span class=\"hljs-keyword\">String</span> assetURL);<br><span class=\"hljs-number\">1</span><br>loadScriptFromAssets 既然是一个 native 方法，我们去 CatalystInstanceImpl.cpp 看下这个方法的实现，如下：<br><br><span class=\"hljs-keyword\">void</span> CatalystInstanceImpl::loadScriptFromAssets(jobject assetManager,<br>                                                <span class=\"hljs-keyword\">const</span> std::string&amp; assetURL) &#123;<br>  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">int</span> kAssetsLength = <span class=\"hljs-number\">9</span>;  <span class=\"hljs-comment\">// strlen(&quot;assets://&quot;);</span><br>  <span class=\"hljs-comment\">//获取source路径名，不计前缀，这里默认就是index.android.bundle</span><br>  auto sourceURL = assetURL.substr(kAssetsLength);<br>    <span class=\"hljs-comment\">//assetManager是Java传递的AssetManager。</span><br>    <span class=\"hljs-comment\">//extractAssetManager是JSLoader.cpp中通过系统动态链接库android/asset_manager_jni.h的AAssetManager_fromJava方法来获取AAssetManager对象的。</span><br>  auto manager = react::extractAssetManager(assetManager);<br>    <span class=\"hljs-comment\">//通过JSLoader对象的loadScriptFromAssets方法读文件，得到大字符串script（即index.android.bundle文件的JS内容）。</span><br>  auto script = react::loadScriptFromAssets(manager, sourceURL);<br>    <span class=\"hljs-comment\">//判断是不是Unbundle，这里不是Unbundle，因为打包命令我们用了react.gradle的默认bundle，没用unbundle命令（感兴趣的自己分析这条路线）。</span><br>  <span class=\"hljs-keyword\">if</span> (JniJSModulesUnbundle::isUnbundle(manager, sourceURL)) &#123;<br>    instance_-&gt;loadUnbundle(<br>      folly::make_unique&lt;JniJSModulesUnbundle&gt;(manager, sourceURL),<br>      std::move(script),<br>      sourceURL);<br>    <span class=\"hljs-keyword\">return</span>;<br>  &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>    <span class=\"hljs-comment\">//bundle命令打包的，所以走这里。</span><br>    <span class=\"hljs-comment\">//instance_为ReactCommon目录下 Instance.h 中类的实例，前面分析过了。</span><br>    instance_-&gt;loadScriptFromString(std::move(script), sourceURL);<br>  &#125;<br>&#125;<br><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> setupReactContext(<span class=\"hljs-keyword\">final</span> ReactApplicationContext reactContext) &#123;<br><br>    <span class=\"hljs-comment\">//Initialize all the native modules</span><br>    catalystInstance.initialize();<br>    <span class=\"hljs-comment\">//重置devSupportManager中的reactContext</span><br>    mDevSupportManager.onNewReactContextCreated(reactContext);<br>    mMemoryPressureRouter.addMemoryPressureListener(catalystInstance);<br>    <span class=\"hljs-comment\">//置位生命周期</span><br>    moveReactContextToCurrentLifecycleState();<br><span class=\"hljs-comment\">// 核心方法</span><br>    synchronized (mAttachedRootViews) &#123;<br>      <span class=\"hljs-keyword\">for</span> (ReactRootView rootView : mAttachedRootViews) &#123;<br>        attachRootViewToInstance(rootView, catalystInstance);<br>      &#125;<br>    &#125;<br><span class=\"hljs-comment\">// 通知UI更新</span><br>    UiThreadUtil.runOnUiThread(<br>        <span class=\"hljs-keyword\">new</span> Runnable() &#123;<br>          @Override<br>          <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> run() &#123;<br>            <span class=\"hljs-keyword\">for</span> (ReactInstanceEventListener listener : finalListeners) &#123;<br>              listener.onReactContextInitialized(reactContext);<br>            &#125;<br>          &#125;<br>        &#125;);<br>    <span class=\"hljs-comment\">// 开启JS消息队列线程</span><br>    reactContext.runOnJSQueueThread(<br>        <span class=\"hljs-keyword\">new</span> Runnable() &#123;<br>          @Override<br>          <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> run() &#123;<br>            Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);<br>          &#125;<br>        &#125;);<br>    <span class=\"hljs-comment\">//开启Native消息队列线程</span><br>    reactContext.runOnNativeModulesQueueThread(<br>        <span class=\"hljs-keyword\">new</span> Runnable() &#123;<br>          @Override<br>          <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> run() &#123;<br>            Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);<br>          &#125;<br>        &#125;);<br>  &#125;<br><br>  <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> attachRootViewToInstance(<br>      <span class=\"hljs-keyword\">final</span> ReactRootView rootView,<br>      CatalystInstance catalystInstance) &#123;<br>       <span class=\"hljs-comment\">//通过UIManagerModule设置根布局为ReactRootView</span><br>    UIManagerModule uiManagerModule = catalystInstance.getNativeModule(UIManagerModule.<span class=\"hljs-keyword\">class</span>);<br>        <span class=\"hljs-comment\">//设置相关tag</span><br>    <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span> rootTag = uiManagerModule.addRootView(rootView);<br>    rootView.setRootViewTag(rootTag);<br>      <span class=\"hljs-comment\">//Calls into JS to start the React application. </span><br>    rootView.invokeJSEntryPoint();<br>    ......<br>    UiThreadUtil.runOnUiThread(<span class=\"hljs-keyword\">new</span> Runnable() &#123;<br>      @Override<br>      <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> run() &#123;<br>        <span class=\"hljs-comment\">//</span><br>        rootView.onAttachedToReactInstance();<br>      &#125;<br>    &#125;);<br>  &#125;<br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">   * Calls the default entry point into JS which is AppRegistry.runApplication()</span><br><span class=\"hljs-comment\">   */</span><br>  <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> defaultJSEntryPoint() &#123;<br>      <span class=\"hljs-keyword\">try</span> &#123;<br>        <span class=\"hljs-keyword\">if</span> (mReactInstanceManager == <span class=\"hljs-literal\">null</span> || !mIsAttachedToInstance) &#123;<br>          <span class=\"hljs-keyword\">return</span>;<br>        &#125;<br>        ReactContext reactContext = mReactInstanceManager.getCurrentReactContext();<br>        <span class=\"hljs-keyword\">if</span> (reactContext == <span class=\"hljs-literal\">null</span>) &#123;<br>          <span class=\"hljs-keyword\">return</span>;<br>        &#125;<br>        CatalystInstance catalystInstance = reactContext.getCatalystInstance();<br>          <span class=\"hljs-comment\">// 包装相关参数，传给js，rootTag用来告诉js端对应的是native 端哪一个view</span><br>        WritableNativeMap appParams = <span class=\"hljs-keyword\">new</span> WritableNativeMap();<br>        appParams.putDouble(<span class=\"hljs-string\">&quot;rootTag&quot;</span>, getRootViewTag());<br>        @Nullable Bundle appProperties = getAppProperties();<br>        <span class=\"hljs-keyword\">if</span> (appProperties != <span class=\"hljs-literal\">null</span>) &#123;<br>          appParams.putMap(<span class=\"hljs-string\">&quot;initialProps&quot;</span>, Arguments.fromBundle(appProperties));<br>        &#125;<br>        ....<br>        <span class=\"hljs-comment\">//核心！！！ReactNative真正的启动流程就是在这里被调用起来的</span><br>        <span class=\"hljs-keyword\">String</span> jsAppModuleName = getJSModuleName();<br>        catalystInstance.getJSModule(AppRegistry.<span class=\"hljs-keyword\">class</span>).runApplication(jsAppModuleName, appParams);<br>      &#125; <span class=\"hljs-keyword\">finally</span> &#123;<br>        Systrace.endSection(TRACE_TAG_REACT_JAVA_BRIDGE);<br>      &#125;<br>  &#125;<br><br><span class=\"hljs-comment\">//`AppRegistry` is the JS entry point to running all React Native apps.  App</span><br><span class=\"hljs-comment\">// root components should register themselves with</span><br><span class=\"hljs-keyword\">var</span> AppRegistry = &#123;<br>    ......<br>    <span class=\"hljs-comment\">//我们JS端自己在index.android.js文件中调用的入口就是：</span><br>    <span class=\"hljs-comment\">//AppRegistry.registerComponent(&#x27;TestRN&#x27;, () =&gt; TestRN);</span><br>  registerComponent: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">appKey: <span class=\"hljs-keyword\">string</span>, getComponentFunc: ComponentProvider</span>): <span class=\"hljs-title\">string</span> </span>&#123;<br>    runnables[appKey] = &#123;<br>      run: (appParameters) =&gt;<br>        renderApplication(getComponentFunc(), appParameters.initialProps, appParameters.rootTag)<br>    &#125;;<br>    <span class=\"hljs-keyword\">return</span> appKey;<br>  &#125;,<br>    ......<br>    <span class=\"hljs-comment\">//上面java端 AppRegistry 调用的 JS 端就是这个方法，索引到我们设置的appkey=TestRN字符串的JS入口</span><br>  runApplication: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">appKey: <span class=\"hljs-keyword\">string</span>, appParameters: any</span>): <span class=\"hljs-title\">void</span> </span>&#123;<br>    ......<br>    runnables[appKey].run(appParameters);<br>  &#125;,<br>    ......<br>&#125;;<br><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>到这里ReactNative的启动流程就差不多了，我们小梳理总结，如下图：</p>\n<p><img src=\"https://i.loli.net/2018/11/18/5bf0e39e53802.jpg\" alt=\"img\">上面这幅图已经囊括了我们上面说到的启动流程的全部流程分析</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"ckqou4ee800017mmz5rna4a3b","category_id":"ckqou869n00017zmz560u1kxn","_id":"ckqouf54l0003v5mz47ah9jd9"},{"post_id":"ckqou4ee300007mmzgirm13xr","category_id":"ckqou869n00017zmz560u1kxn","_id":"ckqoufgtc0004v5mz338m9z41"},{"post_id":"ckqoti0aw00031xmz3q40c591","category_id":"ckqoufqrb0005v5mz4pzt4af3","_id":"ckqoufqrc0006v5mz2lm4325i"},{"post_id":"ckqotlggo00002zmzhhf1356a","category_id":"ckqoufqrb0005v5mz4pzt4af3","_id":"ckqoufzdi0007v5mz95q0fykh"},{"post_id":"ckqoti0aq00001xmz7ir634we","category_id":"ckqoufqrb0005v5mz4pzt4af3","_id":"ckqoug1q60008v5mz8e2h6w8e"},{"post_id":"ckqoti0au00011xmzevlndn7o","category_id":"ckqoufqrb0005v5mz4pzt4af3","_id":"ckqoug5180009v5mzayhs8dw0"},{"post_id":"ckqoti0ax00041xmz62lydneh","category_id":"ckqoufqrb0005v5mz4pzt4af3","_id":"ckqoukdjq000av5mze34xcjez"},{"post_id":"ckqoti0b200071xmz8eqdbmdh","category_id":"ckqoufqrb0005v5mz4pzt4af3","_id":"ckqoukgl6000bv5mzenxt6y48"}],"PostTag":[{"post_id":"ckqoti0aw00031xmz3q40c591","tag_id":"ckqoutcqw000cv5mz3i1nf3st","_id":"ckqoutcqy000dv5mzb47r3wxn"},{"post_id":"ckqoti0aw00031xmz3q40c591","tag_id":"ckqoutmi9000ev5mzen7x1a89","_id":"ckqoutmi9000fv5mz5jv6cnfq"},{"post_id":"ckqotlggo00002zmzhhf1356a","tag_id":"ckqoutcqw000cv5mz3i1nf3st","_id":"ckqoutueg000gv5mz3f395zgf"},{"post_id":"ckqotlggo00002zmzhhf1356a","tag_id":"ckqoutmi9000ev5mzen7x1a89","_id":"ckqoutueg000hv5mzhaplhvtt"},{"post_id":"ckqoti0aq00001xmz7ir634we","tag_id":"ckqoutcqw000cv5mz3i1nf3st","_id":"ckqoutxcn000iv5mzcha4fmir"},{"post_id":"ckqoti0aq00001xmz7ir634we","tag_id":"ckqoutmi9000ev5mzen7x1a89","_id":"ckqoutxco000jv5mze5mverta"},{"post_id":"ckqoti0au00011xmzevlndn7o","tag_id":"ckqoutcqw000cv5mz3i1nf3st","_id":"ckqouu08r000kv5mz0ovd7ibf"},{"post_id":"ckqoti0au00011xmzevlndn7o","tag_id":"ckqoutmi9000ev5mzen7x1a89","_id":"ckqouu08r000lv5mzaye47ow6"},{"post_id":"ckqoti0ax00041xmz62lydneh","tag_id":"ckqoutcqw000cv5mz3i1nf3st","_id":"ckqouu7dp000nv5mz7ppa4hrm"},{"post_id":"ckqoti0ax00041xmz62lydneh","tag_id":"ckqoutmi9000ev5mzen7x1a89","_id":"ckqouu7dp000ov5mz8bli30s5"},{"post_id":"ckqoti0ax00041xmz62lydneh","tag_id":"ckqouu7do000mv5mzfxpb88ea","_id":"ckqouu7dp000pv5mz5sd0392p"},{"post_id":"ckqoti0b200071xmz8eqdbmdh","tag_id":"ckqoutcqw000cv5mz3i1nf3st","_id":"ckqouubu8000qv5mz6vkhhv2w"},{"post_id":"ckqoti0b200071xmz8eqdbmdh","tag_id":"ckqoutmi9000ev5mzen7x1a89","_id":"ckqouubu9000rv5mzedx5hvg1"},{"post_id":"ckqoti0b200071xmz8eqdbmdh","tag_id":"ckqouuhut000sv5mz3sipco53","_id":"ckqouuhuu000tv5mz1b2b8gp4"},{"post_id":"ckqou4ee300007mmzgirm13xr","tag_id":"ckqouuxw5000wv5mz7hj79me9","_id":"ckqouuxw5000xv5mzbjxvdx93"},{"post_id":"ckqou4ee800017mmz5rna4a3b","tag_id":"ckqouuxw5000wv5mz7hj79me9","_id":"ckqov1e4o00003fmz13nx3wfo"}],"Tag":[{"name":"区块链","_id":"ckqoutcqw000cv5mz3i1nf3st"},{"name":"比特币","_id":"ckqoutmi9000ev5mzen7x1a89"},{"name":"以太坊","_id":"ckqouu7do000mv5mzfxpb88ea"},{"name":"智能合约","_id":"ckqouuhut000sv5mz3sipco53"},{"name":"React Native","_id":"ckqouuxw5000wv5mz7hj79me9"}]}}